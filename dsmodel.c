#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model CHEETA.Examples.CHEETAElectricalSystem.SingleBranch_AveragedHalfBridge
 Dymola Version 2020 (64-bit), 2019-04-10 translated this at Mon Dec  2 11:12:09 2019

   */

#include <matrixop.h>
#if defined(DynSimStruct) || defined(BUILDFMU)
static double DymArrays0[3]={2.0, 2.0, 1.0};
static double DymArrays1[3]={3.0, 2.0, 2.0};
#endif
/* Declaration of C-structs */
/* Prototypes for functions used in model */
/* Codes used in model */
/* DSblock C-code: */

BreakSectionFunctionDef(1)
BreakSectionFunctionDef(0)
#define NX_    8
#define NX2_   0
#define NU_    0
#define NY_    0
#define NW_    242
#define NP_    102
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   0
#define MAXAuxStr_   0
#define MAXAuxStrLen_   500
#define NHash1_ -436628363
#define NHash2_ -919178234
#define NHash3_ 0
#define NI_    0
#define NRelF_ 10
#define NRel_  12
#define NTim_  3
#define NSamp_ 2
#define NCons_ 0
#define NA_    214
#define SizePre_ 6
#define SizeEq_ 6
#define SizeDelay_ 0
#define QNLmax_ 0
#define MAXAux 8
#define NrDymolaTimers_ 0
#define NWhen_ 3
#define NCheckIf_ 0
#define NGlobalHelp_ 24
#define NGlobalHelpI_ 0
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="CHEETA.Examples.CHEETAElectricalSystem.SingleBranch_AveragedHalfBridge";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/meagh/appdata/roaming/dassaultsystemes/dymola/dymola.lic";
#define QJacobianCGDef_ 1
DYMOLA_STATIC int QJacobianCG_[17]={6 , 3 , 1 , 3 , 4 , 1 , 2 , 1 , 5 , 1 , 6 , 1
   , 7 , 1 , 8 , 0 , 0};
DYMOLA_STATIC int QJacobianGC_[49]={
1 , 4 , 4 , 4 , 0 , 0 , 0 , 0 , 2 , 2 , 0 , 2 , 0 , 0 , 2 , 0 , 5 , 5 , 0 , 0 , 5
   , 5 , 0 , 0 , 6 , 6 , 0 , 0 , 0 , 6 , 0 , 0 , 7 , 7 , 0 , 0 , 7 , 7 , 7 , 7
   , 8 , 8 , 0 , 0 , 8 , 8 , 8 , 0 , 0};
DYMOLA_STATIC double QJacobianCD_[9]={0  , 44 , 50 , 66 , 77 , 72 , 72 , 70 , 66};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,5) = false;
DYNX(W_,22) = false;
DYNX(W_,26) = true;
DYNX(W_,27) = 1;
DYNX(W_,28) = true;
DYNX(W_,30) = 1;
DYNX(W_,40) = false;
DYNX(W_,44) = 1;
DYNX(W_,45) = 1;
DYNX(W_,50) = false;
DYNX(W_,54) = 1;
DYNX(W_,55) = 1;
DYNX(W_,60) = true;
DYNX(W_,81) = false;
DYNX(W_,112) = false;
DYNX(W_,119) = false;
DYNX(W_,124) = false;
DYNX(W_,135) = 3;
memcpy(&DYNX(W_,161), &DymArrays0, sizeof(double)*3);
memcpy(&DYNX(W_,174), &DymArrays0, sizeof(double)*3);
memcpy(&DYNX(W_,190), &DymArrays1, sizeof(double)*3);
DYNX(W_,213) = false;
DYNX(W_,232) = false;
DYNX(W_,23) = 293.15;
DYNX(W_,32) = 1;
DYNX(W_,63) = false;
DYNX(W_,64) = 2;
DYNX(W_,65) = true;
DYNX(W_,74) = 1;
DYNX(W_,76) = -1;
DYNX(W_,77) = 0;
DYNX(W_,84) = false;
DYNX(W_,85) = 2;
DYNX(W_,86) = true;
DYNX(W_,95) = 1;
DYNX(W_,97) = -1;
DYNX(W_,98) = 0;
DYNX(W_,140) = false;
DYNX(W_,141) = 2;
DYNX(W_,142) = true;
DYNX(W_,159) = 2;
DYNX(W_,172) = 1;
DYNX(W_,187) = 2;
DYNX(W_,193) = 0.0;
DYNX(W_,196) = 0.0;
DYNX(W_,118) = 0;
DYNX(W_,200) = 0;
DYNX(W_,1) = 0;
DYNX(W_,240) = 0.0;
DYNX(W_,236) = 0.0;
DYNX(W_,212) = 0.0;
DYNX(W_,218) = 0.0;
DYNX(W_,221) = 0.0;
DYNX(W_,25) = 293.15;
DYNX(W_,133) = 0.0;
DYNX(W_,128) = 0.0;
DYNX(W_,131) = 0.0;
DYNX(W_,14) = 0.0;
DYNX(W_,15) = 0.0;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
AssertModelica(DYNX(DP_,18) >= DYNX(DP_,19),"pwm.limiter.uMax >= pwm.limiter.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(DP_,18), true, 0)),") < uMin (="),Real2String2(DYNX(DP_,19),
   true, 0)),")"));
PopAllMarks();
AssertModelica(DYNX(DP_,23) >= DYNX(DP_,24),"pwm1.limiter.uMax >= pwm1.limiter.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(DP_,23), true, 0)),") < uMin (="),Real2String2(DYNX(DP_,24),
   true, 0)),")"));
PopAllMarks();
BoundParameterSection
DYNX(W_,0) = DYNX(DP_,4);
DYNX(W_,2) = DYNX(DP_,2);
DYNX(W_,6) = DYNX(DP_,0);
AssertModelica(1+DYNX(DP_,1)*(DYNX(W_,6)-DYNX(DP_,0)) >= 1E-15,"1+simplifiedFuelCell.resistor.alpha*(simplifiedFuelCell.resistor.T-simplifiedFuelCell.resistor.T_ref) >= 1E-15",
   "Temperature outside scope of model!");
DYNX(W_,10) = DYNX(DP_,3);
DYNX(W_,13) = DYNX(DP_,4);
DYNX(W_,29) = DYNX(DP_,11);
DYNX(W_,31) = DYNX(W_,29);
DYNX(W_,37) = DYNX(DP_,5);
DYNX(W_,38) = DYNX(DP_,6);
DYNX(W_,39) = DYNX(DP_,7);
DYNX(W_,47) = DYNX(DP_,8);
DYNX(W_,48) = DYNX(DP_,9);
DYNX(W_,49) = DYNX(DP_,10);
DYNX(W_,62) = DYNX(DP_,15);
DYNX(DYNhelp,0) = divinvGuarded(DYNX(DP_,16),"pwm.f");
DYNX(W_,69) = DYNX(DYNhelp,0);
DYNX(W_,70) = DYNX(DP_,17);
DYNX(W_,75) = DYNX(DYNhelp,0);
DYNX(W_,78) = DYNX(DP_,17);
DYNX(DYNhelp,1) = divinvGuarded(DYNX(DP_,21),"pwm1.f");
DYNX(W_,90) = DYNX(DYNhelp,1);
DYNX(W_,91) = DYNX(DP_,22);
DYNX(W_,96) = DYNX(DYNhelp,1);
DYNX(W_,99) = DYNX(DP_,22);
DYNX(W_,109) = DYNX(DP_,30);
DYNX(W_,110) = DYNX(DP_,29);
DYNX(W_,113) = DYNX(DP_,27);
AssertModelica(1+DYNX(DP_,28)*(DYNX(W_,113)-DYNX(DP_,27)) >= 1E-15,
  "1+simpleMotor.resistor.alpha*(simpleMotor.resistor.T-simpleMotor.resistor.T_ref) >= 1E-15",
   "Temperature outside scope of model!");
DYNX(W_,116) = DYNX(DP_,33);
DYNX(W_,120) = DYNX(DP_,31);
AssertModelica(1+DYNX(DP_,32)*(DYNX(W_,120)-DYNX(DP_,31)) >= 1E-15,
  "1+simpleMotor.hysteresis.alpha*(simpleMotor.hysteresis.T-simpleMotor.hysteresis.T_ref) >= 1E-15",
   "Temperature outside scope of model!");
DYNX(W_,125) = DYNX(DP_,35);
DYNX(W_,134) = DYNX(DP_,36);
DYNX(W_,136) = DYNX(DP_,37);
DYNX(W_,138) = DYNX(DP_,61);
DYNX(W_,139) = DYNX(DP_,62);
AssertModelica(DYNX(W_,138) >= DYNX(W_,139),"modulatedSignalController.limiter.uMax >= modulatedSignalController.limiter.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(W_,138), true, 0)),") < uMin (="),Real2String2(DYNX(W_,139),
   true, 0)),")"));
PopAllMarks();
DYNX(W_,155) = DYNX(DP_,53);
DYNX(W_,156) = DYNX(DP_,54);
DYNX(W_,157) = DYNX(DP_,55);
DYNX(W_,158) = DYNX(DP_,56);
DYNX(W_,164) = DYNX(W_,155);
DYNX(W_,165) = DYNX(W_,156);
DYNX(DYNhelp,2) = divinvGuarded(DYNX(W_,157),"modulatedSignalController.transferFunction.a[1]");
DYNX(W_,166) = DYNX(DYNhelp,2)*DYNX(W_,164);
DYNX(DYNhelp,3) = sqrtGuarded(DYNX(W_,157)*DYNX(W_,157)+DYNX(W_,158)*
  DYNX(W_,158),"modulatedSignalController.transferFunction.a[1]*modulatedSignalController.transferFunction.a[1]+modulatedSignalController.transferFunction.a[2]*modulatedSignalController.transferFunction.a[2]");
DYNX(W_,167) = IF DYNX(W_,158) > 1E-13*DYNX(DYNhelp,3) THEN DYNX(W_,158) ELSE 
  1.0;
DYNX(W_,168) = DYNX(DP_,57);
DYNX(W_,169) = DYNX(DP_,58);
DYNX(W_,170) = DYNX(DP_,59);
DYNX(W_,171) = DYNX(DP_,60);
DYNX(W_,177) = DYNX(W_,168);
DYNX(W_,178) = DYNX(W_,169);
DYNX(DYNhelp,4) = divinvGuarded(DYNX(W_,170),"modulatedSignalController.transferFunction1.a[1]");
DYNX(W_,179) = DYNX(DYNhelp,4)*DYNX(W_,177);
DYNX(DYNhelp,5) = sqrtGuarded(DYNX(W_,170)*DYNX(W_,170)+DYNX(W_,171)*
  DYNX(W_,171),"modulatedSignalController.transferFunction1.a[1]*modulatedSignalController.transferFunction1.a[1]+modulatedSignalController.transferFunction1.a[2]*modulatedSignalController.transferFunction1.a[2]");
DYNX(W_,180) = IF DYNX(W_,171) > 1E-13*DYNX(DYNhelp,5) THEN DYNX(W_,171) ELSE 
  1.0;
DYNX(W_,182) = DYNX(DP_,48);
DYNX(W_,183) = DYNX(DP_,49);
DYNX(W_,184) = DYNX(DP_,50);
DYNX(W_,185) = DYNX(DP_,51);
DYNX(W_,186) = DYNX(DP_,52);
DYNX(W_,194) = DYNX(W_,182);
DYNX(W_,195) = DYNX(W_,183);
DYNX(DYNhelp,6) = sqrtGuarded(DYNX(W_,184)*DYNX(W_,184)+DYNX(W_,185)*
  DYNX(W_,185)+DYNX(W_,186)*DYNX(W_,186),"modulatedSignalController.transferFunction2.a[1]*modulatedSignalController.transferFunction2.a[1]+modulatedSignalController.transferFunction2.a[2]*modulatedSignalController.transferFunction2.a[2]+modulatedSignalController.transferFunction2.a[3]*modulatedSignalController.transferFunction2.a[3]");
DYNX(W_,197) = IF DYNX(W_,186) > 1E-13*DYNX(DYNhelp,6) THEN DYNX(W_,186) ELSE 
  1.0;
DYNX(W_,198) = DYNX(DP_,47);
DYNX(W_,199) = DYNX(DP_,72)/(double)(2);
DYNX(W_,217) = DYNX(DP_,95);
DYNX(W_,211) = DYNX(W_,217);
DYNX(W_,214) = DYNX(DP_,81);
AssertModelica(1+DYNX(DP_,82)*(DYNX(W_,214)-DYNX(DP_,81)) >= 1E-15,
  "1+dCAC_HalfBridgeAverage.switch1.resistor.alpha*(dCAC_HalfBridgeAverage.switch1.resistor.T-dCAC_HalfBridgeAverage.switch1.resistor.T_ref) >= 1E-15",
   "Temperature outside scope of model!");
DYNX(W_,219) = DYNX(DP_,95);
DYNX(W_,230) = DYNX(W_,219);
DYNX(W_,233) = DYNX(DP_,91);
AssertModelica(1+DYNX(DP_,92)*(DYNX(W_,233)-DYNX(DP_,91)) >= 1E-15,
  "1+dCAC_HalfBridgeAverage.switch4.resistor.alpha*(dCAC_HalfBridgeAverage.switch4.resistor.T-dCAC_HalfBridgeAverage.switch4.resistor.T_ref) >= 1E-15",
   "Temperature outside scope of model!");
DYNX(W_,238) = DYNX(DP_,97)/(double)(2);
BoundParameterConstantSection
DYNX(W_,115) = DYNX(W_,110)*(1+DYNX(DP_,28)*(DYNX(W_,113)-DYNX(DP_,27)));
DYNX(W_,122) = DYNX(W_,116)*(1+DYNX(DP_,32)*(DYNX(W_,120)-DYNX(DP_,31)));
DYNX(W_,8) = DYNX(W_,2)*(1+DYNX(DP_,1)*(DYNX(W_,6)-DYNX(DP_,0)));
DYNX(W_,66) = homotopy(IF DYNX(W_,62) > DYNX(DP_,18) THEN DYNX(DP_,18) ELSE IF 
  DYNX(W_,62) < DYNX(DP_,19) THEN DYNX(DP_,19) ELSE DYNX(W_,62), DYNX(W_,62));
DYNX(W_,216) = DYNX(W_,211)*(1+DYNX(DP_,82)*(DYNX(W_,214)-DYNX(DP_,81)));
DYNX(W_,235) = DYNX(W_,230)*(1+DYNX(DP_,92)*(DYNX(W_,233)-DYNX(DP_,91)));
BoundParameterSection
InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,42) = true;
DYNX(W_,43) = 0;
DYNX(W_,52) = true;
DYNX(W_,53) = 0;
DYNX(W_,57) = 0;
DYNX(W_,72) = false;
DYNX(W_,73) = 0;
DYNX(W_,93) = false;
DYNX(W_,94) = 0;
DYNX(W_,103) = 0;
#endif
InitialSection
InitialStartSection
InitialStartSection2
DYNX(W_,79) = DYNX(W_,78);
DYNX(W_,100) = DYNX(W_,99);
DYNX(W_,160) = DYNX(DP_,40);
DYNX(W_,173) = DYNX(DP_,42);
DYNX(W_,188) = DYNX(DP_,44);
DYNX(W_,189) = DYNX(DP_,45);
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialBoundSection
DYNX(Aux_,0) = DYNX(W_,79);
DYNX(Aux_,1) = DYNX(W_,80);
DYNX(Aux_,2) = DYNX(W_,72);
DYNX(Aux_,3) = DYNX(W_,73);
DYNX(Aux_,4) = DYNX(W_,100);
DYNX(Aux_,5) = DYNX(W_,101);
DYNX(Aux_,6) = DYNX(W_,93);
DYNX(Aux_,7) = DYNX(W_,94);
InitialSection
InitialSection2
DYNX(F_,6) = 0.0;
DYNX(F_,4) = 0.0;
DYNX(F_,7) = 0.0;
DYNX(W_,152) = 0.0;
DYNX(W_,154) = 0.0;
DYNX(W_,188) = 0.0;
DYNX(X_,6) = 0.0;
  DYNX(W_,80) = real2integerEvent(divGuarded(DYNTime-DYNX(W_,78),
    "time-pwm.sawtooth.startTime",DYNX(W_,75),"pwm.sawtooth.period"),
    "(time-pwm.sawtooth.startTime)/pwm.sawtooth.period", 0);
  DYNX(W_,79) = DYNX(W_,78)+DYNX(W_,80)*DYNX(W_,75);
DYNX(W_,73) = DYNX(W_,66);
DYNX(W_,146) = DYNX(DP_,66)+(IF LessTime(DYNX(DP_,67), 0) THEN 0 ELSE 
  DYNX(DP_,63)*sin(6.283185307179586*DYNX(DP_,64)*(DYNTime-DYNX(DP_,67))+
  DYNX(DP_,65)));
DYNX(W_,145) = DYNX(DP_,38)*DYNX(W_,146)+DYNX(DP_,39)*DYNX(X_,1);
DYNX(W_,181) = DYNX(W_,198)*DYNX(W_,145);
 /* Linear system of equations to solve. */
/* Introducing 1 common subexpressions used in 1 expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,7) = divinvGuarded(DYNX(W_,184),"modulatedSignalController.transferFunction2.a[1]");
DYNX(X_,7) = 0.0;
SolveScalarLinearParametric(DYNX(DYNhelp,7)*DYNX(W_,186),"modulatedSignalController.transferFunction2.a[3]/modulatedSignalController.transferFunction2.a[1]",
   DYNX(DYNhelp,7)*DYNX(W_,197)*DYNX(W_,181),"modulatedSignalController.transferFunction2.a_end*modulatedSignalController.transferFunction2.u/modulatedSignalController.transferFunction2.a[1]",
   DYNX(X_,7),"modulatedSignalController.transferFunction2.x_scaled[2]");
 /* End of Equation Block */ 

DYNX(W_,151) = divGuarded(DYNX(W_,195)*DYNX(X_,7),"modulatedSignalController.transferFunction2.bb[3]*modulatedSignalController.transferFunction2.x_scaled[2]",
  DYNX(W_,197),"modulatedSignalController.transferFunction2.a_end");
 /* Linear system of equations to solve. */
/* Introducing 1 common subexpressions used in 1 expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,8) = divinvGuarded(DYNX(W_,157),"modulatedSignalController.transferFunction.a[1]");
DYNX(X_,4) = 0.0;
SolveScalarLinearParametric(DYNX(DYNhelp,8)*DYNX(W_,158),"modulatedSignalController.transferFunction.a[2]/modulatedSignalController.transferFunction.a[1]",
   DYNX(DYNhelp,8)*DYNX(W_,167)*DYNX(W_,151),"modulatedSignalController.transferFunction.a_end*modulatedSignalController.transferFunction.u/modulatedSignalController.transferFunction.a[1]",
   DYNX(X_,4),"modulatedSignalController.transferFunction.x_scaled[1]");
 /* End of Equation Block */ 

DYNX(W_,153) = divGuarded((DYNX(W_,165)-DYNX(W_,166)*DYNX(W_,158))*DYNX(X_,4),
  "(modulatedSignalController.transferFunction.bb[2]-modulatedSignalController.transferFunction.d*modulatedSignalController.transferFunction.a[2])*modulatedSignalController.transferFunction.x_scaled[1]",
  DYNX(W_,167),"modulatedSignalController.transferFunction.a_end")+DYNX(W_,166)*
  DYNX(W_,151);
DYNX(W_,147) = divGuarded((DYNX(W_,178)-DYNX(W_,179)*DYNX(W_,171))*DYNX(X_,5),
  "(modulatedSignalController.transferFunction1.bb[2]-modulatedSignalController.transferFunction1.d*modulatedSignalController.transferFunction1.a[2])*modulatedSignalController.transferFunction1.x_scaled[1]",
  DYNX(W_,180),"modulatedSignalController.transferFunction1.a_end")+DYNX(W_,179)
  *DYNX(W_,153);
DYNX(W_,143) = divGuarded(DYNX(W_,147),"modulatedSignalController.division.u1",
  DYNX(W_,199),"const.k");
DYNX(W_,149) = homotopy(IF GreaterS(DYNX(W_,143),"modulatedSignalController.limiter.u",
   DYNX(W_,138),"modulatedSignalController.limiter.uMax", 1) THEN DYNX(W_,138)
   ELSE IF LessS(DYNX(W_,143),"modulatedSignalController.limiter.u", 
  DYNX(W_,139),"modulatedSignalController.limiter.uMin", 2) THEN DYNX(W_,139)
   ELSE DYNX(W_,143), DYNX(W_,143));
DYNX(W_,87) = homotopy(IF GreaterS(DYNX(W_,149),"modulatedSignalController.y", 
  DYNX(DP_,23),"pwm1.limiter.uMax", 3) THEN DYNX(DP_,23) ELSE IF LessS(
  DYNX(W_,149),"modulatedSignalController.y", DYNX(DP_,24),"pwm1.limiter.uMin", 4)
   THEN DYNX(DP_,24) ELSE DYNX(W_,149), DYNX(W_,149));
DYNX(W_,94) = DYNX(W_,87);
  DYNX(W_,101) = real2integerEvent(divGuarded(DYNTime-DYNX(W_,99),
    "time-pwm1.sawtooth.startTime",DYNX(W_,96),"pwm1.sawtooth.period"),
    "(time-pwm1.sawtooth.startTime)/pwm1.sawtooth.period", 5);
  DYNX(W_,100) = DYNX(W_,99)+DYNX(W_,101)*DYNX(W_,96);
InitialBoundSection
DYNX(Aux_,0) = DYNX(W_,79);
DYNX(Aux_,4) = DYNX(W_,100);
DYNX(Aux_,1) = DYNX(W_,80);
DYNX(Aux_,5) = DYNX(W_,101);
InitialSection2
DYNX(W_,72) = DYNX(Aux_,2);
DYNX(W_,93) = DYNX(Aux_,6);
DYNX(F_,5) = divGuarded(DYNX(W_,180)*DYNX(W_,153)-DYNX(W_,171)*DYNX(X_,5),
  "modulatedSignalController.transferFunction1.a_end*modulatedSignalController.transferFunction.y-modulatedSignalController.transferFunction1.a[2]*modulatedSignalController.transferFunction1.x_scaled[1]",
  DYNX(W_,170),"modulatedSignalController.transferFunction1.a[1]");
DYNX(W_,148) = divGuarded((DYNX(W_,178)-DYNX(W_,179)*DYNX(W_,171))*DYNX(F_,5),
  "(modulatedSignalController.transferFunction1.bb[2]-modulatedSignalController.transferFunction1.d*modulatedSignalController.transferFunction1.a[2])*der(modulatedSignalController.transferFunction1.x_scaled[1])",
  DYNX(W_,180),"modulatedSignalController.transferFunction1.a_end");
DYNX(W_,144) = divGuarded(DYNX(W_,148),"der(modulatedSignalController.division.u1)",
  DYNX(W_,199),"const.k");
DYNX(W_,150) = homotopy(IF Greater(DYNX(W_,143),"modulatedSignalController.limiter.u",
   DYNX(W_,138),"modulatedSignalController.limiter.uMax", 6) THEN 0.0 ELSE IF 
  Less(DYNX(W_,143),"modulatedSignalController.limiter.u", DYNX(W_,139),
  "modulatedSignalController.limiter.uMin", 7) THEN 0.0 ELSE DYNX(W_,144), 
  DYNX(W_,144));
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection

DynamicsSection
DYNX(W_,108) = DYNX(W_,125)*DYNX(X_,3);
 /* Linear system of equations to solve. */
DYNX(W_,117) = RememberSimple_(DYNX(W_,117), 0);
SolveScalarLinearParametric( -DYNX(W_,122)," -simpleMotor.hysteresis.R_actual", 
   -DYNX(W_,108)," -simpleMotor.inductor.n.v", DYNX(W_,117),"simpleMotor.hysteresis.i");
 /* End of Equation Block */ 

DYNX(W_,126) = DYNX(X_,1)-DYNX(W_,117);
DYNX(W_,130) =  -DYNX(W_,125)*DYNX(W_,126);
 /* Linear system of equations to solve. */
DYNX(F_,3) = RememberSimple_(DYNX(F_,3), 1);
SolveScalarLinearParametric(DYNX(W_,134),"fan.inertia.J",  -DYNX(W_,130),
  " -simpleMotor.flange1.tau", DYNX(F_,3),"der(fan.inertia.w)");
 /* End of Equation Block */ 

DYNX(F_,2) = DYNX(X_,3);
DYNX(W_,146) = DYNX(DP_,66)+(IF LessTime(DYNX(DP_,67), 0) THEN 0 ELSE 
  DYNX(DP_,63)*sin(6.283185307179586*DYNX(DP_,64)*(DYNTime-DYNX(DP_,67))+
  DYNX(DP_,65)));
DYNX(W_,145) = DYNX(DP_,38)*DYNX(W_,146)+DYNX(DP_,39)*DYNX(X_,1);
DYNX(W_,181) = DYNX(W_,198)*DYNX(W_,145);
if (NewParameters_) {
DYNX(DYNhelp,9) = divinvGuarded(DYNX(W_,184),"modulatedSignalController.transferFunction2.a[1]");
}
DYNX(F_,6) = DYNX(DYNhelp,9)*(DYNX(W_,197)*DYNX(W_,181)-(DYNX(W_,185)*DYNX(X_,6)
  +DYNX(W_,186)*DYNX(X_,7)));
if (NewParameters_) {
DYNX(DYNhelp,10) = divinvGuarded(DYNX(W_,197),"modulatedSignalController.transferFunction2.a_end");
}
DYNX(W_,151) = DYNX(DYNhelp,10)*(DYNX(W_,194)*DYNX(X_,6)+DYNX(W_,195)*DYNX(X_,7));
DYNX(F_,4) = DYNX(DYNhelp,2)*(DYNX(W_,167)*DYNX(W_,151)-DYNX(W_,158)*DYNX(X_,4));
if (NewParameters_) {
DYNX(DYNhelp,11) = divinvGuarded(DYNX(W_,167),"modulatedSignalController.transferFunction.a_end");
}
DYNX(W_,153) = DYNX(DYNhelp,11)*(DYNX(W_,165)-DYNX(W_,166)*DYNX(W_,158))*
  DYNX(X_,4)+DYNX(W_,166)*DYNX(W_,151);
DYNX(F_,5) = DYNX(DYNhelp,4)*(DYNX(W_,180)*DYNX(W_,153)-DYNX(W_,171)*DYNX(X_,5));
DYNX(W_,111) = DYNX(W_,115)*DYNX(X_,1);
if (NewParameters_) {
DYNX(DYNhelp,12) = divinvGuarded(DYNX(W_,180),"modulatedSignalController.transferFunction1.a_end");
}
DYNX(W_,147) = DYNX(DYNhelp,12)*(DYNX(W_,178)-DYNX(W_,179)*DYNX(W_,171))*
  DYNX(X_,5)+DYNX(W_,179)*DYNX(W_,153);
if (NewParameters_) {
DYNX(DYNhelp,13) = divinvGuarded(DYNX(W_,199),"const.k");
}
DYNX(W_,143) = DYNX(DYNhelp,13)*DYNX(W_,147);
DYNX(W_,149) = IF GreaterS(DYNX(W_,143),"modulatedSignalController.limiter.u", 
  DYNX(W_,138),"modulatedSignalController.limiter.uMax", 1) THEN DYNX(W_,138)
   ELSE IF LessS(DYNX(W_,143),"modulatedSignalController.limiter.u", 
  DYNX(W_,139),"modulatedSignalController.limiter.uMin", 2) THEN DYNX(W_,139)
   ELSE DYNX(W_,143);
DYNX(W_,239) = DYNX(DP_,100)*DYNX(W_,149);
DYNX(W_,237) = DYNX(DP_,98)*DYNX(W_,239)+DYNX(DP_,99)*DYNX(DP_,101);
DYNX(W_,123) = DYNX(W_,237)*DYNX(W_,238);
DYNX(W_,107) = DYNX(W_,123)-DYNX(W_,111);
DYNX(W_,106) = DYNX(W_,107)-DYNX(W_,108);
 /* Linear system of equations to solve. */
DYNX(F_,1) = RememberSimple_(DYNX(F_,1), 2);
SolveScalarLinearParametric(DYNX(W_,109),"simpleMotor.inductor.L", DYNX(W_,106),
  "simpleMotor.inductor.v", DYNX(F_,1),"der(simpleMotor.inductor.i)");
 /* End of Equation Block */ 

DYNX(F_,7) = DYNX(X_,6);
DYNX(W_,3) = DYNX(W_,8)*DYNX(X_,0);
DYNX(W_,4) = DYNX(W_,0)-DYNX(W_,3);
DYNX(W_,203) = DYNX(DP_,73)*DYNX(W_,149);
DYNX(W_,205) = DYNX(DP_,75)*DYNX(W_,203)+DYNX(DP_,76)*DYNX(DP_,74);
DYNX(W_,207) = DYNX(DP_,77)*DYNX(W_,205)+DYNX(DP_,78)*DYNX(DP_,80);
if (NewParameters_) {
DYNX(DYNhelp,14) = divinvGuarded(DYNX(DP_,79),"dCAC_HalfBridgeAverage.switch1.const2.k");
}
DYNX(W_,209) = DYNX(DYNhelp,14)*DYNX(W_,207);
DYNX(W_,57) = DYNX(W_,209)*DYNX(X_,1);
DYNX(W_,36) = DYNX(X_,0)-DYNX(W_,57);
beginwhenBlock
if (NewParameters_) {
DYNX(DYNhelp,15) = divinvGuarded(DYNX(W_,75),"pwm.sawtooth.period");
}
DYNX(DYNhelp,16) = real2integer(DYNX(DYNhelp,15)*(DYNTime-DYNX(W_,78)));
whenModelica(real2integerEventMinor(divGuarded(DYNTime-DYNX(W_,78),
  "time-pwm.sawtooth.startTime",DYNX(W_,75),"pwm.sawtooth.period"),
  "(time-pwm.sawtooth.startTime)/pwm.sawtooth.period", 0) > PRE(DYNX(W_,80), 2),
   0) 
  DYNX(W_,79) = DYNTime;
endwhenModelica()
endwhenBlock


DYNX(W_,67) = IF LessTime(DYNX(W_,78), 1) THEN 0 ELSE divGuarded(DYNTime-
  DYNX(W_,79),"time-pwm.sawtooth.T_start",DYNX(W_,75),"pwm.sawtooth.period");
DYNX(W_,68) = PRE(DYNX(W_,73), 3);
DYNX(W_,34) = Less(DYNX(W_,67),"pwm.greaterEqual.u1", DYNX(W_,68),
  "pwm.greaterEqual.u2", 8);
DYNX(W_,33) = DYNX(W_,34) AND DYNX(W_,31);

MixedSystemOfEquations(1, DYNX(DYNhelp,17))
   /* Linear system of equations to solve. */
  DYNX(W_,43) = RememberSimple_(DYNX(W_,43), 3);
  SolveScalarLinearMixed( -(IF DYNX(W_,42) THEN DYNX(W_,38) ELSE 1),
    " -(if dcdc.transistor.off then dcdc.transistor.Goff else 1)", DYNX(W_,38)*
    DYNX(W_,39)-DYNX(W_,36),"dcdc.transistor.Goff*dcdc.transistor.Vknee-dcdc.transistor.i",
     DYNX(W_,43),"dcdc.transistor.s");
   /* End of Equation Block */ 


  MixedModeStartBoolean
  UpdateVariableNamed(DYNX(W_,42),"dcdc.transistor.off", Less(DYNX(W_,43),
    "dcdc.transistor.s", 0,"0", 9) OR  NOT DYNX(W_,33));
  MixedModeInit(1, DYNX(DYNhelp,18))
  ThetaMixedCross(0,9)
  MixedModeEndBoolean
  UpdateReal(DYNX(W_,43), 1)
EndMixedSystemOfEquations

DYNX(W_,35) = DYNX(W_,43)*(IF DYNX(W_,42) THEN 1 ELSE DYNX(W_,37))+DYNX(W_,39);
DYNX(W_,12) = DYNX(W_,35)+DYNX(W_,13);
DYNX(W_,9) = DYNX(W_,4)-DYNX(W_,12);
 /* Linear system of equations to solve. */
DYNX(F_,0) = RememberSimple_(DYNX(F_,0), 4);
SolveScalarLinearParametric(DYNX(W_,10),"simplifiedFuelCell.inductor.L", 
  DYNX(W_,9),"simplifiedFuelCell.inductor.v", DYNX(F_,0),"der(simplifiedFuelCell.inductor.i)");
 /* End of Equation Block */ 


AcceptedSection1
DYNX(W_,71) = sampleNew2(DYNX(W_,70), DYNX(W_,69), 0);
beginwhenBlock
whenModelica(real2integerEventMinor(divGuarded(DYNTime-DYNX(W_,78),
  "time-pwm.sawtooth.startTime",DYNX(W_,75),"pwm.sawtooth.period"),
  "(time-pwm.sawtooth.startTime)/pwm.sawtooth.period", 0) > PRE(DYNX(W_,80), 2),
   1) 
  DYNX(W_,80) = PRE(DYNX(W_,80), 2)+1;
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelicaS(DYNX(W_,71))
  DYNX(W_,73) = DYNX(W_,66);
endwhenModelica()
endwhenBlock


BreakSectionFunctionCallNew(0);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(1);

AcceptedSection2
DYNX(W_,92) = sampleNew2(DYNX(W_,91), DYNX(W_,90), 1);
DYNX(W_,87) = IF GreaterS(DYNX(W_,149),"modulatedSignalController.y", 
  DYNX(DP_,23),"pwm1.limiter.uMax", 3) THEN DYNX(DP_,23) ELSE IF LessS(
  DYNX(W_,149),"modulatedSignalController.y", DYNX(DP_,24),"pwm1.limiter.uMin", 4)
   THEN DYNX(DP_,24) ELSE DYNX(W_,149);
DYNX(W_,137) = DYNX(X_,2)-DYNX(W_,136)/(double)(2);
DYNX(W_,129) = DYNX(W_,137)-DYNX(W_,136)/(double)(2);
DYNX(W_,127) = DYNX(W_,129)-DYNX(DP_,34);
DYNX(W_,222) = DYNX(DP_,83)*DYNX(W_,149);
DYNX(W_,224) = DYNX(DP_,85)*DYNX(W_,222)+DYNX(DP_,86)*DYNX(DP_,84);
DYNX(W_,226) = DYNX(DP_,87)*DYNX(W_,224)+DYNX(DP_,88)*DYNX(DP_,90);
if (NewParameters_) {
DYNX(DYNhelp,19) = divinvGuarded(DYNX(DP_,89),"dCAC_HalfBridgeAverage.switch4.const2.k");
}
DYNX(W_,228) = DYNX(DYNhelp,19)*DYNX(W_,226);
DYNX(W_,103) = DYNX(W_,228)*DYNX(X_,1);
DYNX(W_,152) = DYNX(DYNhelp,10)*(DYNX(W_,194)*DYNX(F_,6)+DYNX(W_,195)*DYNX(X_,6));
DYNX(W_,154) = DYNX(DYNhelp,11)*(DYNX(W_,165)-DYNX(W_,166)*DYNX(W_,158))*
  DYNX(F_,4)+DYNX(W_,166)*DYNX(W_,152);
DYNX(W_,148) = DYNX(DYNhelp,12)*(DYNX(W_,178)-DYNX(W_,179)*DYNX(W_,171))*
  DYNX(F_,5)+DYNX(W_,179)*DYNX(W_,154);
DYNX(W_,144) = DYNX(DYNhelp,13)*DYNX(W_,148);
DYNX(W_,150) = IF Greater(DYNX(W_,143),"modulatedSignalController.limiter.u", 
  DYNX(W_,138),"modulatedSignalController.limiter.uMax", 6) THEN 0.0 ELSE IF 
  Less(DYNX(W_,143),"modulatedSignalController.limiter.u", DYNX(W_,139),
  "modulatedSignalController.limiter.uMin", 7) THEN 0.0 ELSE DYNX(W_,144);
DYNX(W_,204) = DYNX(DP_,73)*DYNX(W_,150);
DYNX(W_,206) = DYNX(DP_,75)*DYNX(W_,204);
DYNX(W_,208) = DYNX(DP_,77)*DYNX(W_,206);
DYNX(W_,210) = DYNX(DYNhelp,14)*DYNX(W_,208);
DYNX(W_,58) = DYNX(W_,210)*DYNX(X_,1)+DYNX(W_,209)*DYNX(F_,1);
DYNX(W_,223) = DYNX(DP_,83)*DYNX(W_,150);
DYNX(W_,225) = DYNX(DP_,85)*DYNX(W_,223);
DYNX(W_,227) = DYNX(DP_,87)*DYNX(W_,225);
DYNX(W_,229) = DYNX(DYNhelp,19)*DYNX(W_,227);
DYNX(W_,104) = DYNX(W_,229)*DYNX(X_,1)+DYNX(W_,228)*DYNX(F_,1);
DYNX(W_,7) = DYNX(W_,3)*DYNX(X_,0);
DYNX(W_,11) = DYNX(W_,36)-DYNX(W_,103);
DYNX(W_,16) = DYNX(W_,11)-DYNX(X_,0);
DYNX(W_,17) = DYNX(W_,12)-DYNX(W_,13);
DYNX(W_,18) = DYNX(W_,17)*DYNX(X_,0);

MixedSystemOfEquations(1, DYNX(DYNhelp,20))
   /* Linear system of equations to solve. */
  DYNX(W_,53) = RememberSimple_(DYNX(W_,53), 5);
  SolveScalarLinearMixed( -(IF DYNX(W_,52) THEN DYNX(W_,48) ELSE 1),
    " -(if dcdc.diode.off then dcdc.diode.Goff else 1)", DYNX(W_,48)*DYNX(W_,49)
    -DYNX(W_,57),"dcdc.diode.Goff*dcdc.diode.Vknee-inductor.i", DYNX(W_,53),
    "dcdc.diode.s");
   /* End of Equation Block */ 


  MixedModeStartBoolean
  UpdateVariableNamed(DYNX(W_,52),"dcdc.diode.off", Less(DYNX(W_,53),
    "dcdc.diode.s", 0,"0", 10));
  MixedModeInit(1, DYNX(DYNhelp,21))
  ThetaMixedCross(0,10)
  MixedModeEndBoolean
  UpdateReal(DYNX(W_,53), 1)
EndMixedSystemOfEquations

DYNX(W_,46) = DYNX(W_,53)*(IF DYNX(W_,52) THEN 1 ELSE DYNX(W_,47))+DYNX(W_,49);
DYNX(W_,19) = DYNX(W_,12)-DYNX(W_,46);
DYNX(W_,20) = DYNX(W_,19)-DYNX(W_,13);
DYNX(W_,21) =  -DYNX(W_,20)*DYNX(W_,57);
DYNX(W_,51) = DYNX(W_,46)*DYNX(W_,57);
DYNX(W_,41) = DYNX(W_,35)*DYNX(W_,36);
DYNX(W_,24) = DYNX(W_,51)+DYNX(W_,41);
DYNX(W_,56) = DYNX(DP_,14)*DYNX(W_,58);
DYNX(W_,59) = DYNX(W_,19)-DYNX(W_,56);
beginwhenBlock
whenModelicaS(DYNX(W_,71))
  DYNX(W_,72) = DYNTime <= DYNX(W_,70)+DYNX(W_,69)/(double)(2);
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelicaS(DYNX(W_,92))
  DYNX(W_,93) = DYNTime <= DYNX(W_,91)+DYNX(W_,90)/(double)(2);
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelicaS(DYNX(W_,92))
  DYNX(W_,94) = DYNX(W_,87);
endwhenModelica()
endwhenBlock


beginwhenBlock
if (NewParameters_) {
DYNX(DYNhelp,22) = divinvGuarded(DYNX(W_,96),"pwm1.sawtooth.period");
}
DYNX(DYNhelp,23) = real2integer(DYNX(DYNhelp,22)*(DYNTime-DYNX(W_,99)));
whenModelica(real2integerEventMinor(divGuarded(DYNTime-DYNX(W_,99),
  "time-pwm1.sawtooth.startTime",DYNX(W_,96),"pwm1.sawtooth.period"),
  "(time-pwm1.sawtooth.startTime)/pwm1.sawtooth.period", 5) > PRE(DYNX(W_,101), 4),
   2) 
  DYNX(W_,100) = DYNTime;
  DYNX(W_,101) = PRE(DYNX(W_,101), 4)+1;
endwhenModelica()
endwhenBlock


DYNX(W_,88) = IF LessTime(DYNX(W_,99), 2) THEN 0 ELSE divGuarded(DYNTime-
  DYNX(W_,100),"time-pwm1.sawtooth.T_start",DYNX(W_,96),"pwm1.sawtooth.period");
DYNX(W_,102) = DYNX(DP_,25)*DYNX(W_,104);
DYNX(W_,105) = DYNX(W_,13)-DYNX(W_,102);
DYNX(W_,114) = DYNX(W_,111)*DYNX(X_,1);
DYNX(W_,121) = DYNX(W_,108)*DYNX(W_,117);
DYNX(W_,132) = DYNX(W_,126)+DYNX(W_,117);
DYNX(W_,160) = DYNX(DYNhelp,11)*DYNX(X_,4);
DYNX(W_,173) = DYNX(DYNhelp,12)*DYNX(X_,5);
DYNX(W_,188) = DYNX(DYNhelp,10)*DYNX(X_,6);
DYNX(W_,189) = DYNX(DYNhelp,10)*DYNX(X_,7);
DYNX(W_,201) = DYNX(W_,216)*DYNX(W_,57);
DYNX(W_,202) = DYNX(W_,59)-DYNX(W_,201);
DYNX(W_,215) = DYNX(W_,201)*DYNX(W_,57);
DYNX(W_,231) =  -DYNX(W_,235)*DYNX(W_,103);
DYNX(W_,220) = DYNX(W_,231)+DYNX(W_,105);
DYNX(W_,234) =  -DYNX(W_,231)*DYNX(W_,103);
DYNX(W_,241) = DYNX(W_,103)-DYNX(X_,1)+DYNX(W_,57);
DYNX(W_,61) =  NOT DYNX(W_,34);
DYNX(W_,89) = PRE(DYNX(W_,94), 5);
DYNX(W_,82) = Less(DYNX(W_,88),"pwm1.greaterEqual.u1", DYNX(W_,89),
  "pwm1.greaterEqual.u2", 11);
DYNX(W_,83) =  NOT DYNX(W_,82);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareVariable("simplifiedFuelCell.constantVoltage.V", "Value of constant voltage [V]",\
 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("simplifiedFuelCell.constantVoltage.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 "simplifiedFuelCell.constantVoltage.V", 1, 5, 0, 0)
DeclareAlias2("simplifiedFuelCell.constantVoltage.i", "Current flowing from pin p to pin n [A]",\
 "simplifiedFuelCell.inductor.i", -1, 1, 0, 0)
DeclareAlias2("simplifiedFuelCell.constantVoltage.p.v", "Potential at the pin [V]",\
 "simplifiedFuelCell.constantVoltage.V", 1, 5, 0, 4)
DeclareAlias2("simplifiedFuelCell.constantVoltage.p.i", "Current flowing into the pin [A]",\
 "simplifiedFuelCell.inductor.i", -1, 1, 0, 132)
DeclareVariable("simplifiedFuelCell.constantVoltage.n.v", "Potential at the pin [V]",\
 0, 0.0,0.0,0.0,0,521)
DeclareAlias2("simplifiedFuelCell.constantVoltage.n.i", "Current flowing into the pin [A]",\
 "simplifiedFuelCell.inductor.i", 1, 1, 0, 132)
DeclareVariable("simplifiedFuelCell.resistor.R", "Resistance at temperature T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareParameter("simplifiedFuelCell.resistor.T_ref", "Reference temperature [K|degC]",\
 0, 300.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("simplifiedFuelCell.resistor.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 1, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("simplifiedFuelCell.resistor.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("simplifiedFuelCell.resistor.i", "Current flowing from pin p to pin n [A]",\
 "simplifiedFuelCell.inductor.i", 1, 1, 0, 0)
DeclareAlias2("simplifiedFuelCell.resistor.p.v", "Potential at the pin [V]", \
"simplifiedFuelCell.constantVoltage.V", 1, 5, 0, 4)
DeclareAlias2("simplifiedFuelCell.resistor.p.i", "Current flowing into the pin [A]",\
 "simplifiedFuelCell.inductor.i", 1, 1, 0, 132)
DeclareVariable("simplifiedFuelCell.resistor.n.v", "Potential at the pin [V]", \
0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("simplifiedFuelCell.resistor.n.i", "Current flowing into the pin [A]",\
 "simplifiedFuelCell.inductor.i", -1, 1, 0, 132)
DeclareVariable("simplifiedFuelCell.resistor.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("simplifiedFuelCell.resistor.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("simplifiedFuelCell.resistor.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("simplifiedFuelCell.resistor.T_heatPort", "Temperature of heatPort [K|degC]",\
 "simplifiedFuelCell.resistor.T", 1, 5, 6, 0)
DeclareVariable("simplifiedFuelCell.resistor.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("simplifiedFuelCell.inductor.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("simplifiedFuelCell.inductor.i", "Current flowing from pin p to pin n [A]",\
 0, 0, 0.0,0.0,0.0,0,560)
DeclareDerivative("simplifiedFuelCell.inductor.der(i)", "der(Current flowing from pin p to pin n) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("simplifiedFuelCell.inductor.p.v", "Potential at the pin [V]", \
"simplifiedFuelCell.resistor.n.v", 1, 5, 4, 4)
DeclareAlias2("simplifiedFuelCell.inductor.p.i", "Current flowing into the pin [A]",\
 "simplifiedFuelCell.inductor.i", 1, 1, 0, 132)
DeclareAlias2("simplifiedFuelCell.inductor.n.v", "Potential at the pin [V]", \
"simplifiedFuelCell.pin_p.v", 1, 5, 12, 4)
DeclareAlias2("simplifiedFuelCell.inductor.n.i", "Current flowing into the pin [A]",\
 "simplifiedFuelCell.inductor.i", -1, 1, 0, 132)
DeclareVariable("simplifiedFuelCell.inductor.L", "Inductance [H]", 1, 0.0,0.0,\
0.0,0,513)
DeclareAlias2("simplifiedFuelCell.n1.v", "Potential at the pin [V]", \
"simplifiedFuelCell.constantVoltage1.V", 1, 5, 13, 4)
DeclareVariable("simplifiedFuelCell.n1.i", "Current flowing into the pin [A]", \
0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("simplifiedFuelCell.pin_p.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,520)
DeclareAlias2("simplifiedFuelCell.pin_p.i", "Current flowing into the pin [A]", \
"simplifiedFuelCell.inductor.i", -1, 1, 0, 132)
DeclareParameter("simplifiedFuelCell.R", "Impedance [Ohm]", 2, 100, 0.0,0.0,0.0,\
0,560)
DeclareParameter("simplifiedFuelCell.L", "Impedance [H]", 3, 1000.0, 0.0,0.0,0.0,\
0,560)
DeclareParameter("simplifiedFuelCell.V", "Fuel cell voltage [V]", 4, 500, \
0.0,0.0,0.0,0,560)
DeclareVariable("simplifiedFuelCell.constantVoltage1.V", "Value of constant voltage [V]",\
 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("simplifiedFuelCell.constantVoltage1.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 "simplifiedFuelCell.constantVoltage1.V", 1, 5, 13, 0)
DeclareAlias2("simplifiedFuelCell.constantVoltage1.i", "Current flowing from pin p to pin n [A]",\
 "simplifiedFuelCell.n1.i", 1, 5, 11, 0)
DeclareAlias2("simplifiedFuelCell.constantVoltage1.p.v", "Potential at the pin [V]",\
 "simplifiedFuelCell.constantVoltage1.V", 1, 5, 13, 4)
DeclareAlias2("simplifiedFuelCell.constantVoltage1.p.i", "Current flowing into the pin [A]",\
 "simplifiedFuelCell.n1.i", 1, 5, 11, 132)
DeclareVariable("simplifiedFuelCell.constantVoltage1.n.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("simplifiedFuelCell.constantVoltage1.n.i", "Current flowing into the pin [A]",\
 "simplifiedFuelCell.n1.i", -1, 5, 11, 132)
DeclareVariable("simplifiedFuelCell.ground.p.v", "Potential at the pin [V]", 0.0,\
 0.0,0.0,0.0,0,521)
DeclareVariable("simplifiedFuelCell.ground.p.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareParameter("dcdc.RonTransistor", "Transistor closed resistance [Ohm]", 5, \
1E-05, 0.0,0.0,0.0,0,560)
DeclareParameter("dcdc.GoffTransistor", "Transistor opened conductance [S]", 6, \
1E-05, 0.0,0.0,0.0,0,560)
DeclareParameter("dcdc.VkneeTransistor", "Transistor threshold voltage [V]", 7, 0,\
 0.0,0.0,0.0,0,560)
DeclareParameter("dcdc.RonDiode", "Closed diode resistance [Ohm]", 8, 1E-05, 0.0,\
1E+100,0.0,0,560)
DeclareParameter("dcdc.GoffDiode", "Opened diode conductance [S]", 9, 1E-05, 0.0,\
1E+100,0.0,0,560)
DeclareParameter("dcdc.VkneeDiode", "Diode forward threshold voltage [V]", 10, 0,\
 0.0,1E+100,0.0,0,560)
DeclareAlias2("dcdc.dc_p1.v", "Potential at the pin [V]", "simplifiedFuelCell.pin_p.v", 1,\
 5, 12, 4)
DeclareAlias2("dcdc.dc_p1.i", "Current flowing into the pin [A]", \
"simplifiedFuelCell.inductor.i", 1, 1, 0, 132)
DeclareAlias2("dcdc.dc_n1.v", "Potential at the pin [V]", "simplifiedFuelCell.constantVoltage1.V", 1,\
 5, 13, 4)
DeclareAlias2("dcdc.dc_n1.i", "Current flowing into the pin [A]", \
"simplifiedFuelCell.n1.i", -1, 5, 11, 132)
DeclareVariable("dcdc.vDC1", "DC voltage side 1 [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dcdc.iDC1", "DC current side 1 [A]", "simplifiedFuelCell.inductor.i", 1,\
 1, 0, 0)
DeclareVariable("dcdc.powerDC1", "DC power side 1 [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("dcdc.dc_p2.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("dcdc.dc_p2.i", "Current flowing into the pin [A]", "inductor.i", -1,\
 5, 57, 132)
DeclareAlias2("dcdc.dc_n2.v", "Potential at the pin [V]", "simplifiedFuelCell.constantVoltage1.V", 1,\
 5, 13, 4)
DeclareAlias2("dcdc.dc_n2.i", "Current flowing into the pin [A]", "inductor1.i", -1,\
 5, 103, 132)
DeclareVariable("dcdc.vDC2", "DC voltages side 2 [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dcdc.iDC2", "DC current side 2 [A]", "inductor.i", -1, 5, 57, 0)
DeclareVariable("dcdc.powerDC2", "DC power side 2 [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("dcdc.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("dcdc.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("dcdc.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("dcdc.T_heatPort", "Temperature of heatPort [K|degC]", 293.15, \
0.0,1E+100,300.0,0,513)
DeclareVariable("dcdc.useConstantEnable", "true = disabled boolean input, use constantEnable [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("dcdc.constantEnable", "Constant enabling of firing signals [:#(type=Boolean)]",\
 11, true, 0.0,0.0,0.0,0,562)
DeclareVariable("dcdc.m", "Number of phases [:#(type=Integer)]", 1, 1.0,1E+100,\
0.0,0,517)
DeclareVariable("dcdc.enableLogic.useConstantEnable", "true = disabled boolean input, use constantEnable [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("dcdc.enableLogic.constantEnable", "Constant enabling of firing signals [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("dcdc.enableLogic.m", "Number of phases [:#(type=Integer)]", 1, \
1.0,1E+100,0.0,0,517)
DeclareVariable("dcdc.enableLogic.enableConstantSource.k", "Constant output value [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("dcdc.enableLogic.enableConstantSource.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "dcdc.enableLogic.enableConstantSource.k", 1, 5, 31, 65)
DeclareVariable("dcdc.enableLogic.booleanReplicator.nout", "Number of outputs [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,517)
DeclareAlias2("dcdc.enableLogic.booleanReplicator.u", "Connector of Boolean input signal [:#(type=Boolean)]",\
 "dcdc.enableLogic.enableConstantSource.k", 1, 5, 31, 65)
DeclareAlias2("dcdc.enableLogic.booleanReplicator.y[1]", "Connector of Boolean output signals [:#(type=Boolean)]",\
 "dcdc.enableLogic.enableConstantSource.k", 1, 5, 31, 65)
DeclareAlias2("dcdc.enableLogic.internalEnable[1]", "m replicated enable signals [:#(type=Boolean)]",\
 "dcdc.enableLogic.enableConstantSource.k", 1, 5, 31, 65)
DeclareAlias2("dcdc.andCondition_p.u1", "Connector of first Boolean input signal [:#(type=Boolean)]",\
 "dcdc.fire_p", 1, 5, 34, 65)
DeclareAlias2("dcdc.andCondition_p.u2", "Connector of second Boolean input signal [:#(type=Boolean)]",\
 "dcdc.enableLogic.enableConstantSource.k", 1, 5, 31, 65)
DeclareVariable("dcdc.andCondition_p.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,642)
DeclareVariable("dcdc.fire_p", "Firing signal of positive potential transistor [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,642)
DeclareVariable("dcdc.transistor.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("dcdc.transistor.i", "Current flowing from pin p to pin n [A]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dcdc.transistor.p.v", "Potential at the pin [V]", \
"simplifiedFuelCell.pin_p.v", 1, 5, 12, 4)
DeclareAlias2("dcdc.transistor.p.i", "Current flowing into the pin [A]", \
"dcdc.transistor.i", 1, 5, 36, 132)
DeclareAlias2("dcdc.transistor.n.v", "Potential at the pin [V]", \
"simplifiedFuelCell.constantVoltage1.V", 1, 5, 13, 4)
DeclareAlias2("dcdc.transistor.n.i", "Current flowing into the pin [A]", \
"dcdc.transistor.i", -1, 5, 36, 132)
DeclareVariable("dcdc.transistor.Ron", "Forward state-on differential resistance (closed resistance) [Ohm]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("dcdc.transistor.Goff", "Backward state-off conductance (opened conductance) [S]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("dcdc.transistor.Vknee", "Forward threshold voltage [V]", 0.0, \
0.0,1E+100,0.0,0,513)
DeclareVariable("dcdc.transistor.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("dcdc.transistor.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 12, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("dcdc.transistor.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dcdc.transistor.T_heatPort", "Temperature of heatPort [K|degC]", \
"dcdc.transistor.T", 1, 7, 12, 0)
DeclareVariable("dcdc.transistor.off", "Switching state [:#(type=Boolean)]", \
true, 0.0,0.0,0.0,0,706)
DeclareVariable("dcdc.transistor.s", "Auxiliary variable for actual position on the ideal diode characteristic [1]",\
 0, 0.0,0.0,0.0,0,2560)
DeclareVariable("dcdc.transistor.unitVoltage", "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("dcdc.transistor.unitCurrent", "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("dcdc.transistor.fire", "[:#(type=Boolean)]", "dcdc.andCondition_p.y", 1,\
 5, 33, 65)
DeclareVariable("dcdc.diode.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dcdc.diode.i", "Current flowing from pin p to pin n [A]", \
"inductor.i", 1, 5, 57, 0)
DeclareAlias2("dcdc.diode.p.v", "Potential at the pin [V]", "simplifiedFuelCell.pin_p.v", 1,\
 5, 12, 4)
DeclareAlias2("dcdc.diode.p.i", "Current flowing into the pin [A]", "inductor.i", 1,\
 5, 57, 132)
DeclareAlias2("dcdc.diode.n.v", "Potential at the pin [V]", "dcdc.dc_p2.v", 1, 5,\
 19, 4)
DeclareAlias2("dcdc.diode.n.i", "Current flowing into the pin [A]", "inductor.i", -1,\
 5, 57, 132)
DeclareVariable("dcdc.diode.Ron", "Forward state-on differential resistance (closed resistance) [Ohm]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("dcdc.diode.Goff", "Backward state-off conductance (opened conductance) [S]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("dcdc.diode.Vknee", "Forward threshold voltage [V]", 0.0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("dcdc.diode.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("dcdc.diode.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 13, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("dcdc.diode.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dcdc.diode.T_heatPort", "Temperature of heatPort [K|degC]", \
"dcdc.diode.T", 1, 7, 13, 0)
DeclareVariable("dcdc.diode.off", "Switching state [:#(type=Boolean)]", true, \
0.0,0.0,0.0,0,706)
DeclareVariable("dcdc.diode.s", "Auxiliary variable for actual position on the ideal diode characteristic [1]",\
 0, 0.0,0.0,0.0,0,2560)
DeclareVariable("dcdc.diode.unitVoltage", "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("dcdc.diode.unitCurrent", "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("inductor.v", "Voltage drop of the two pins (= p.v - n.v) [V]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inductor.i", "Current flowing from pin p to pin n [A]", 0, \
0.0,0.0,0.0,0,512)
DeclareVariable("inductor.der(i)", "der(Current flowing from pin p to pin n) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inductor.p.v", "Potential at the pin [V]", "dcdc.dc_p2.v", 1, 5, 19,\
 4)
DeclareAlias2("inductor.p.i", "Current flowing into the pin [A]", "inductor.i", 1,\
 5, 57, 132)
DeclareVariable("inductor.n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("inductor.n.i", "Current flowing into the pin [A]", "inductor.i", -1,\
 5, 57, 132)
DeclareParameter("inductor.L", "Inductance [H]", 14, 1E-06, 0.0,0.0,0.0,0,560)
DeclareVariable("pwm.useConstantDutyCycle", "Enables constant duty cycle [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("pwm.constantDutyCycle", "Constant duty cycle", 15, 0.5, \
0.0,0.0,0.0,0,560)
DeclareParameter("pwm.f", "Switching frequency [Hz]", 16, 10, 0.0,0.0,0.0,0,560)
DeclareParameter("pwm.startTime", "Start time [s]", 17, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("pwm.fire", "Firing PWM signal [:#(type=Boolean)]", "dcdc.fire_p", 1,\
 5, 34, 65)
DeclareVariable("pwm.notFire", "Firing PWM signal [:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,642)
DeclareVariable("pwm.const.k", "Constant output value", 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("pwm.const.y", "Connector of Real output signal", "pwm.const.k", 1,\
 5, 62, 0)
DeclareParameter("pwm.limiter.uMax", "Upper limits of input signals", 18, 1, \
0.0,0.0,0.0,0,560)
DeclareParameter("pwm.limiter.uMin", "Lower limits of input signals", 19, 0, \
0.0,0.0,0.0,0,560)
DeclareVariable("pwm.limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("pwm.limiter.homotopyType", "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("pwm.limiter.limitsAtInit", "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("pwm.limiter.u", "Connector of Real input signal", "pwm.const.k", 1,\
 5, 62, 0)
DeclareVariable("pwm.limiter.y", "Connector of Real output signal", 0.0, \
0.0,0.0,0.0,0,513)
DeclareAlias2("pwm.limiter.simplifiedExpr", "Simplified expression for homotopy-based initialization",\
 "pwm.const.k", 1, 5, 62, 1024)
DeclareVariable("pwm.greaterEqual.u1", "Connector of first Real input signal", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pwm.greaterEqual.u2", "Connector of second Real input signal", \
0.0, 0.0,0.0,0.0,0,640)
DeclareAlias2("pwm.greaterEqual.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "dcdc.fire_p", 1, 5, 34, 65)
DeclareVariable("pwm.zeroOrderHold.samplePeriod", "Sample period of component [s]",\
 0.1, 1E-13,1E+100,0.0,0,513)
DeclareVariable("pwm.zeroOrderHold.startTime", "First sample time instant [s]", \
0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pwm.zeroOrderHold.sampleTrigger", "True, if sample time instant [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2690)
DeclareVariable("pwm.zeroOrderHold.firstTrigger", "Rising edge signals first sample instant [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2706)
DeclareAlias2("pwm.zeroOrderHold.u", "Connector of Real input signal", \
"pwm.limiter.y", 1, 5, 66, 0)
DeclareAlias2("pwm.zeroOrderHold.y", "Connector of Real output signal", \
"pwm.greaterEqual.u2", 1, 5, 68, 0)
DeclareVariable("pwm.zeroOrderHold.ySample", "", 0, 0.0,0.0,0.0,0,656)
DeclareVariable("pwm.sawtooth.amplitude", "Amplitude of saw tooth", 1, 0.0,0.0,\
0.0,0,513)
DeclareVariable("pwm.sawtooth.period", "Time for one period [s]", 1, 1E-60,\
1E+100,0.0,0,513)
DeclareVariable("pwm.sawtooth.nperiod", "Number of periods (< 0 means infinite number of periods) [:#(type=Integer)]",\
 -1, 0.0,0.0,0.0,0,517)
DeclareAlias2("pwm.sawtooth.y", "Connector of Real output signal", \
"pwm.greaterEqual.u1", 1, 5, 67, 0)
DeclareVariable("pwm.sawtooth.offset", "Offset of output signal y", 0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("pwm.sawtooth.startTime", "Output y = offset for time < startTime [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pwm.sawtooth.T_start", "Start time of current period [s]", 0.0,\
 0.0,0.0,0.0,0,2688)
DeclareVariable("pwm.sawtooth.count", "Period count [:#(type=Integer)]", 0, \
0.0,0.0,0.0,0,2692)
DeclareAlias2("pwm.inverse.u", "Connector of Boolean input signal [:#(type=Boolean)]",\
 "dcdc.fire_p", 1, 5, 34, 65)
DeclareAlias2("pwm.inverse.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "pwm.notFire", 1, 5, 61, 65)
DeclareVariable("pwm1.useConstantDutyCycle", "Enables constant duty cycle [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("pwm1.constantDutyCycle", "Constant duty cycle", 20, 0.5, \
0.0,0.0,0.0,0,560)
DeclareParameter("pwm1.f", "Switching frequency [Hz]", 21, 10, 0.0,0.0,0.0,0,560)
DeclareParameter("pwm1.startTime", "Start time [s]", 22, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("pwm1.dutyCycle", "Duty cycle", "modulatedSignalController.y", 1, 5,\
 149, 0)
DeclareVariable("pwm1.fire", "Firing PWM signal [:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,642)
DeclareVariable("pwm1.notFire", "Firing PWM signal [:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,642)
DeclareParameter("pwm1.limiter.uMax", "Upper limits of input signals", 23, 1, \
0.0,0.0,0.0,0,560)
DeclareParameter("pwm1.limiter.uMin", "Lower limits of input signals", 24, 0, \
0.0,0.0,0.0,0,560)
DeclareVariable("pwm1.limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("pwm1.limiter.homotopyType", "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("pwm1.limiter.limitsAtInit", "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("pwm1.limiter.u", "Connector of Real input signal", \
"modulatedSignalController.y", 1, 5, 149, 0)
DeclareVariable("pwm1.limiter.y", "Connector of Real output signal", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("pwm1.limiter.simplifiedExpr", "Simplified expression for homotopy-based initialization",\
 "modulatedSignalController.y", 1, 5, 149, 1024)
DeclareVariable("pwm1.greaterEqual.u1", "Connector of first Real input signal", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pwm1.greaterEqual.u2", "Connector of second Real input signal",\
 0.0, 0.0,0.0,0.0,0,640)
DeclareAlias2("pwm1.greaterEqual.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "pwm1.fire", 1, 5, 82, 65)
DeclareVariable("pwm1.zeroOrderHold.samplePeriod", "Sample period of component [s]",\
 0.1, 1E-13,1E+100,0.0,0,513)
DeclareVariable("pwm1.zeroOrderHold.startTime", "First sample time instant [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pwm1.zeroOrderHold.sampleTrigger", "True, if sample time instant [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2690)
DeclareVariable("pwm1.zeroOrderHold.firstTrigger", "Rising edge signals first sample instant [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2706)
DeclareAlias2("pwm1.zeroOrderHold.u", "Connector of Real input signal", \
"pwm1.limiter.y", 1, 5, 87, 0)
DeclareAlias2("pwm1.zeroOrderHold.y", "Connector of Real output signal", \
"pwm1.greaterEqual.u2", 1, 5, 89, 0)
DeclareVariable("pwm1.zeroOrderHold.ySample", "", 0, 0.0,0.0,0.0,0,656)
DeclareVariable("pwm1.sawtooth.amplitude", "Amplitude of saw tooth", 1, 0.0,0.0,\
0.0,0,513)
DeclareVariable("pwm1.sawtooth.period", "Time for one period [s]", 1, 1E-60,\
1E+100,0.0,0,513)
DeclareVariable("pwm1.sawtooth.nperiod", "Number of periods (< 0 means infinite number of periods) [:#(type=Integer)]",\
 -1, 0.0,0.0,0.0,0,517)
DeclareAlias2("pwm1.sawtooth.y", "Connector of Real output signal", \
"pwm1.greaterEqual.u1", 1, 5, 88, 0)
DeclareVariable("pwm1.sawtooth.offset", "Offset of output signal y", 0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("pwm1.sawtooth.startTime", "Output y = offset for time < startTime [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pwm1.sawtooth.T_start", "Start time of current period [s]", 0.0,\
 0.0,0.0,0.0,0,2688)
DeclareVariable("pwm1.sawtooth.count", "Period count [:#(type=Integer)]", 0, \
0.0,0.0,0.0,0,2692)
DeclareAlias2("pwm1.inverse.u", "Connector of Boolean input signal [:#(type=Boolean)]",\
 "pwm1.fire", 1, 5, 82, 65)
DeclareAlias2("pwm1.inverse.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "pwm1.notFire", 1, 5, 83, 65)
DeclareVariable("inductor1.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inductor1.i", "Current flowing from pin p to pin n [A]", 0, \
0.0,0.0,0.0,0,512)
DeclareVariable("inductor1.der(i)", "der(Current flowing from pin p to pin n) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inductor1.p.v", "Potential at the pin [V]", "simplifiedFuelCell.constantVoltage1.V", 1,\
 5, 13, 4)
DeclareAlias2("inductor1.p.i", "Current flowing into the pin [A]", "inductor1.i", 1,\
 5, 103, 132)
DeclareVariable("inductor1.n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("inductor1.n.i", "Current flowing into the pin [A]", "inductor1.i", -1,\
 5, 103, 132)
DeclareParameter("inductor1.L", "Inductance [H]", 25, 1E-06, 0.0,0.0,0.0,0,560)
DeclareVariable("simpleMotor.inductor.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("simpleMotor.inductor.i", "Current flowing from pin p to pin n [A]",\
 1, 0, 0.0,0.0,0.0,0,560)
DeclareDerivative("simpleMotor.inductor.der(i)", "der(Current flowing from pin p to pin n) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("simpleMotor.inductor.p.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,520)
DeclareAlias2("simpleMotor.inductor.p.i", "Current flowing into the pin [A]", \
"simpleMotor.inductor.i", 1, 1, 1, 132)
DeclareVariable("simpleMotor.inductor.n.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,520)
DeclareAlias2("simpleMotor.inductor.n.i", "Current flowing into the pin [A]", \
"simpleMotor.inductor.i", -1, 1, 1, 132)
DeclareVariable("simpleMotor.inductor.L", "Inductance [H]", 1, 0.0,0.0,0.0,0,513)
DeclareParameter("simpleMotor.R", "Effective resistance for hysteresis [Ohm]", 26,\
 149, 0.0,0.0,0.0,0,560)
DeclareVariable("simpleMotor.resistor.R", "Resistance at temperature T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareParameter("simpleMotor.resistor.T_ref", "Reference temperature [K|degC]",\
 27, 300.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("simpleMotor.resistor.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 28, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("simpleMotor.resistor.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("simpleMotor.resistor.i", "Current flowing from pin p to pin n [A]",\
 "simpleMotor.inductor.i", 1, 1, 1, 0)
DeclareAlias2("simpleMotor.resistor.p.v", "Potential at the pin [V]", \
"simpleMotor.p1.v", 1, 5, 123, 4)
DeclareAlias2("simpleMotor.resistor.p.i", "Current flowing into the pin [A]", \
"simpleMotor.inductor.i", 1, 1, 1, 132)
DeclareAlias2("simpleMotor.resistor.n.v", "Potential at the pin [V]", \
"simpleMotor.inductor.p.v", 1, 5, 107, 4)
DeclareAlias2("simpleMotor.resistor.n.i", "Current flowing into the pin [A]", \
"simpleMotor.inductor.i", -1, 1, 1, 132)
DeclareVariable("simpleMotor.resistor.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("simpleMotor.resistor.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("simpleMotor.resistor.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("simpleMotor.resistor.T_heatPort", "Temperature of heatPort [K|degC]",\
 "simpleMotor.resistor.T", 1, 5, 113, 0)
DeclareVariable("simpleMotor.resistor.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("simpleMotor.R_trs", "Effective resistance for transport  ac loss [Ohm]",\
 29, 1E-06, 0.0,0.0,0.0,0,560)
DeclareParameter("simpleMotor.X_s", "Reactance [H]", 30, 0.041, 0.0,0.0,0.0,0,560)
DeclareVariable("simpleMotor.hysteresis.R", "Resistance at temperature T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareParameter("simpleMotor.hysteresis.T_ref", "Reference temperature [K|degC]",\
 31, 300.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("simpleMotor.hysteresis.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 32, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("simpleMotor.hysteresis.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 "simpleMotor.inductor.n.v", 1, 5, 108, 0)
DeclareVariable("simpleMotor.hysteresis.i", "Current flowing from pin p to pin n [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("simpleMotor.hysteresis.p.v", "Potential at the pin [V]", \
"simpleMotor.inductor.n.v", 1, 5, 108, 4)
DeclareAlias2("simpleMotor.hysteresis.p.i", "Current flowing into the pin [A]", \
"simpleMotor.hysteresis.i", 1, 5, 117, 132)
DeclareVariable("simpleMotor.hysteresis.n.v", "Potential at the pin [V]", 0, \
0.0,0.0,0.0,0,521)
DeclareAlias2("simpleMotor.hysteresis.n.i", "Current flowing into the pin [A]", \
"simpleMotor.hysteresis.i", -1, 5, 117, 132)
DeclareVariable("simpleMotor.hysteresis.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("simpleMotor.hysteresis.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("simpleMotor.hysteresis.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("simpleMotor.hysteresis.T_heatPort", "Temperature of heatPort [K|degC]",\
 "simpleMotor.hysteresis.T", 1, 5, 120, 0)
DeclareVariable("simpleMotor.hysteresis.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("simpleMotor.R_hyst", "Effective resistance for hysteresis ac loss [Ohm]",\
 33, 149, 0.0,0.0,0.0,0,560)
DeclareVariable("simpleMotor.p1.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,\
0,520)
DeclareAlias2("simpleMotor.p1.i", "Current flowing into the pin [A]", \
"simpleMotor.inductor.i", 1, 1, 1, 132)
DeclareVariable("simpleMotor.emf.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("simpleMotor.emf.k", "Transformation coefficient [N.m/A]", 1, \
0.0,0.0,0.0,0,513)
DeclareAlias2("simpleMotor.emf.v", "Voltage drop between the two pins [V]", \
"simpleMotor.inductor.n.v", 1, 5, 108, 0)
DeclareVariable("simpleMotor.emf.i", "Current flowing from positive to negative pin [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("simpleMotor.emf.phi", "Angle of shaft flange with respect to support (= flange.phi - support.phi) [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("simpleMotor.emf.der(phi)", "der(Angle of shaft flange with respect to support (= flange.phi - support.phi)) [rad/s]",\
 "fan.inertia.w", 1, 1, 3, 0)
DeclareAlias2("simpleMotor.emf.w", "Angular velocity of flange relative to support [rad/s]",\
 "fan.inertia.w", 1, 1, 3, 0)
DeclareAlias2("simpleMotor.emf.tau", "Torque of flange [N.m]", "simpleMotor.flange1.tau", 1,\
 5, 130, 0)
DeclareAlias2("simpleMotor.emf.tauElectrical", "Electrical torque [N.m]", \
"simpleMotor.flange1.tau", -1, 5, 130, 0)
DeclareAlias2("simpleMotor.emf.p.v", "Potential at the pin [V]", \
"simpleMotor.inductor.n.v", 1, 5, 108, 4)
DeclareAlias2("simpleMotor.emf.p.i", "Current flowing into the pin [A]", \
"simpleMotor.emf.i", 1, 5, 126, 132)
DeclareVariable("simpleMotor.emf.n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,\
0.0,0,521)
DeclareAlias2("simpleMotor.emf.n.i", "Current flowing into the pin [A]", \
"simpleMotor.emf.i", -1, 5, 126, 132)
DeclareAlias2("simpleMotor.emf.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "simpleMotor.flange1.phi", 1, 5, 129, 4)
DeclareAlias2("simpleMotor.emf.flange.tau", "Cut torque in the flange [N.m]", \
"simpleMotor.flange1.tau", 1, 5, 130, 132)
DeclareParameter("simpleMotor.emf.fixed.phi0", "Fixed offset angle of housing [rad|deg]",\
 34, 0, 0.0,0.0,0.0,0,2608)
DeclareAlias2("simpleMotor.emf.fixed.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "simpleMotor.emf.fixed.phi0", 1, 7, 34, 1028)
DeclareAlias2("simpleMotor.emf.fixed.flange.tau", "Cut torque in the flange [N.m]",\
 "simpleMotor.flange1.tau", 1, 5, 130, 1156)
DeclareAlias2("simpleMotor.emf.internalSupport.tau", "External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau) [N.m]",\
 "simpleMotor.flange1.tau", -1, 5, 130, 1024)
DeclareAlias2("simpleMotor.emf.internalSupport.phi", "External support angle (= flange.phi) [rad|deg]",\
 "simpleMotor.emf.fixed.phi0", 1, 7, 34, 1024)
DeclareAlias2("simpleMotor.emf.internalSupport.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "simpleMotor.emf.fixed.phi0", 1, 7, 34, 1028)
DeclareAlias2("simpleMotor.emf.internalSupport.flange.tau", "Cut torque in the flange [N.m]",\
 "simpleMotor.flange1.tau", -1, 5, 130, 1156)
DeclareParameter("simpleMotor.k", "Transformation coefficient of back EMF [N.m/A]",\
 35, 0.021, 0.0,0.0,0.0,0,560)
DeclareVariable("simpleMotor.flange1.phi", "Absolute rotation angle of flange [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareVariable("simpleMotor.flange1.tau", "Cut torque in the flange [N.m]", 0.0,\
 0.0,0.0,0.0,0,776)
DeclareVariable("simpleMotor.ground.p.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,521)
DeclareVariable("simpleMotor.ground.p.i", "Current flowing into the pin [A]", \
0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("fan.inertia.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "fan.inertia.phi", 1, 1, 2, 4)
DeclareAlias2("fan.inertia.flange_a.tau", "Cut torque in the flange [N.m]", \
"simpleMotor.flange1.tau", -1, 5, 130, 132)
DeclareAlias2("fan.inertia.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "fan.inertia.phi", 1, 1, 2, 4)
DeclareVariable("fan.inertia.flange_b.tau", "Cut torque in the flange [N.m]", \
0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("fan.inertia.J", "Moment of inertia [kg.m2]", 1, 0.0,1E+100,0.0,\
0,513)
DeclareVariable("fan.inertia.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 3, 1.0,5.0,0.0,0,1541)
DeclareState("fan.inertia.phi", "Absolute rotation angle of component [rad|deg]",\
 2, 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("fan.inertia.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("fan.inertia.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 3, 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("fan.inertia.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("fan.inertia.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "fan.inertia.der(w)", 1, 6, 3, 0)
DeclareAlias2("fan.flange_a1.phi", "Absolute rotation angle of flange [rad|deg]",\
 "simpleMotor.flange1.phi", 1, 5, 129, 4)
DeclareAlias2("fan.flange_a1.tau", "Cut torque in the flange [N.m]", \
"simpleMotor.flange1.tau", -1, 5, 130, 132)
DeclareParameter("fan.J", "Moment of inertia of the fan blades [kg.m2]", 36, 0.5,\
 0.0,0.0,0.0,0,560)
DeclareAlias2("fan.disc.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "simpleMotor.flange1.phi", 1, 5, 129, 4)
DeclareAlias2("fan.disc.flange_a.tau", "Cut torque in the flange [N.m]", \
"simpleMotor.flange1.tau", -1, 5, 130, 132)
DeclareAlias2("fan.disc.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "fan.inertia.phi", 1, 1, 2, 4)
DeclareAlias2("fan.disc.flange_b.tau", "Cut torque in the flange [N.m]", \
"simpleMotor.flange1.tau", 1, 5, 130, 132)
DeclareVariable("fan.disc.deltaPhi", "Fixed rotation of left flange with respect to right flange (= flange_b.phi - flange_a.phi) [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("fan.disc.phi", "Absolute rotation angle of component [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("fan.deltaPhi", "Fixed rotation of left flange with respect to right flange [rad|deg]",\
 37, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("modulatedSignalController.limiter.uMax", "Upper limits of input signals",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("modulatedSignalController.limiter.uMin", "Lower limits of input signals",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("modulatedSignalController.limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("modulatedSignalController.limiter.homotopyType", \
"Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("modulatedSignalController.limiter.limitsAtInit", \
"Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("modulatedSignalController.limiter.u", "Connector of Real input signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("modulatedSignalController.limiter.der(u)", "der(Connector of Real input signal)",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("modulatedSignalController.limiter.y", "Connector of Real output signal",\
 "modulatedSignalController.y", 1, 5, 149, 0)
DeclareAlias2("modulatedSignalController.limiter.simplifiedExpr", \
"Simplified expression for homotopy-based initialization", "modulatedSignalController.limiter.u", 1,\
 5, 143, 1024)
DeclareAlias2("modulatedSignalController.add.u1", "Connector of Real input signal 1",\
 "modulatedSignalController.Reference", 1, 5, 146, 0)
DeclareAlias2("modulatedSignalController.add.u2", "Connector of Real input signal 2 [A]",\
 "simpleMotor.inductor.i", 1, 1, 1, 0)
DeclareVariable("modulatedSignalController.add.y", "Connector of Real output signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("modulatedSignalController.add.k1", "Gain of input signal 1", 38,\
 1, 0.0,0.0,0.0,0,560)
DeclareParameter("modulatedSignalController.add.k2", "Gain of input signal 2", 39,\
 -1, 0.0,0.0,0.0,0,560)
DeclareVariable("modulatedSignalController.Reference", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("modulatedSignalController.FeedbackSignal", "[A]", \
"simpleMotor.inductor.i", 1, 1, 1, 0)
DeclareAlias2("modulatedSignalController.Vdc2", "", "const.k", 1, 5, 199, 0)
DeclareVariable("modulatedSignalController.division.u1", "Connector of Real input signal 1",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("modulatedSignalController.division.der(u1)", "der(Connector of Real input signal 1)",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("modulatedSignalController.division.u2", "Connector of Real input signal 2",\
 "const.k", 1, 5, 199, 0)
DeclareAlias2("modulatedSignalController.division.y", "Connector of Real output signal",\
 "modulatedSignalController.limiter.u", 1, 5, 143, 0)
DeclareVariable("modulatedSignalController.y", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("modulatedSignalController.der(y)", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("modulatedSignalController.transferFunction.u", "Connector of Real input signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("modulatedSignalController.transferFunction.der(u)", \
"der(Connector of Real input signal)", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("modulatedSignalController.transferFunction.y", "Connector of Real output signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("modulatedSignalController.transferFunction.der(y)", \
"der(Connector of Real output signal)", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("modulatedSignalController.transferFunction.b[1]", \
"Numerator coefficients of transfer function (e.g., 2*s+3 is specified as {2,3})",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("modulatedSignalController.transferFunction.b[2]", \
"Numerator coefficients of transfer function (e.g., 2*s+3 is specified as {2,3})",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("modulatedSignalController.transferFunction.a[1]", \
"Denominator coefficients of transfer function (e.g., 5*s+6 is specified as {5,6})",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("modulatedSignalController.transferFunction.a[2]", \
"Denominator coefficients of transfer function (e.g., 5*s+6 is specified as {5,6})",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("modulatedSignalController.transferFunction.initType", \
"Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareParameter("modulatedSignalController.transferFunction.x_start[1]", \
"Initial or guess values of states", 40, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("modulatedSignalController.transferFunction.y_start", \
"Initial value of output (derivatives of y are zero up to nx-1-th derivative)", 41,\
 0, 0.0,0.0,0.0,0,560)
DeclareVariable("modulatedSignalController.transferFunction.x[1]", \
"State of transfer function from controller canonical form", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("modulatedSignalController.transferFunction.na", \
"Size of Denominator of transfer function. [:#(type=Integer)]", 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("modulatedSignalController.transferFunction.nb", \
"Size of Numerator of transfer function. [:#(type=Integer)]", 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("modulatedSignalController.transferFunction.nx", \
"[:#(type=Integer)]", 1, 0.0,0.0,0.0,0,2565)
DeclareVariable("modulatedSignalController.transferFunction.bb[1]", "", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("modulatedSignalController.transferFunction.bb[2]", "", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("modulatedSignalController.transferFunction.d", "", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("modulatedSignalController.transferFunction.a_end", "", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareState("modulatedSignalController.transferFunction.x_scaled[1]", \
"Scaled vector x", 4, 0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("modulatedSignalController.transferFunction.der(x_scaled[1])",\
 "der(Scaled vector x)", 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("modulatedSignalController.transferFunction1.u", "Connector of Real input signal",\
 "modulatedSignalController.transferFunction.y", 1, 5, 153, 0)
DeclareAlias2("modulatedSignalController.transferFunction1.y", "Connector of Real output signal",\
 "modulatedSignalController.division.u1", 1, 5, 147, 0)
DeclareVariable("modulatedSignalController.transferFunction1.b[1]", \
"Numerator coefficients of transfer function (e.g., 2*s+3 is specified as {2,3})",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("modulatedSignalController.transferFunction1.b[2]", \
"Numerator coefficients of transfer function (e.g., 2*s+3 is specified as {2,3})",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("modulatedSignalController.transferFunction1.a[1]", \
"Denominator coefficients of transfer function (e.g., 5*s+6 is specified as {5,6})",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("modulatedSignalController.transferFunction1.a[2]", \
"Denominator coefficients of transfer function (e.g., 5*s+6 is specified as {5,6})",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("modulatedSignalController.transferFunction1.initType", \
"Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareParameter("modulatedSignalController.transferFunction1.x_start[1]", \
"Initial or guess values of states", 42, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("modulatedSignalController.transferFunction1.y_start", \
"Initial value of output (derivatives of y are zero up to nx-1-th derivative)", 43,\
 0, 0.0,0.0,0.0,0,560)
DeclareVariable("modulatedSignalController.transferFunction1.x[1]", \
"State of transfer function from controller canonical form", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("modulatedSignalController.transferFunction1.na", \
"Size of Denominator of transfer function. [:#(type=Integer)]", 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("modulatedSignalController.transferFunction1.nb", \
"Size of Numerator of transfer function. [:#(type=Integer)]", 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("modulatedSignalController.transferFunction1.nx", \
"[:#(type=Integer)]", 1, 0.0,0.0,0.0,0,2565)
DeclareVariable("modulatedSignalController.transferFunction1.bb[1]", "", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("modulatedSignalController.transferFunction1.bb[2]", "", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("modulatedSignalController.transferFunction1.d", "", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("modulatedSignalController.transferFunction1.a_end", "", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareState("modulatedSignalController.transferFunction1.x_scaled[1]", \
"Scaled vector x", 5, 0.0, 0.0,0.0,0.0,0,2608)
DeclareDerivative("modulatedSignalController.transferFunction1.der(x_scaled[1])",\
 "der(Scaled vector x)", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("modulatedSignalController.transferFunction2.u", \
"Connector of Real input signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("modulatedSignalController.transferFunction2.y", "Connector of Real output signal",\
 "modulatedSignalController.transferFunction.u", 1, 5, 151, 0)
DeclareVariable("modulatedSignalController.transferFunction2.b[1]", \
"Numerator coefficients of transfer function (e.g., 2*s+3 is specified as {2,3})",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("modulatedSignalController.transferFunction2.b[2]", \
"Numerator coefficients of transfer function (e.g., 2*s+3 is specified as {2,3})",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("modulatedSignalController.transferFunction2.a[1]", \
"Denominator coefficients of transfer function (e.g., 5*s+6 is specified as {5,6})",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("modulatedSignalController.transferFunction2.a[2]", \
"Denominator coefficients of transfer function (e.g., 5*s+6 is specified as {5,6})",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("modulatedSignalController.transferFunction2.a[3]", \
"Denominator coefficients of transfer function (e.g., 5*s+6 is specified as {5,6})",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("modulatedSignalController.transferFunction2.initType", \
"Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareParameter("modulatedSignalController.transferFunction2.x_start[1]", \
"Initial or guess values of states", 44, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("modulatedSignalController.transferFunction2.x_start[2]", \
"Initial or guess values of states", 45, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("modulatedSignalController.transferFunction2.y_start", \
"Initial value of output (derivatives of y are zero up to nx-1-th derivative)", 46,\
 0, 0.0,0.0,0.0,0,560)
DeclareVariable("modulatedSignalController.transferFunction2.x[1]", \
"State of transfer function from controller canonical form", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("modulatedSignalController.transferFunction2.x[2]", \
"State of transfer function from controller canonical form", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("modulatedSignalController.transferFunction2.na", \
"Size of Denominator of transfer function. [:#(type=Integer)]", 3, 0.0,0.0,0.0,0,2565)
DeclareVariable("modulatedSignalController.transferFunction2.nb", \
"Size of Numerator of transfer function. [:#(type=Integer)]", 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("modulatedSignalController.transferFunction2.nx", \
"[:#(type=Integer)]", 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("modulatedSignalController.transferFunction2.bb[1]", "", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("modulatedSignalController.transferFunction2.bb[2]", "", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("modulatedSignalController.transferFunction2.bb[3]", "", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("modulatedSignalController.transferFunction2.d", "", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("modulatedSignalController.transferFunction2.a_end", "", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareState("modulatedSignalController.transferFunction2.x_scaled[1]", \
"Scaled vector x", 6, 0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("modulatedSignalController.transferFunction2.der(x_scaled[1])",\
 "der(Scaled vector x)", 0.0, 0.0,0.0,0.0,0,2560)
DeclareState("modulatedSignalController.transferFunction2.x_scaled[2]", \
"Scaled vector x", 7, 0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("modulatedSignalController.transferFunction2.der(x_scaled[2])",\
 "der(Scaled vector x)", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("modulatedSignalController.gain.k", "Gain value multiplied with input signal [1]",\
 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("modulatedSignalController.gain.u", "Input signal connector", \
"modulatedSignalController.add.y", 1, 5, 145, 0)
DeclareAlias2("modulatedSignalController.gain.y", "Output signal connector", \
"modulatedSignalController.transferFunction2.u", 1, 5, 181, 0)
DeclareParameter("modulatedSignalController.k", "Reference gain for difference between reference signal and the actual signal [1]",\
 47, 8680, 0.0,0.0,0.0,0,560)
DeclareParameter("modulatedSignalController.b1[1]", "Transfer function numerator 1",\
 48, 1.0, 0.0,0.0,0.0,0,560)
DeclareParameter("modulatedSignalController.b1[2]", "Transfer function numerator 1",\
 49, 8.52, 0.0,0.0,0.0,0,560)
DeclareParameter("modulatedSignalController.a1[1]", "Transfer function denominator 1",\
 50, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("modulatedSignalController.a1[2]", "Transfer function denominator 1",\
 51, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("modulatedSignalController.a1[3]", "Transfer function denominator 1",\
 52, 142129, 0.0,0.0,0.0,0,560)
DeclareParameter("modulatedSignalController.b2[1]", "Transfer function numerator 2",\
 53, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("modulatedSignalController.b2[2]", "Transfer function numerator 2",\
 54, 966, 0.0,0.0,0.0,0,560)
DeclareParameter("modulatedSignalController.a2[1]", "Transfer function denominator 2",\
 55, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("modulatedSignalController.a2[2]", "Transfer function denominator 2",\
 56, 5633, 0.0,0.0,0.0,0,560)
DeclareParameter("modulatedSignalController.b3[1]", "Transfer function numerator 3",\
 57, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("modulatedSignalController.b3[2]", "Transfer function numerator 3",\
 58, 2, 0.0,0.0,0.0,0,560)
DeclareParameter("modulatedSignalController.a3[1]", "Transfer function numerator 3",\
 59, 1.0, 0.0,0.0,0.0,0,560)
DeclareParameter("modulatedSignalController.a3[2]", "Transfer function numerator 3",\
 60, 0.05, 0.0,0.0,0.0,0,560)
DeclareParameter("modulatedSignalController.uMax", "Upper limit of output signal y",\
 61, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("modulatedSignalController.uMin", "Lower limits of output signal y",\
 62, -1, 0.0,0.0,0.0,0,560)
DeclareAlias2("currentSensor.p.v", "Potential at the pin [V]", "simpleMotor.p1.v", 1,\
 5, 123, 4)
DeclareAlias2("currentSensor.p.i", "Current flowing into the pin [A]", \
"simpleMotor.inductor.i", 1, 1, 1, 132)
DeclareAlias2("currentSensor.n.v", "Potential at the pin [V]", "simpleMotor.p1.v", 1,\
 5, 123, 4)
DeclareAlias2("currentSensor.n.i", "Current flowing into the pin [A]", \
"simpleMotor.inductor.i", -1, 1, 1, 132)
DeclareAlias2("currentSensor.i", "Current in the branch from p to n as output signal [A]",\
 "simpleMotor.inductor.i", 1, 1, 1, 0)
DeclareVariable("const.k", "Constant output value", 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("const.y", "Connector of Real output signal", "const.k", 1, 5, 199,\
 0)
DeclareParameter("sine.amplitude", "Amplitude of sine wave", 63, 1000, 0.0,0.0,\
0.0,0,560)
DeclareParameter("sine.freqHz", "Frequency of sine wave [Hz]", 64, 60, 0.0,0.0,\
0.0,0,560)
DeclareParameter("sine.phase", "Phase of sine wave [rad|deg]", 65, 0, 0.0,0.0,\
0.0,0,560)
DeclareAlias2("sine.y", "Connector of Real output signal", "modulatedSignalController.Reference", 1,\
 5, 146, 0)
DeclareParameter("sine.offset", "Offset of output signal y", 66, 0, 0.0,0.0,0.0,\
0,560)
DeclareParameter("sine.startTime", "Output y = offset for time < startTime [s]",\
 67, 0.07, 0.0,0.0,0.0,0,560)
DeclareParameter("plant.R", "Resistance of external network", 68, 0.005, \
0.0,0.0,0.0,0,560)
DeclareParameter("plant.L", "Inductance of external network", 69, 0.00069, \
0.0,0.0,0.0,0,560)
DeclareParameter("plant.ron", "Resistance of the switch ON state", 70, 0.00088, \
0.0,0.0,0.0,0,560)
DeclareParameter("plant.lambda", "Closed-loop time constant", 71, 0.005, \
0.0,0.0,0.0,0,560)
DeclareParameter("plant.Vd", "DC side voltage of the converter", 72, 1000, \
0.0,0.0,0.0,0,560)
DeclareAlias2("dCAC_HalfBridgeAverage.Q1gate", "[:#(type=Boolean)]", "pwm1.fire", 1,\
 5, 82, 65)
DeclareAlias2("dCAC_HalfBridgeAverage.ac.v", "Potential at the pin [V]", \
"simpleMotor.p1.v", 1, 5, 123, 4)
DeclareAlias2("dCAC_HalfBridgeAverage.ac.i", "Current flowing into the pin [A]",\
 "simpleMotor.inductor.i", -1, 1, 1, 132)
DeclareAlias2("dCAC_HalfBridgeAverage.Q4gate", "[:#(type=Boolean)]", \
"pwm1.notFire", 1, 5, 83, 65)
DeclareAlias2("dCAC_HalfBridgeAverage.switch1.GateSignal", "[:#(type=Boolean)]",\
 "pwm1.fire", 1, 5, 82, 65)
DeclareAlias2("dCAC_HalfBridgeAverage.switch1.pin.v", "Potential at the pin [V]",\
 "inductor.n.v", 1, 5, 59, 4)
DeclareAlias2("dCAC_HalfBridgeAverage.switch1.pin.i", "Current flowing into the pin [A]",\
 "inductor.i", 1, 5, 57, 132)
DeclareVariable("dCAC_HalfBridgeAverage.switch1.pin_n.v", "Potential at the pin [V]",\
 0, 0.0,0.0,0.0,0,521)
DeclareAlias2("dCAC_HalfBridgeAverage.switch1.pin_n.i", "Current flowing into the pin [A]",\
 "inductor.i", -1, 5, 57, 132)
DeclareAlias2("dCAC_HalfBridgeAverage.switch1.signalCurrent.p.v", \
"Potential at the pin [V]", "inductor.n.v", 1, 5, 59, 4)
DeclareAlias2("dCAC_HalfBridgeAverage.switch1.signalCurrent.p.i", \
"Current flowing into the pin [A]", "inductor.i", 1, 5, 57, 132)
DeclareVariable("dCAC_HalfBridgeAverage.switch1.signalCurrent.n.v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("dCAC_HalfBridgeAverage.switch1.signalCurrent.n.i", \
"Current flowing into the pin [A]", "inductor.i", -1, 5, 57, 132)
DeclareVariable("dCAC_HalfBridgeAverage.switch1.signalCurrent.v", \
"Voltage drop between the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dCAC_HalfBridgeAverage.switch1.signalCurrent.i", "Current flowing from pin p to pin n as input signal [A]",\
 "inductor.i", 1, 5, 57, 0)
DeclareAlias2("dCAC_HalfBridgeAverage.switch1.DutyCycle", "", "modulatedSignalController.y", 1,\
 5, 149, 0)
DeclareParameter("dCAC_HalfBridgeAverage.switch1.gain2.k", "Gain value multiplied with input signal [1]",\
 73, 2, 0.0,0.0,0.0,0,560)
DeclareAlias2("dCAC_HalfBridgeAverage.switch1.gain2.u", "Input signal connector",\
 "modulatedSignalController.y", 1, 5, 149, 0)
DeclareVariable("dCAC_HalfBridgeAverage.switch1.gain2.y", "Output signal connector",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("dCAC_HalfBridgeAverage.switch1.gain2.der(y)", "der(Output signal connector)",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("dCAC_HalfBridgeAverage.switch1.const.k", "Constant output value",\
 74, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("dCAC_HalfBridgeAverage.switch1.const.y", "Connector of Real output signal",\
 "dCAC_HalfBridgeAverage.switch1.const.k", 1, 7, 74, 0)
DeclareAlias2("dCAC_HalfBridgeAverage.switch1.add.u1", "Connector of Real input signal 1",\
 "dCAC_HalfBridgeAverage.switch1.gain2.y", 1, 5, 203, 0)
DeclareAlias2("dCAC_HalfBridgeAverage.switch1.add.u2", "Connector of Real input signal 2",\
 "dCAC_HalfBridgeAverage.switch1.const.k", 1, 7, 74, 0)
DeclareVariable("dCAC_HalfBridgeAverage.switch1.add.y", "Connector of Real output signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("dCAC_HalfBridgeAverage.switch1.add.der(y)", "der(Connector of Real output signal)",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("dCAC_HalfBridgeAverage.switch1.add.k1", "Gain of input signal 1",\
 75, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("dCAC_HalfBridgeAverage.switch1.add.k2", "Gain of input signal 2",\
 76, -1, 0.0,0.0,0.0,0,560)
DeclareAlias2("dCAC_HalfBridgeAverage.switch1.add1.u1", "Connector of Real input signal 1",\
 "dCAC_HalfBridgeAverage.switch1.add.y", 1, 5, 205, 0)
DeclareAlias2("dCAC_HalfBridgeAverage.switch1.add1.u2", "Connector of Real input signal 2",\
 "dCAC_HalfBridgeAverage.switch1.const1.k", 1, 7, 80, 0)
DeclareVariable("dCAC_HalfBridgeAverage.switch1.add1.y", "Connector of Real output signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("dCAC_HalfBridgeAverage.switch1.add1.der(y)", "der(Connector of Real output signal)",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("dCAC_HalfBridgeAverage.switch1.add1.k1", "Gain of input signal 1",\
 77, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("dCAC_HalfBridgeAverage.switch1.add1.k2", "Gain of input signal 2",\
 78, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("dCAC_HalfBridgeAverage.switch1.division.u1", "Connector of Real input signal 1",\
 "dCAC_HalfBridgeAverage.switch1.add1.y", 1, 5, 207, 0)
DeclareAlias2("dCAC_HalfBridgeAverage.switch1.division.u2", "Connector of Real input signal 2",\
 "dCAC_HalfBridgeAverage.switch1.const2.k", 1, 7, 79, 0)
DeclareVariable("dCAC_HalfBridgeAverage.switch1.division.y", "Connector of Real output signal [1]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("dCAC_HalfBridgeAverage.switch1.division.der(y)", \
"der(Connector of Real output signal) [s-1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("dCAC_HalfBridgeAverage.switch1.const2.k", "Constant output value",\
 79, 2, 0.0,0.0,0.0,0,560)
DeclareAlias2("dCAC_HalfBridgeAverage.switch1.const2.y", "Connector of Real output signal",\
 "dCAC_HalfBridgeAverage.switch1.const2.k", 1, 7, 79, 0)
DeclareParameter("dCAC_HalfBridgeAverage.switch1.const1.k", "Constant output value",\
 80, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("dCAC_HalfBridgeAverage.switch1.const1.y", "Connector of Real output signal",\
 "dCAC_HalfBridgeAverage.switch1.const1.k", 1, 7, 80, 0)
DeclareAlias2("dCAC_HalfBridgeAverage.switch1.product.u1", "Connector of Real input signal 1 [1]",\
 "dCAC_HalfBridgeAverage.switch1.division.y", 1, 5, 209, 0)
DeclareAlias2("dCAC_HalfBridgeAverage.switch1.product.u2", "Connector of Real input signal 2 [A]",\
 "simpleMotor.inductor.i", 1, 1, 1, 0)
DeclareAlias2("dCAC_HalfBridgeAverage.switch1.product.y", "Connector of Real output signal [A]",\
 "inductor.i", 1, 5, 57, 0)
DeclareAlias2("dCAC_HalfBridgeAverage.switch1.current", "[A]", "simpleMotor.inductor.i", 1,\
 1, 1, 0)
DeclareVariable("dCAC_HalfBridgeAverage.switch1.resistor.R", "Resistance at temperature T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareParameter("dCAC_HalfBridgeAverage.switch1.resistor.T_ref", \
"Reference temperature [K|degC]", 81, 300.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("dCAC_HalfBridgeAverage.switch1.resistor.alpha", \
"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 82, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("dCAC_HalfBridgeAverage.switch1.resistor.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 "dCAC_HalfBridgeAverage.switch1.signalCurrent.n.v", 1, 5, 201, 0)
DeclareAlias2("dCAC_HalfBridgeAverage.switch1.resistor.i", "Current flowing from pin p to pin n [A]",\
 "inductor.i", 1, 5, 57, 0)
DeclareAlias2("dCAC_HalfBridgeAverage.switch1.resistor.p.v", "Potential at the pin [V]",\
 "dCAC_HalfBridgeAverage.switch1.signalCurrent.n.v", 1, 5, 201, 4)
DeclareAlias2("dCAC_HalfBridgeAverage.switch1.resistor.p.i", "Current flowing into the pin [A]",\
 "inductor.i", 1, 5, 57, 132)
DeclareVariable("dCAC_HalfBridgeAverage.switch1.resistor.n.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("dCAC_HalfBridgeAverage.switch1.resistor.n.i", "Current flowing into the pin [A]",\
 "inductor.i", -1, 5, 57, 132)
DeclareVariable("dCAC_HalfBridgeAverage.switch1.resistor.useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("dCAC_HalfBridgeAverage.switch1.resistor.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("dCAC_HalfBridgeAverage.switch1.resistor.LossPower", \
"Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dCAC_HalfBridgeAverage.switch1.resistor.T_heatPort", \
"Temperature of heatPort [K|degC]", "dCAC_HalfBridgeAverage.switch1.resistor.T", 1,\
 5, 214, 0)
DeclareVariable("dCAC_HalfBridgeAverage.switch1.resistor.R_actual", \
"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]", 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("dCAC_HalfBridgeAverage.switch1.Ron", "Forward state-on differential resistance (closed resistance) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("dCAC_HalfBridgeAverage.switch4.GateSignal", "[:#(type=Boolean)]",\
 "pwm1.notFire", 1, 5, 83, 65)
DeclareVariable("dCAC_HalfBridgeAverage.switch4.pin.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("dCAC_HalfBridgeAverage.switch4.pin.i", "Current flowing into the pin [A]",\
 "inductor1.i", -1, 5, 103, 132)
DeclareVariable("dCAC_HalfBridgeAverage.switch4.Ron", "Forward state-on differential resistance (closed resistance) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("dCAC_HalfBridgeAverage.switch4.pin_n.v", "Potential at the pin [V]",\
 "inductor1.n.v", 1, 5, 105, 4)
DeclareAlias2("dCAC_HalfBridgeAverage.switch4.pin_n.i", "Current flowing into the pin [A]",\
 "inductor1.i", 1, 5, 103, 132)
DeclareVariable("dCAC_HalfBridgeAverage.switch4.signalCurrent.p.v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("dCAC_HalfBridgeAverage.switch4.signalCurrent.p.i", \
"Current flowing into the pin [A]", "inductor1.i", 1, 5, 103, 132)
DeclareVariable("dCAC_HalfBridgeAverage.switch4.signalCurrent.n.v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("dCAC_HalfBridgeAverage.switch4.signalCurrent.n.i", \
"Current flowing into the pin [A]", "inductor1.i", -1, 5, 103, 132)
DeclareAlias2("dCAC_HalfBridgeAverage.switch4.signalCurrent.v", "Voltage drop between the two pins (= p.v - n.v) [V]",\
 "dCAC_HalfBridgeAverage.switch4.signalCurrent.p.v", 1, 5, 220, 0)
DeclareAlias2("dCAC_HalfBridgeAverage.switch4.signalCurrent.i", "Current flowing from pin p to pin n as input signal [A]",\
 "inductor1.i", 1, 5, 103, 0)
DeclareAlias2("dCAC_HalfBridgeAverage.switch4.DutyCycle", "", "modulatedSignalController.y", 1,\
 5, 149, 0)
DeclareParameter("dCAC_HalfBridgeAverage.switch4.gain2.k", "Gain value multiplied with input signal [1]",\
 83, 2, 0.0,0.0,0.0,0,560)
DeclareAlias2("dCAC_HalfBridgeAverage.switch4.gain2.u", "Input signal connector",\
 "modulatedSignalController.y", 1, 5, 149, 0)
DeclareVariable("dCAC_HalfBridgeAverage.switch4.gain2.y", "Output signal connector",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("dCAC_HalfBridgeAverage.switch4.gain2.der(y)", "der(Output signal connector)",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("dCAC_HalfBridgeAverage.switch4.const.k", "Constant output value",\
 84, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("dCAC_HalfBridgeAverage.switch4.const.y", "Connector of Real output signal",\
 "dCAC_HalfBridgeAverage.switch4.const.k", 1, 7, 84, 0)
DeclareAlias2("dCAC_HalfBridgeAverage.switch4.add.u1", "Connector of Real input signal 1",\
 "dCAC_HalfBridgeAverage.switch4.gain2.y", 1, 5, 222, 0)
DeclareAlias2("dCAC_HalfBridgeAverage.switch4.add.u2", "Connector of Real input signal 2",\
 "dCAC_HalfBridgeAverage.switch4.const.k", 1, 7, 84, 0)
DeclareVariable("dCAC_HalfBridgeAverage.switch4.add.y", "Connector of Real output signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("dCAC_HalfBridgeAverage.switch4.add.der(y)", "der(Connector of Real output signal)",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("dCAC_HalfBridgeAverage.switch4.add.k1", "Gain of input signal 1",\
 85, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("dCAC_HalfBridgeAverage.switch4.add.k2", "Gain of input signal 2",\
 86, -1, 0.0,0.0,0.0,0,560)
DeclareAlias2("dCAC_HalfBridgeAverage.switch4.add1.u1", "Connector of Real input signal 1",\
 "dCAC_HalfBridgeAverage.switch4.add.y", 1, 5, 224, 0)
DeclareAlias2("dCAC_HalfBridgeAverage.switch4.add1.u2", "Connector of Real input signal 2",\
 "dCAC_HalfBridgeAverage.switch4.const1.k", 1, 7, 90, 0)
DeclareVariable("dCAC_HalfBridgeAverage.switch4.add1.y", "Connector of Real output signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("dCAC_HalfBridgeAverage.switch4.add1.der(y)", "der(Connector of Real output signal)",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("dCAC_HalfBridgeAverage.switch4.add1.k1", "Gain of input signal 1",\
 87, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("dCAC_HalfBridgeAverage.switch4.add1.k2", "Gain of input signal 2",\
 88, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("dCAC_HalfBridgeAverage.switch4.division.u1", "Connector of Real input signal 1",\
 "dCAC_HalfBridgeAverage.switch4.add1.y", 1, 5, 226, 0)
DeclareAlias2("dCAC_HalfBridgeAverage.switch4.division.u2", "Connector of Real input signal 2",\
 "dCAC_HalfBridgeAverage.switch4.const2.k", 1, 7, 89, 0)
DeclareVariable("dCAC_HalfBridgeAverage.switch4.division.y", "Connector of Real output signal [1]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("dCAC_HalfBridgeAverage.switch4.division.der(y)", \
"der(Connector of Real output signal) [s-1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("dCAC_HalfBridgeAverage.switch4.const2.k", "Constant output value",\
 89, 2, 0.0,0.0,0.0,0,560)
DeclareAlias2("dCAC_HalfBridgeAverage.switch4.const2.y", "Connector of Real output signal",\
 "dCAC_HalfBridgeAverage.switch4.const2.k", 1, 7, 89, 0)
DeclareParameter("dCAC_HalfBridgeAverage.switch4.const1.k", "Constant output value",\
 90, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("dCAC_HalfBridgeAverage.switch4.const1.y", "Connector of Real output signal",\
 "dCAC_HalfBridgeAverage.switch4.const1.k", 1, 7, 90, 0)
DeclareAlias2("dCAC_HalfBridgeAverage.switch4.product.u1", "Connector of Real input signal 1 [1]",\
 "dCAC_HalfBridgeAverage.switch4.division.y", 1, 5, 228, 0)
DeclareAlias2("dCAC_HalfBridgeAverage.switch4.product.u2", "Connector of Real input signal 2 [A]",\
 "simpleMotor.inductor.i", 1, 1, 1, 0)
DeclareAlias2("dCAC_HalfBridgeAverage.switch4.product.y", "Connector of Real output signal [A]",\
 "inductor1.i", 1, 5, 103, 0)
DeclareAlias2("dCAC_HalfBridgeAverage.switch4.current", "[A]", "simpleMotor.inductor.i", 1,\
 1, 1, 0)
DeclareVariable("dCAC_HalfBridgeAverage.switch4.resistor.R", "Resistance at temperature T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareParameter("dCAC_HalfBridgeAverage.switch4.resistor.T_ref", \
"Reference temperature [K|degC]", 91, 300.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("dCAC_HalfBridgeAverage.switch4.resistor.alpha", \
"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 92, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("dCAC_HalfBridgeAverage.switch4.resistor.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dCAC_HalfBridgeAverage.switch4.resistor.i", "Current flowing from pin p to pin n [A]",\
 "inductor1.i", -1, 5, 103, 0)
DeclareAlias2("dCAC_HalfBridgeAverage.switch4.resistor.p.v", "Potential at the pin [V]",\
 "dCAC_HalfBridgeAverage.switch4.signalCurrent.p.v", 1, 5, 220, 4)
DeclareAlias2("dCAC_HalfBridgeAverage.switch4.resistor.p.i", "Current flowing into the pin [A]",\
 "inductor1.i", -1, 5, 103, 132)
DeclareAlias2("dCAC_HalfBridgeAverage.switch4.resistor.n.v", "Potential at the pin [V]",\
 "inductor1.n.v", 1, 5, 105, 4)
DeclareAlias2("dCAC_HalfBridgeAverage.switch4.resistor.n.i", "Current flowing into the pin [A]",\
 "inductor1.i", 1, 5, 103, 132)
DeclareVariable("dCAC_HalfBridgeAverage.switch4.resistor.useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("dCAC_HalfBridgeAverage.switch4.resistor.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("dCAC_HalfBridgeAverage.switch4.resistor.LossPower", \
"Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dCAC_HalfBridgeAverage.switch4.resistor.T_heatPort", \
"Temperature of heatPort [K|degC]", "dCAC_HalfBridgeAverage.switch4.resistor.T", 1,\
 5, 233, 0)
DeclareVariable("dCAC_HalfBridgeAverage.switch4.resistor.R_actual", \
"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]", 0.0, 0.0,0.0,0.0,\
0,513)
DeclareAlias2("dCAC_HalfBridgeAverage.DutyCycle", "", "modulatedSignalController.y", 1,\
 5, 149, 0)
DeclareAlias2("dCAC_HalfBridgeAverage.current", "[A]", "simpleMotor.inductor.i", 1,\
 1, 1, 0)
DeclareAlias2("dCAC_HalfBridgeAverage.signalVoltage.p.v", "Potential at the pin [V]",\
 "simpleMotor.p1.v", 1, 5, 123, 4)
DeclareAlias2("dCAC_HalfBridgeAverage.signalVoltage.p.i", "Current flowing into the pin [A]",\
 "simpleMotor.inductor.i", -1, 1, 1, 132)
DeclareVariable("dCAC_HalfBridgeAverage.signalVoltage.n.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("dCAC_HalfBridgeAverage.signalVoltage.n.i", "Current flowing into the pin [A]",\
 "simpleMotor.inductor.i", 1, 1, 1, 132)
DeclareAlias2("dCAC_HalfBridgeAverage.signalVoltage.v", "Voltage between pin p and n (= p.v - n.v) as input signal [V]",\
 "simpleMotor.p1.v", 1, 5, 123, 0)
DeclareAlias2("dCAC_HalfBridgeAverage.signalVoltage.i", "Current flowing from pin p to pin n [A]",\
 "simpleMotor.inductor.i", -1, 1, 1, 0)
DeclareParameter("dCAC_HalfBridgeAverage.plant.R", "Resistance of external network",\
 93, 0.005, 0.0,0.0,0.0,0,560)
DeclareParameter("dCAC_HalfBridgeAverage.plant.L", "Inductance of external network",\
 94, 0.00069, 0.0,0.0,0.0,0,560)
DeclareParameter("dCAC_HalfBridgeAverage.plant.ron", "Resistance of the switch ON state [Ohm]",\
 95, 0.00088, 0.0,0.0,0.0,0,560)
DeclareParameter("dCAC_HalfBridgeAverage.plant.lambda", "Closed-loop time constant",\
 96, 0.005, 0.0,0.0,0.0,0,560)
DeclareParameter("dCAC_HalfBridgeAverage.plant.Vd", "DC side voltage of the converter",\
 97, 1200, 0.0,0.0,0.0,0,560)
DeclareVariable("dCAC_HalfBridgeAverage.product2.u1", "Connector of Real input signal 1",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dCAC_HalfBridgeAverage.product2.u2", "Connector of Real input signal 2",\
 "dCAC_HalfBridgeAverage.const5.k", 1, 5, 238, 0)
DeclareAlias2("dCAC_HalfBridgeAverage.product2.y", "Connector of Real output signal [V]",\
 "simpleMotor.p1.v", 1, 5, 123, 0)
DeclareVariable("dCAC_HalfBridgeAverage.const5.k", "Constant output value", 1, \
0.0,0.0,0.0,0,513)
DeclareAlias2("dCAC_HalfBridgeAverage.const5.y", "Connector of Real output signal",\
 "dCAC_HalfBridgeAverage.const5.k", 1, 5, 238, 0)
DeclareVariable("dCAC_HalfBridgeAverage.add.u1", "Connector of Real input signal 1",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dCAC_HalfBridgeAverage.add.u2", "Connector of Real input signal 2",\
 "dCAC_HalfBridgeAverage.const.k", 1, 7, 101, 0)
DeclareAlias2("dCAC_HalfBridgeAverage.add.y", "Connector of Real output signal",\
 "dCAC_HalfBridgeAverage.product2.u1", 1, 5, 237, 0)
DeclareParameter("dCAC_HalfBridgeAverage.add.k1", "Gain of input signal 1", 98, 1,\
 0.0,0.0,0.0,0,560)
DeclareParameter("dCAC_HalfBridgeAverage.add.k2", "Gain of input signal 2", 99, -1,\
 0.0,0.0,0.0,0,560)
DeclareParameter("dCAC_HalfBridgeAverage.gain2.k", "Gain value multiplied with input signal [1]",\
 100, 2, 0.0,0.0,0.0,0,560)
DeclareAlias2("dCAC_HalfBridgeAverage.gain2.u", "Input signal connector", \
"modulatedSignalController.y", 1, 5, 149, 0)
DeclareAlias2("dCAC_HalfBridgeAverage.gain2.y", "Output signal connector", \
"dCAC_HalfBridgeAverage.add.u1", 1, 5, 239, 0)
DeclareParameter("dCAC_HalfBridgeAverage.const.k", "Constant output value", 101,\
 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("dCAC_HalfBridgeAverage.const.y", "Connector of Real output signal",\
 "dCAC_HalfBridgeAverage.const.k", 1, 7, 101, 0)
DeclareAlias2("dCAC_HalfBridgeAverage.pin1.v", "Potential at the pin [V]", \
"inductor.n.v", 1, 5, 59, 4)
DeclareAlias2("dCAC_HalfBridgeAverage.pin1.i", "Current flowing into the pin [A]",\
 "inductor.i", 1, 5, 57, 132)
DeclareAlias2("dCAC_HalfBridgeAverage.pin_n1.v", "Potential at the pin [V]", \
"inductor1.n.v", 1, 5, 105, 4)
DeclareAlias2("dCAC_HalfBridgeAverage.pin_n1.i", "Current flowing into the pin [A]",\
 "inductor1.i", 1, 5, 103, 132)
DeclareVariable("dCAC_HalfBridgeAverage.ground1.p.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("dCAC_HalfBridgeAverage.ground1.p.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
}
StartDataBlock
StartPreBlock
preWD(DYNX(W_,33),"dcdc.andCondition_p.y", false, 0);
preWD(DYNX(W_,42),"dcdc.transistor.off", true, 1);
pre(DYNX(W_,80),"pwm.sawtooth.count", 0, 2);
pre(DYNX(W_,73),"pwm.zeroOrderHold.ySample", 0, 3);
pre(DYNX(W_,101),"pwm1.sawtooth.count", 0, 4);
pre(DYNX(W_,94),"pwm1.zeroOrderHold.ySample", 0, 5);
EndPreBlock
StartEqBlock
DoRememAcc_(DYNX(W_,53), 0, 5);
DoRemember_(DYNX(W_,43), 0, 3);
DoRemember_(DYNX(F_,3), 0.0, 1);
DoRemember_(DYNX(F_,1), 0.0, 2);
DoRemember_(DYNX(F_,0), 0.0, 4);
DoRemember_(DYNX(W_,117), 0.0, 0);
EndEqBlock
UpdateQEvaluate(3)
UpdateSampleCounters(2)
EndDataBlock

BreakSectionFunctionStart(0);
BreakSectionFunctionCallNew(1);
BreakSectionFunctionEnd()
