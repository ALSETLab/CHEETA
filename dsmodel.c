#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model CHEETA.Examples.CHEETAElectricalSystem.SingleBranch_3Phase
 Dymola Version 2020 (64-bit), 2019-04-10 translated this at Tue Mar 10 14:14:20 2020

   */

#include <matrixop.h>
#if defined(DynSimStruct) || defined(BUILDFMU)
static double DymArrays8[3]={0.0, 0.0, 0.0};
static double DymArrays0[3]={1.0, 1.0, 3.0};
static double DymArrays4[3]={293.15, 293.15, 293.15};
static double DymArrays7[4]={0.0, 0.0, 0.0, 0.0};
static double DymArrays1[4]={1.0, 1.0, 3.0, 3.0};
static double DymArrays2[4]={3.0, 3.0, 3.0, 3.0};
static double DymArrays6[5]={1.0, 1.0, 3.0, 3.0, 3.0};
static double DymArrays3[6]={1.0, 1.0, 1.0, 1.0, 1.0, 1.0};
static double DymArrays5[12]={0.6666666666666666, -0.33333333333333315, 
  -0.3333333333333336, 0.0, 0.5773502691896257, -0.5773502691896255, 1.0, 0.0, 
  -0.4999999999999998, 0.8660254037844387, -0.5000000000000004, -0.8660254037844384};
#endif
/* Declaration of C-structs */
/* Prototypes for functions used in model */
DYMOLA_STATIC double   Electrification_Batteries_Core_Capacity_Functions_arrayCapacity
  (RealArray   Qx_0modules, int  ms0_0, int  mp0_0);
DYMOLA_STATIC double   Electrification_Batteries_Core_OCV_Functions_AverageArrayOCV
  (RealArray   OCVx_0modules, int  ms0_0, int  mp0_0);
DYMOLA_STATIC double   Electrification_Batteries_Utilities_Functions_CurrentAtMaximumPower
  (RealArray   ocv0_0, RealArray   R0_0, int  ms0_0, int  mp0_0);
DYMOLA_STATIC double   Modelica_Electrical_Machines_SpacePhasors_Functions_activePower
  (RealArray   v0_0, RealArray   i0_0);
/* Codes used in model */
DYMOLA_STATIC double   Electrification_Batteries_Core_Capacity_Functions_arrayCapacity
  (RealArray   Qx_0modules, int  ms0_0, int  mp0_0) {
  PushContext("Electrification.Batteries.Core.Capacity.Functions.arrayCapacity")
  {
    /* Declare outputs and temporaries */
    double   Qx_0total;
    RealArray    Qx_0strings;
    MarkObject retmark_ = PushMark();
    Qx_0total=0;
    Qx_0strings=RealTemporary( 1, mp0_0);
    PushMark();
    RealFillAssign( Qx_0strings, 0);
    /* Start of real code */
      {
        int end_ = mp0_0;
        int xp0_0_0;
        for(xp0_0_0 = 1;xp0_0_0 <= end_;xp0_0_0 += 1) {
          SetRealVectorElement(Realmin( RealGetSub( Qx_0modules ,Colon  ,
             Index, (Integer)(xp0_0_0) , EndMark)), Qx_0strings, (SizeType)(
            xp0_0_0));
          Release();
        }
      }
      Qx_0total = Realsum( Qx_0strings);
      Release();
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return Qx_0total;
  }}
DYMOLA_STATIC double   Electrification_Batteries_Core_OCV_Functions_AverageArrayOCV
  (RealArray   OCVx_0modules, int  ms0_0, int  mp0_0) {
  PushContext("Electrification.Batteries.Core.OCV.Functions.AverageArrayOCV")
  {
    /* Declare outputs and temporaries */
    double   OCVx_0total;
    RealArray    OCVx_0strings;
    MarkObject retmark_ = PushMark();
    OCVx_0total=0;
    OCVx_0strings=RealTemporary( 1, mp0_0);
    PushMark();
    RealFillAssign( OCVx_0strings, 0);
    /* Start of real code */
      {
        int end_ = mp0_0;
        int xp0_0_0;
        for(xp0_0_0 = 1;xp0_0_0 <= end_;xp0_0_0 += 1) {
          SetRealVectorElement(Realsum( RealGetSub( OCVx_0modules ,Colon  ,
             Index, (Integer)(xp0_0_0) , EndMark)), OCVx_0strings, (SizeType)(
            xp0_0_0));
          Release();
        }
      }
      OCVx_0total = divGuarded(Realsum( OCVx_0strings),"sum(OCV_strings)",mp0_0,
        "mp");
      Release();
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return OCVx_0total;
  }}
DYMOLA_STATIC double   Electrification_Batteries_Utilities_Functions_CurrentAtMaximumPower
  (RealArray   ocv0_0, RealArray   R0_0, int  ms0_0, int  mp0_0) {
  PushContext("Electrification.Batteries.Utilities.Functions.CurrentAtMaximumPower")
  AssertModelica(DYNSizeSimple(R0_0,1)==ms0_0,"size(R, 1) == ms","Dimension check of input to function failed");
  AssertModelica(DYNSizeSimple(R0_0,2)==mp0_0,"size(R, 2) == mp","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    double   iMax0_0;
    double   vSer0_0;
    double   RSer0_0;
    MarkObject retmark_ = PushMark();
    iMax0_0=0;
    vSer0_0=0;
    RSer0_0=0;
    /* Start of real code */
      iMax0_0 = 0;
      {
        int end_ = mp0_0;
        int xp0_0_0;
        for(xp0_0_0 = 1;xp0_0_0 <= end_;xp0_0_0 += 1) {
          vSer0_0 = Realsum( RealGetSub( ocv0_0 ,Colon  , Index, (Integer)(
            xp0_0_0) , EndMark));
          Release();
          RSer0_0 = Realsum( RealGetSub( R0_0 ,Colon  , Index, (Integer)(xp0_0_0)
             , EndMark));
          Release();
          iMax0_0 = iMax0_0+divGuarded(vSer0_0,"vSer",RealBmax(RSer0_0, 1E-60),
            "max(RSer, 1E-60)")/(double)(2);
        }
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return iMax0_0;
  }}
DYMOLA_STATIC double   Modelica_Electrical_Machines_SpacePhasors_Functions_activePower
  (RealArray   v0_0, RealArray   i0_0) {
  PushContext("Modelica.Electrical.Machines.SpacePhasors.Functions.activePower")
  {
    /* Declare outputs and temporaries */
    double   p0_0;
    int   m0_0;
    RealArray    vx_0;
    RealArray    ix_0;
    MarkObject retmark_ = PushMark();
    p0_0=0;
    m0_0 = 3;
    vx_0=RealTemporary( 1, 2);
    PushMark();
    RealFillAssign( vx_0, 0);
    ix_0=RealTemporary( 1, 2);
    PushMark();
    RealFillAssign( ix_0, 0);
    AssertModelica(DYNSizeSimple(v0_0,1)==m0_0,"size(v, 1) == m","Dimension check of input to function failed");
    AssertModelica(DYNSizeSimple(i0_0,1)==m0_0,"size(i, 1) == m","Dimension check of input to function failed");
    /* Start of real code */
      RealFillAssign (vx_0, 0);
      Release();
      RealFillAssign (ix_0, 0);
      Release();
      {
        int end_ = m0_0;
        int k0_0_0;
        for(k0_0_0 = 1;k0_0_0 <= end_;k0_0_0 += 1) {
          RealAssign (vx_0, RealAdd (vx_0,RealScale (RealScale (RealScalarArray 
            ( 2, cos(divGuarded(k0_0_0-1,"k-1",m0_0,"m")*2*3.141592653589793), 
            sin(divGuarded(k0_0_0-1,"k-1",m0_0,"m")*2*3.141592653589793)),
            divGuarded(2,"2",m0_0,"m")),RealElement( v0_0, (SizeType)(k0_0_0)))));
          Release();
          RealAssign (ix_0, RealAdd (ix_0,RealScale (RealScale (RealScalarArray 
            ( 2, cos(divGuarded(k0_0_0-1,"k-1",m0_0,"m")*2*3.141592653589793), 
            sin(divGuarded(k0_0_0-1,"k-1",m0_0,"m")*2*3.141592653589793)),
            divGuarded(2,"2",m0_0,"m")),RealElement( i0_0, (SizeType)(k0_0_0)))));
          Release();
        }
      }
      p0_0 = m0_0/(double)(2)*(RealVectorElement( vx_0, (SizeType)(1))*
        RealVectorElement( ix_0, (SizeType)(1))+RealVectorElement( vx_0, 
        (SizeType)(2))*RealVectorElement( ix_0, (SizeType)(2)));
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return p0_0;
  }}
/* DSblock C-code: */

BreakSectionFunctionDef(1)
BreakSectionFunctionDef(0)
BreakSectionFunctionDef(2)
BreakSectionFunctionDef(3)
BreakSectionFunctionDef(4)
BreakSectionFunctionDef(5)
BreakSectionFunctionDef(6)
BreakSectionFunctionDef(7)
BreakSectionFunctionDef(8)
BreakSectionFunctionDef(9)
BreakSectionFunctionDef(10)
BreakSectionFunctionDef(11)
BreakSectionFunctionDef(12)
BreakSectionFunctionDef(13)
BreakSectionFunctionDef(14)
BreakSectionFunctionDef(15)
#define NX_    24
#define NX2_   12
#define NU_    0
#define NY_    0
#define NW_    2700
#define NP_    373
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   0
#define MAXAuxStr_   20
#define MAXAuxStrLen_   500
#define NHash1_ -1607129387
#define NHash2_ 1487872282
#define NHash3_ 0
#define NI_    0
#define NRelF_ 100
#define NRel_  103
#define NTim_  18
#define NSamp_ 12
#define NCons_ 0
#define NA_    1859
#define SizePre_ 62
#define SizeEq_ 75
#define SizeDelay_ 0
#define QNLmax_ 1
#define MAXAux 60
#define NrDymolaTimers_ 0
#define NWhen_ 47
#define NCheckIf_ 0
#define NGlobalHelp_ 2042
#define NGlobalHelpI_ 168
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="CHEETA.Examples.CHEETAElectricalSystem.SingleBranch_3Phase";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/cps_r/appdata/roaming/dassaultsystemes/dymola/dymola.lic";
#define QJacobianCGDef_ 1
DYMOLA_STATIC int QJacobianCG_[34]={7 , 8 , 1 , 6 , 8 , 13 , 15 , 16 , 18 , 23
   , 3 , 2 , 9 , 19 , 3 , 3 , 10 , 20 , 3 , 4 , 11 , 21 , 3 , 5 , 12 , 22 , 3 , 7
   , 14 , 24 , 1 , 17 , 0 , 0};
DYMOLA_STATIC int QJacobianGC_[169]={
1 , 1 , 1 , 1 , 0 , 0 , 1 , 8 , 8 , 8 , 8 , 0 , 0 , 8 , 0 , 16 , 8 , 18 , 18 , 18
   , 18 , 0 , 0 , 18 , 2 , 2 , 2 , 2 , 0 , 0 , 2 , 9 , 9 , 9 , 9 , 0 , 0 , 9 , 0
   , 0 , 9 , 19 , 19 , 19 , 19 , 0 , 0 , 19 , 3 , 3 , 3 , 3 , 0 , 0 , 3 , 10 , 10
   , 10 , 10 , 0 , 0 , 10 , 0 , 0 , 0 , 20 , 20 , 20 , 20 , 0 , 0 , 20 , 4 , 4
   , 4 , 4 , 0 , 0 , 4 , 11 , 11 , 11 , 11 , 0 , 0 , 11 , 0 , 0 , 0 , 21 , 21 , 21
   , 21 , 0 , 0 , 21 , 5 , 5 , 5 , 5 , 0 , 0 , 5 , 12 , 12 , 12 , 12 , 0 , 0 , 12
   , 0 , 0 , 12 , 22 , 22 , 22 , 22 , 0 , 0 , 22 , 7 , 7 , 7 , 7 , 7 , 7 , 0 , 14
   , 14 , 14 , 14 , 14 , 14 , 0 , 0 , 0 , 0 , 24 , 24 , 24 , 24 , 24 , 24 , 0 , 0
   , 0 , 0 , 0 , 0 , 0 , 0 , 17 , 17 , 17 , 17 , 0 , 0 , 0 , 0 , 0 , 17 , 0 , 0
   , 0 , 0 , 0 , 0 , 0 , 0};
DYMOLA_STATIC double QJacobianCD_[25]={0  , 44 , 50 , 54 , 56 , 56 , 99 , 60 , 121
   , 120 , 117 , 112 , 105 , 176 , 102 , 198 , 209 , 100 , 231 , 220 , 207 , 192
   , 175 , 286 , 162};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,0) = 3;
DYNX(W_,5) = false;
DYNX(W_,17) = false;
DYNX(W_,23) = true;
DYNX(W_,24) = 3;
DYNX(W_,28) = true;
DYNX(W_,30) = 3;
DYNX(W_,42) = 3;
DYNX(W_,53) = false;
DYNX(W_,57) = 3;
DYNX(W_,64) = 3;
DYNX(W_,65) = 3;
DYNX(W_,75) = 3;
DYNX(W_,76) = false;
DYNX(W_,87) = false;
DYNX(W_,91) = 1;
DYNX(W_,92) = 1;
DYNX(W_,97) = false;
DYNX(W_,101) = 1;
DYNX(W_,102) = 1;
DYNX(W_,107) = false;
memcpy(&DYNX(W_,111), &DymArrays0, sizeof(double)*3);
DYNX(W_,120) = 3;
DYNX(W_,121) = 3;
DYNX(W_,131) = 3;
DYNX(W_,132) = false;
DYNX(W_,140) = false;
DYNX(W_,144) = 1;
DYNX(W_,145) = 1;
DYNX(W_,150) = false;
DYNX(W_,154) = 1;
DYNX(W_,155) = 1;
DYNX(W_,160) = false;
memcpy(&DYNX(W_,164), &DymArrays1, sizeof(double)*4);
DYNX(W_,171) = 3;
DYNX(W_,178) = 3;
DYNX(W_,179) = 3;
DYNX(W_,189) = 3;
DYNX(W_,190) = false;
DYNX(W_,201) = false;
DYNX(W_,205) = 1;
DYNX(W_,206) = 1;
DYNX(W_,211) = false;
DYNX(W_,215) = 1;
DYNX(W_,216) = 1;
DYNX(W_,221) = false;
memcpy(&DYNX(W_,225), &DymArrays0, sizeof(double)*3);
DYNX(W_,234) = 3;
DYNX(W_,235) = 3;
DYNX(W_,245) = 3;
DYNX(W_,246) = false;
DYNX(W_,254) = false;
DYNX(W_,258) = 1;
DYNX(W_,259) = 1;
DYNX(W_,264) = false;
DYNX(W_,268) = 1;
DYNX(W_,269) = 1;
DYNX(W_,274) = false;
memcpy(&DYNX(W_,278), &DymArrays1, sizeof(double)*4);
DYNX(W_,290) = false;
DYNX(W_,294) = true;
DYNX(W_,295) = 1;
DYNX(W_,296) = true;
DYNX(W_,298) = 1;
DYNX(W_,308) = false;
DYNX(W_,312) = 1;
DYNX(W_,313) = 1;
DYNX(W_,318) = false;
DYNX(W_,322) = 1;
DYNX(W_,323) = 1;
DYNX(W_,324) = true;
DYNX(W_,345) = 3;
DYNX(W_,354) = false;
DYNX(W_,356) = false;
DYNX(W_,367) = 3;
DYNX(W_,371) = 3;
DYNX(W_,387) = true;
DYNX(W_,424) = 3;
DYNX(W_,425) = 3;
DYNX(W_,427) = 3;
DYNX(W_,431) = 3;
DYNX(W_,432) = 3;
DYNX(W_,445) = 3;
DYNX(W_,446) = true;
DYNX(W_,454) = true;
DYNX(W_,462) = true;
DYNX(W_,470) = true;
DYNX(W_,501) = true;
DYNX(W_,509) = 3;
DYNX(W_,526) = 3;
DYNX(W_,527) = 3;
DYNX(W_,532) = 3;
DYNX(W_,536) = 3;
DYNX(W_,537) = 3;
DYNX(W_,547) = true;
DYNX(W_,552) = 3;
DYNX(W_,553) = false;
DYNX(W_,554) = 293.15;
DYNX(W_,561) = 3;
DYNX(W_,583) = 3;
DYNX(W_,587) = 3.141592653589793;
DYNX(W_,588) = 3;
DYNX(W_,639) = true;
DYNX(W_,642) = 3;
#endif
DYNSetAuxString(did_, "Y", 0);
#if defined(DynSimStruct) || defined(BUILDFMU)
memcpy(&DYNX(W_,643), &DymArrays2, sizeof(double)*4);
DYNX(W_,648) = 3;
DYNX(W_,672) = 3;
DYNX(W_,674) = false;
DYNX(W_,693) = false;
DYNX(W_,712) = false;
DYNX(W_,741) = 3;
DYNX(W_,742) = true;
DYNX(W_,743) = 3;
DYNX(W_,747) = true;
DYNX(W_,749) = 3;
DYNX(W_,759) = 3;
DYNX(W_,770) = false;
DYNX(W_,774) = 3;
DYNX(W_,781) = 3;
DYNX(W_,782) = 3;
DYNX(W_,792) = 3;
DYNX(W_,793) = false;
DYNX(W_,804) = false;
DYNX(W_,808) = 1;
DYNX(W_,809) = 1;
DYNX(W_,814) = false;
DYNX(W_,818) = 1;
DYNX(W_,819) = 1;
DYNX(W_,824) = false;
memcpy(&DYNX(W_,828), &DymArrays0, sizeof(double)*3);
DYNX(W_,837) = 3;
DYNX(W_,838) = 3;
DYNX(W_,848) = 3;
DYNX(W_,849) = false;
DYNX(W_,857) = false;
DYNX(W_,861) = 1;
DYNX(W_,862) = 1;
DYNX(W_,867) = false;
DYNX(W_,871) = 1;
DYNX(W_,872) = 1;
DYNX(W_,877) = false;
memcpy(&DYNX(W_,881), &DymArrays1, sizeof(double)*4);
DYNX(W_,888) = 3;
DYNX(W_,895) = 3;
DYNX(W_,896) = 3;
DYNX(W_,906) = 3;
DYNX(W_,907) = false;
DYNX(W_,918) = false;
DYNX(W_,922) = 1;
DYNX(W_,923) = 1;
DYNX(W_,928) = false;
DYNX(W_,932) = 1;
DYNX(W_,933) = 1;
DYNX(W_,938) = false;
memcpy(&DYNX(W_,942), &DymArrays0, sizeof(double)*3);
DYNX(W_,951) = 3;
DYNX(W_,952) = 3;
DYNX(W_,962) = 3;
DYNX(W_,963) = false;
DYNX(W_,971) = false;
DYNX(W_,975) = 1;
DYNX(W_,976) = 1;
DYNX(W_,981) = false;
DYNX(W_,985) = 1;
DYNX(W_,986) = 1;
DYNX(W_,991) = false;
memcpy(&DYNX(W_,995), &DymArrays1, sizeof(double)*4);
DYNX(W_,1011) = false;
DYNX(W_,1015) = true;
DYNX(W_,1016) = 1;
DYNX(W_,1017) = true;
DYNX(W_,1019) = 1;
DYNX(W_,1028) = false;
DYNX(W_,1032) = 1;
DYNX(W_,1033) = 1;
DYNX(W_,1038) = false;
DYNX(W_,1042) = 1;
DYNX(W_,1043) = 1;
DYNX(W_,1044) = true;
DYNX(W_,1065) = 3;
DYNX(W_,1074) = false;
DYNX(W_,1076) = false;
DYNX(W_,1087) = 3;
DYNX(W_,1091) = 3;
DYNX(W_,1107) = true;
DYNX(W_,1144) = 3;
DYNX(W_,1145) = 3;
DYNX(W_,1147) = 3;
DYNX(W_,1151) = 3;
DYNX(W_,1152) = 3;
DYNX(W_,1165) = 3;
DYNX(W_,1166) = true;
DYNX(W_,1174) = true;
DYNX(W_,1182) = true;
DYNX(W_,1190) = true;
DYNX(W_,1221) = true;
DYNX(W_,1229) = 3;
DYNX(W_,1246) = 3;
DYNX(W_,1247) = 3;
DYNX(W_,1252) = 3;
DYNX(W_,1256) = 3;
DYNX(W_,1257) = 3;
DYNX(W_,1267) = true;
DYNX(W_,1272) = 3;
DYNX(W_,1273) = false;
DYNX(W_,1274) = 293.15;
DYNX(W_,1281) = 3;
DYNX(W_,1303) = 3;
DYNX(W_,1307) = 3.141592653589793;
DYNX(W_,1308) = 3;
DYNX(W_,1359) = true;
DYNX(W_,1362) = 3;
#endif
DYNSetAuxString(did_, "Y", 1);
#if defined(DynSimStruct) || defined(BUILDFMU)
memcpy(&DYNX(W_,1363), &DymArrays2, sizeof(double)*4);
DYNX(W_,1368) = 3;
DYNX(W_,1392) = 3;
DYNX(W_,1394) = false;
DYNX(W_,1413) = false;
DYNX(W_,1432) = false;
DYNX(W_,1461) = 3;
DYNX(W_,1468) = false;
DYNX(W_,1469) = true;
DYNX(W_,1473) = 1;
DYNX(W_,1474) = 1;
DYNX(W_,1477) = 1;
DYNX(W_,1478) = true;
DYNX(W_,1479) = false;
DYNX(W_,1531) = true;
DYNX(W_,1578) = true;
DYNX(W_,1613) = true;
DYNX(W_,1645) = true;
DYNX(W_,1657) = true;
DYNX(W_,1672) = true;
DYNX(W_,1689) = true;
DYNX(W_,1714) = true;
DYNX(W_,1743) = true;
DYNX(W_,1776) = 1;
DYNX(W_,1777) = 1;
DYNX(W_,1780) = false;
DYNX(W_,1781) = false;
DYNX(W_,1782) = false;
DYNX(W_,1783) = false;
DYNX(W_,1791) = false;
memcpy(&DYNX(W_,1792), &DymArrays3, sizeof(double)*6);
DYNX(W_,1809) = 1;
DYNX(W_,1810) = 1;
DYNX(W_,1829) = false;
DYNX(W_,1830) = false;
DYNX(W_,1832) = false;
#endif
BreakSectionFunctionCallNew(0);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(1);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,1836) = 1;
DYNX(W_,1837) = 1;
DYNX(W_,1840) = true;
DYNX(W_,1841) = true;
DYNX(W_,1842) = true;
DYNX(W_,1859) = false;
DYNX(W_,1870) = false;
DYNX(W_,1876) = false;
DYNX(W_,1882) = 1;
DYNX(W_,1883) = 1;
DYNX(W_,1887) = false;
DYNX(W_,1893) = 1;
DYNX(W_,1894) = 1;
DYNX(W_,1903) = false;
DYNX(W_,1909) = 1;
DYNX(W_,1910) = 1;
DYNX(W_,1914) = false;
DYNX(W_,1920) = 1;
DYNX(W_,1921) = 1;
DYNX(W_,1928) = false;
DYNX(W_,1940) = false;
DYNX(W_,1946) = true;
DYNX(W_,1947) = 3;
DYNX(W_,1951) = true;
DYNX(W_,1953) = 3;
DYNX(W_,1965) = 3;
DYNX(W_,1976) = false;
DYNX(W_,1980) = 3;
DYNX(W_,1987) = 3;
DYNX(W_,1988) = 3;
DYNX(W_,1998) = 3;
DYNX(W_,1999) = false;
DYNX(W_,2010) = false;
DYNX(W_,2014) = 1;
DYNX(W_,2015) = 1;
DYNX(W_,2020) = false;
DYNX(W_,2024) = 1;
DYNX(W_,2025) = 1;
DYNX(W_,2030) = false;
memcpy(&DYNX(W_,2034), &DymArrays0, sizeof(double)*3);
DYNX(W_,2043) = 3;
DYNX(W_,2044) = 3;
DYNX(W_,2054) = 3;
DYNX(W_,2055) = false;
DYNX(W_,2063) = false;
DYNX(W_,2067) = 1;
DYNX(W_,2068) = 1;
DYNX(W_,2073) = false;
DYNX(W_,2077) = 1;
DYNX(W_,2078) = 1;
DYNX(W_,2083) = false;
memcpy(&DYNX(W_,2087), &DymArrays1, sizeof(double)*4);
DYNX(W_,2094) = 3;
DYNX(W_,2101) = 3;
DYNX(W_,2102) = 3;
DYNX(W_,2112) = 3;
DYNX(W_,2113) = false;
DYNX(W_,2124) = false;
DYNX(W_,2128) = 1;
DYNX(W_,2129) = 1;
DYNX(W_,2134) = false;
DYNX(W_,2138) = 1;
DYNX(W_,2139) = 1;
DYNX(W_,2144) = false;
memcpy(&DYNX(W_,2148), &DymArrays0, sizeof(double)*3);
DYNX(W_,2157) = 3;
DYNX(W_,2158) = 3;
DYNX(W_,2168) = 3;
DYNX(W_,2169) = false;
DYNX(W_,2177) = false;
DYNX(W_,2181) = 1;
DYNX(W_,2182) = 1;
DYNX(W_,2187) = false;
DYNX(W_,2191) = 1;
DYNX(W_,2192) = 1;
DYNX(W_,2197) = false;
memcpy(&DYNX(W_,2201), &DymArrays1, sizeof(double)*4);
DYNX(W_,2213) = false;
DYNX(W_,2217) = true;
DYNX(W_,2218) = 1;
DYNX(W_,2219) = true;
DYNX(W_,2221) = 1;
DYNX(W_,2231) = false;
DYNX(W_,2235) = 1;
DYNX(W_,2236) = 1;
DYNX(W_,2241) = false;
DYNX(W_,2245) = 1;
DYNX(W_,2246) = 1;
DYNX(W_,2247) = true;
DYNX(W_,2268) = 3;
DYNX(W_,2277) = false;
DYNX(W_,2279) = false;
DYNX(W_,2290) = 3;
DYNX(W_,2294) = 3;
DYNX(W_,2310) = true;
DYNX(W_,2347) = 3;
DYNX(W_,2348) = 3;
DYNX(W_,2350) = 3;
DYNX(W_,2354) = 3;
DYNX(W_,2355) = 3;
DYNX(W_,2368) = 3;
DYNX(W_,2369) = true;
DYNX(W_,2377) = true;
DYNX(W_,2385) = true;
DYNX(W_,2393) = true;
DYNX(W_,2424) = true;
DYNX(W_,2432) = 3;
DYNX(W_,2449) = 3;
DYNX(W_,2450) = 3;
DYNX(W_,2455) = 3;
DYNX(W_,2459) = 3;
DYNX(W_,2460) = 3;
DYNX(W_,2470) = true;
DYNX(W_,2475) = 3;
DYNX(W_,2476) = false;
DYNX(W_,2477) = 293.15;
DYNX(W_,2484) = 3;
DYNX(W_,2506) = 3;
DYNX(W_,2510) = 3.141592653589793;
DYNX(W_,2511) = 3;
DYNX(W_,2562) = true;
DYNX(W_,2565) = 3;
#endif
DYNSetAuxString(did_, "Y", 19);
#if defined(DynSimStruct) || defined(BUILDFMU)
memcpy(&DYNX(W_,2566), &DymArrays2, sizeof(double)*4);
DYNX(W_,2571) = 3;
DYNX(W_,2595) = 3;
DYNX(W_,2597) = false;
DYNX(W_,2616) = false;
DYNX(W_,2635) = false;
DYNX(W_,2664) = 3;
DYNX(W_,2666) = false;
DYNX(W_,2671) = false;
DYNX(W_,32) = 3;
DYNX(W_,54) = 293.15;
memcpy(&DYNX(W_,77), &DymArrays4, sizeof(double)*3);
memcpy(&DYNX(W_,133), &DymArrays4, sizeof(double)*3);
memcpy(&DYNX(W_,191), &DymArrays4, sizeof(double)*3);
memcpy(&DYNX(W_,247), &DymArrays4, sizeof(double)*3);
DYNX(W_,291) = 293.15;
DYNX(W_,300) = 1;
DYNX(W_,327) = false;
DYNX(W_,328) = 2;
DYNX(W_,329) = true;
DYNX(W_,338) = 1;
DYNX(W_,340) = -1;
DYNX(W_,341) = 0;
DYNX(W_,658) = 0.001;
DYNX(W_,361) = 0.001;
DYNX(W_,384) = 0.001;
DYNX(W_,651) = 3;
DYNX(W_,661) = 3;
DYNX(W_,392) = 3;
DYNX(W_,664) = 0;
DYNX(W_,396) = 0.0;
DYNX(W_,492) = 3;
DYNX(W_,496) = 0.0;
DYNX(W_,499) = 3;
DYNX(W_,500) = 1;
DYNX(W_,510) = 1;
memcpy(&DYNX(W_,514), &DymArrays5, sizeof(double)*12);
DYNX(W_,570) = 293.15;
DYNX(W_,573) = 293.15;
DYNX(W_,576) = 293.15;
DYNX(W_,579) = 293.15;
DYNX(W_,602) = 3;
DYNX(W_,627) = 0.0;
DYNX(W_,628) = 0.0;
DYNX(W_,675) = false;
DYNX(W_,676) = 2;
DYNX(W_,677) = true;
DYNX(W_,686) = 1;
DYNX(W_,688) = -1;
DYNX(W_,689) = 0;
DYNX(W_,694) = false;
DYNX(W_,695) = 2;
DYNX(W_,696) = true;
DYNX(W_,705) = 1;
DYNX(W_,707) = -1;
DYNX(W_,708) = 0;
DYNX(W_,713) = false;
DYNX(W_,714) = 2;
DYNX(W_,715) = true;
DYNX(W_,724) = 1;
DYNX(W_,726) = -1;
DYNX(W_,727) = 0;
DYNX(W_,734) = 2;
DYNX(W_,751) = 3;
DYNX(W_,771) = 293.15;
memcpy(&DYNX(W_,794), &DymArrays4, sizeof(double)*3);
memcpy(&DYNX(W_,850), &DymArrays4, sizeof(double)*3);
memcpy(&DYNX(W_,908), &DymArrays4, sizeof(double)*3);
memcpy(&DYNX(W_,964), &DymArrays4, sizeof(double)*3);
DYNX(W_,1012) = 293.15;
DYNX(W_,1021) = 1;
DYNX(W_,1047) = false;
DYNX(W_,1048) = 2;
DYNX(W_,1049) = true;
DYNX(W_,1058) = 1;
DYNX(W_,1060) = -1;
DYNX(W_,1061) = 0;
DYNX(W_,1378) = 0.001;
DYNX(W_,1081) = 0.001;
DYNX(W_,1104) = 0.001;
DYNX(W_,1371) = 3;
DYNX(W_,1381) = 3;
DYNX(W_,1112) = 3;
DYNX(W_,1384) = 0;
DYNX(W_,1116) = 0.0;
DYNX(W_,1212) = 3;
DYNX(W_,1216) = 0.0;
DYNX(W_,1219) = 3;
DYNX(W_,1220) = 1;
DYNX(W_,1230) = 1;
memcpy(&DYNX(W_,1234), &DymArrays5, sizeof(double)*12);
DYNX(W_,1290) = 293.15;
DYNX(W_,1293) = 293.15;
DYNX(W_,1296) = 293.15;
DYNX(W_,1299) = 293.15;
DYNX(W_,1322) = 3;
DYNX(W_,1347) = 0.0;
DYNX(W_,1348) = 0.0;
DYNX(W_,1395) = false;
DYNX(W_,1396) = 2;
DYNX(W_,1397) = true;
DYNX(W_,1406) = 1;
DYNX(W_,1408) = -1;
DYNX(W_,1409) = 0;
DYNX(W_,1414) = false;
DYNX(W_,1415) = 2;
DYNX(W_,1416) = true;
DYNX(W_,1425) = 1;
DYNX(W_,1427) = -1;
DYNX(W_,1428) = 0;
DYNX(W_,1433) = false;
DYNX(W_,1434) = 2;
DYNX(W_,1435) = true;
DYNX(W_,1444) = 1;
DYNX(W_,1446) = -1;
DYNX(W_,1447) = 0;
DYNX(W_,1454) = 2;
DYNX(W_,1528) = 1;
DYNX(W_,1570) = 1;
DYNX(W_,1490) = 1;
DYNX(W_,1491) = 1;
DYNX(W_,1518) = 1;
DYNX(W_,1519) = 1;
#endif
DYNSetAuxString(did_, "", 13);
DYNSetAuxString(did_, "", 2);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,1527) = 1;
DYNX(W_,1549) = 1;
#endif
BreakSectionFunctionEnd()
BreakSectionFunctionStart(2);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,1550) = 1;
DYNX(W_,1569) = 1;
#endif
DYNSetAuxString(did_, "", 3);
DYNSetAuxString(did_, "State of Charge (SoC)", 4);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,1609) = 1;
DYNX(W_,1610) = 1;
#endif
DYNSetAuxString(did_, "The OCV model is outside of its' valid range", 5);
DYNSetAuxString(did_, "Battery cell OCV", 6);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,1641) = 1;
DYNX(W_,1642) = 1;
DYNX(W_,1668) = 1;
DYNX(W_,1669) = 1;
DYNX(W_,1685) = 1;
DYNX(W_,1686) = 1;
#endif
DYNSetAuxString(did_, "This may be caused by too high current.", 7);
DYNSetAuxString(did_, "Battery cell voltage", 8);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,1710) = 1;
DYNX(W_,1711) = 1;
#endif
DYNSetAuxString(did_, "", 9);
DYNSetAuxString(did_, "Cell current", 10);
DYNSetAuxString(did_, "", 11);
DYNSetAuxString(did_, "Cell power", 12);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,1787) = 1;
DYNX(W_,1788) = 1;
DYNX(W_,1798) = 1;
DYNX(W_,1799) = 1;
#endif
DYNSetAuxString(did_, "", 14);
DYNSetAuxString(did_, "", 15);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,1815) = 1;
DYNX(W_,1816) = 1;
#endif
DYNSetAuxString(did_, "", 16);
DYNSetAuxString(did_, "The battery current has passed the limit of maximum discharge power. This typically results in a large voltage drop and failure to deliver power.",
   17);
DYNSetAuxString(did_, "Battery discharge current", 18);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,1877) = 293.15;
DYNX(W_,1888) = 293.15;
DYNX(W_,1904) = 293.15;
DYNX(W_,1915) = 293.15;
DYNX(W_,1955) = 3;
DYNX(W_,1977) = 293.15;
memcpy(&DYNX(W_,2000), &DymArrays4, sizeof(double)*3);
memcpy(&DYNX(W_,2056), &DymArrays4, sizeof(double)*3);
memcpy(&DYNX(W_,2114), &DymArrays4, sizeof(double)*3);
memcpy(&DYNX(W_,2170), &DymArrays4, sizeof(double)*3);
DYNX(W_,2214) = 293.15;
DYNX(W_,2223) = 1;
DYNX(W_,2250) = false;
DYNX(W_,2251) = 2;
DYNX(W_,2252) = true;
DYNX(W_,2261) = 1;
DYNX(W_,2263) = -1;
DYNX(W_,2264) = 0;
DYNX(W_,2581) = 0.001;
DYNX(W_,2284) = 0.001;
DYNX(W_,2307) = 0.001;
DYNX(W_,2574) = 3;
DYNX(W_,2584) = 3;
DYNX(W_,2315) = 3;
DYNX(W_,2587) = 0;
DYNX(W_,2319) = 0.0;
DYNX(W_,2415) = 3;
DYNX(W_,2419) = 0.0;
DYNX(W_,2422) = 3;
DYNX(W_,2423) = 1;
DYNX(W_,2433) = 1;
memcpy(&DYNX(W_,2437), &DymArrays5, sizeof(double)*12);
DYNX(W_,2493) = 293.15;
DYNX(W_,2496) = 293.15;
DYNX(W_,2499) = 293.15;
DYNX(W_,2502) = 293.15;
DYNX(W_,2525) = 3;
DYNX(W_,2550) = 0.0;
DYNX(W_,2551) = 0.0;
DYNX(W_,2598) = false;
DYNX(W_,2599) = 2;
DYNX(W_,2600) = true;
DYNX(W_,2609) = 1;
DYNX(W_,2611) = -1;
DYNX(W_,2612) = 0;
DYNX(W_,2617) = false;
DYNX(W_,2618) = 2;
DYNX(W_,2619) = true;
DYNX(W_,2628) = 1;
DYNX(W_,2630) = -1;
DYNX(W_,2631) = 0;
DYNX(W_,2636) = false;
DYNX(W_,2637) = 2;
DYNX(W_,2638) = true;
DYNX(W_,2647) = 1;
DYNX(W_,2649) = -1;
DYNX(W_,2650) = 0;
DYNX(W_,2657) = 2;
DYNX(W_,655) = 0;
DYNX(W_,662) = 0;
DYNX(W_,667) = 0;
DYNX(W_,1375) = 0;
DYNX(W_,1382) = 0;
DYNX(W_,1387) = 0;
DYNX(W_,1481) = false;
memcpy(&DYNX(W_,1483), &DymArrays6, sizeof(double)*5);
DYNX(W_,1574) = true;
DYNX(W_,1575) = false;
DYNX(W_,1617) = 1;
DYNX(W_,2578) = 0;
DYNX(W_,2585) = 0;
DYNX(W_,2590) = 0;
DYNX(W_,376) = 0;
DYNX(W_,2) = 0;
DYNX(W_,489) = 0;
DYNX(W_,538) = 0;
DYNX(W_,736) = 0;
DYNX(W_,372) = 0.0;
DYNX(W_,374) = 0.0;
DYNX(W_,373) = 0.0;
DYNX(W_,1096) = 0;
DYNX(W_,1004) = 0;
DYNX(W_,1209) = 0;
DYNX(W_,1258) = 0;
DYNX(W_,1456) = 0;
DYNX(W_,1092) = 0.0;
DYNX(W_,1094) = 0.0;
DYNX(W_,1093) = 0.0;
DYNX(W_,1660) = 0.0;
DYNX(W_,1744) = 0;
DYNX(W_,1693) = 0;
DYNX(W_,1698) = 0;
DYNX(W_,1691) = 0.0;
DYNX(W_,1588) = 0;
DYNX(W_,1724) = 0;
DYNX(W_,1631) = 0;
DYNX(W_,1634) = 0;
DYNX(W_,1620) = 0.0;
DYNX(W_,1513) = 0.0;
DYNX(W_,1653) = 0.0;
DYNX(W_,1680) = 0;
DYNX(W_,1564) = 0;
DYNX(W_,1471) = 0;
DYNX(W_,1565) = 0.0;
DYNX(W_,1606) = 0.0;
DYNX(W_,1725) = 0.0;
DYNX(W_,1734) = 0.0;
DYNX(W_,1843) = 0.0;
DYNX(W_,1845) = -1E+60;
DYNX(W_,2299) = 0;
DYNX(W_,2412) = 0;
DYNX(W_,2461) = 0;
DYNX(W_,2659) = 0;
DYNX(W_,2295) = 0.0;
DYNX(W_,2297) = 0.0;
DYNX(W_,2296) = 0.0;
DYNX(W_,368) = 0.0;
DYNX(W_,406) = 0.0;
memcpy(&DYNX(W_,410), &DymArrays7, sizeof(double)*4);
DYNX(W_,507) = 0;
DYNX(W_,557) = 0.0;
DYNX(W_,559) = 0.0;
DYNX(W_,560) = 0.0;
DYNX(W_,1007) = 0.0;
DYNX(W_,1088) = 0.0;
DYNX(W_,1126) = 0.0;
memcpy(&DYNX(W_,1130), &DymArrays7, sizeof(double)*4);
DYNX(W_,1227) = 0;
DYNX(W_,1277) = 0.0;
DYNX(W_,1279) = 0.0;
DYNX(W_,1280) = 0.0;
DYNX(W_,1482) = 300;
DYNX(W_,1495) = 0.0;
DYNX(W_,1496) = 0.0;
DYNX(W_,1500) = 0.0;
DYNX(W_,1501) = 0.0;
DYNX(W_,1559) = 0.0;
DYNX(W_,1650) = 0.0;
DYNX(W_,1720) = 0.0;
DYNX(W_,1752) = 0.0;
DYNX(W_,1754) = 0.0;
DYNX(W_,1771) = 0.0;
DYNX(W_,1772) = 0.0;
DYNX(W_,1925) = 0;
DYNX(W_,2291) = 0.0;
DYNX(W_,2329) = 0.0;
memcpy(&DYNX(W_,2333), &DymArrays7, sizeof(double)*4);
DYNX(W_,2430) = 0;
DYNX(W_,2480) = 0.0;
DYNX(W_,2482) = 0.0;
DYNX(W_,2483) = 0.0;
DYNX(W_,1509) = 0.0;
DYNX(W_,1558) = 0.0;
DYNX(W_,419) = 0.0;
DYNX(W_,484) = 0.0;
DYNX(W_,1139) = 0.0;
DYNX(W_,1204) = 0.0;
DYNX(W_,2342) = 0.0;
DYNX(W_,2407) = 0.0;
DYNX(W_,418) = 0.0;
DYNX(W_,1138) = 0.0;
DYNX(W_,2341) = 0.0;
DYNX(W_,1589) = 0.0;
DYNX(W_,1695) = 0.0;
DYNX(W_,2686) = 0.0;
DYNX(W_,2687) = 0.0;
memcpy(&DYNX(W_,2690), &DymArrays7, sizeof(double)*4);
DYNX(W_,1534) = 300.0;
DYNX(W_,1694) = 0.0;
DYNX(W_,1692) = 0.0;
DYNX(W_,1696) = 0.0;
DYNX(W_,1697) = 0.0;
DYNX(W_,1682) = 0.0;
DYNX(W_,1681) = 0.0;
DYNX(W_,1596) = 0.0;
DYNX(W_,1590) = 0.0;
DYNX(W_,1566) = 0.0;
DYNX(W_,1605) = 0.0;
DYNX(W_,1648) = 0.0;
DYNX(W_,1647) = 0.0;
DYNX(W_,1649) = 0.0;
DYNX(W_,1638) = 0.0;
DYNX(W_,1637) = 0.0;
DYNX(W_,1659) = 0.0;
DYNX(W_,1654) = 0.0;
DYNX(W_,1656) = 0.0;
DYNX(W_,1655) = 0.0;
DYNX(W_,1636) = 0.0;
DYNX(W_,1545) = 0.0;
DYNX(W_,1544) = 0.0;
DYNX(W_,1546) = 0.0;
DYNX(W_,1675) = 0.0;
DYNX(W_,1674) = 0.0;
DYNX(W_,1676) = 0.0;
DYNX(W_,1679) = 0.0;
DYNX(W_,1678) = 0.0;
DYNX(W_,1677) = 0.0;
DYNX(W_,1665) = 0.0;
DYNX(W_,1664) = 0.0;
DYNX(W_,1663) = 0.0;
DYNX(W_,1716) = 0.0;
DYNX(W_,1723) = 0.0;
DYNX(W_,1722) = 0.0;
DYNX(W_,1715) = 0.0;
DYNX(W_,1717) = 0.0;
DYNX(W_,2678) = 0.0;
DYNX(W_,2677) = 0.0;
DYNX(W_,2688) = 0.0;
DYNX(W_,2689) = 0.0;
DYNX(W_,1556) = 0.0;
DYNX(W_,1553) = 0.0;
DYNX(W_,1555) = 0.0;
DYNX(W_,1554) = 0.0;
DYNX(W_,1621) = 0.0;
DYNX(W_,1616) = 300.0;
DYNX(W_,1756) = 0.0;
DYNX(W_,1755) = 0.0;
#endif
BreakSectionFunctionEnd()
BreakSectionFunctionStart(3);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,1746) = 0.0;
DYNX(W_,1745) = 0.0;
DYNX(W_,1773) = 0.0;
DYNX(W_,1767) = 0.0;
DYNX(W_,1766) = 0.0;
DYNX(W_,1768) = 0.0;
DYNX(W_,1759) = 0.0;
DYNX(W_,1758) = 0.0;
DYNX(W_,1757) = 0.0;
memcpy(&DYNX(W_,1748), &DymArrays8, sizeof(double)*3);
DYNX(W_,1747) = 0.0;
DYNX(W_,1751) = 0.0;
DYNX(W_,1753) = 0.0;
memcpy(&DYNX(W_,2679), &DymArrays7, sizeof(double)*4);
memcpy(&DYNX(W_,2694), &DymArrays7, sizeof(double)*4);
DYNX(W_,1765) = 0.0;
DYNX(W_,1764) = 0.0;
DYNX(W_,1763) = 0.0;
DYNX(W_,1762) = 0.0;
DYNX(W_,1761) = 0.0;
DYNX(W_,1760) = 0.0;
DYNX(W_,1770) = 0.0;
DYNX(W_,1769) = 0.0;
DYNX(W_,1472) = 0.0;
DYNX(W_,1470) = 0.0;
DYNX(W_,1507) = 0.0;
DYNX(W_,1494) = 0.0;
DYNX(W_,1497) = 0.0;
DYNX(W_,1498) = 0.0;
DYNX(W_,2683) = 0.0;
DYNX(W_,1803) = 0.0;
DYNX(W_,2684) = 0.0;
DYNX(W_,1806) = 0.0;
DYNX(W_,1823) = 0.0;
DYNX(W_,1825) = 0.0;
DYNX(W_,1826) = 0.0;
DYNX(W_,1784) = 0.0;
DYNX(W_,1879) = 293.15;
DYNX(W_,1896) = 0.0;
DYNX(W_,1895) = 0.0;
DYNX(W_,1898) = 0.0;
DYNX(W_,1897) = 0.0;
DYNX(W_,1901) = 0.0;
DYNX(W_,1890) = 293.15;
DYNX(W_,1886) = 0.0;
DYNX(W_,1906) = 293.15;
DYNX(W_,1917) = 293.15;
DYNX(W_,293) = 293.15;
DYNX(W_,1014) = 293.15;
DYNX(W_,1009) = 0.0;
DYNX(W_,1003) = 0.0;
DYNX(W_,1006) = 0.0;
DYNX(W_,1024) = 0.0;
DYNX(W_,2216) = 293.15;
DYNX(W_,486) = 0.0;
DYNX(W_,1206) = 0.0;
DYNX(W_,2409) = 0.0;
DYNX(W_,739) = 0.0;
DYNX(W_,1459) = 0.0;
DYNX(W_,2662) = 0.0;
DYNX(W_,1852) = 0.0;
DYNX(W_,773) = 293.15;
DYNX(W_,56) = 293.15;
DYNX(W_,1979) = 293.15;
DYNX(W_,12) = 0.0;
DYNX(W_,13) = 0.0;
DYNX(W_,1935) = 0.0;
DYNX(W_,1936) = 0.0;
DYNX(W_,1467) = 0.0;
DYNX(W_,1466) = 0.0;
DYNX(W_,1465) = 0.0;
DYNX(W_,1464) = 0.0;
DYNX(W_,1463) = 0.0;
DYNX(W_,1462) = 0.0;
DYNX(W_,389) = 0.0;
DYNX(W_,388) = 293.15;
DYNX(W_,390) = 0.0;
DYNX(W_,377) = 0.0;
DYNX(W_,379) = 0.0;
DYNX(W_,375) = 0.0;
DYNX(W_,369) = 0.0;
DYNX(W_,391) = 0.0;
DYNX(W_,599) = 0.0;
DYNX(W_,598) = 293.15;
DYNX(W_,595) = 0.0;
DYNX(W_,594) = 293.15;
DYNX(W_,600) = 0.0;
DYNX(W_,593) = 0.0;
DYNX(W_,592) = 293.15;
memcpy(&DYNX(W_,589), &DymArrays8, sizeof(double)*3);
DYNX(W_,597) = 0.0;
DYNX(W_,596) = 293.15;
DYNX(W_,485) = 0.0;
DYNX(W_,490) = 0.0;
DYNX(W_,488) = 0.0;
DYNX(W_,487) = 0.0;
DYNX(W_,531) = 0.0;
DYNX(W_,530) = 0.0;
DYNX(W_,529) = 0.0;
DYNX(W_,528) = 0.0;
DYNX(W_,503) = 0.0;
DYNX(W_,502) = 293.15;
memcpy(&DYNX(W_,504), &DymArrays8, sizeof(double)*3);
DYNX(W_,549) = 0.0;
DYNX(W_,548) = 293.15;
DYNX(W_,550) = 0.0;
DYNX(W_,539) = 0.0;
DYNX(W_,541) = 0.0;
memcpy(&DYNX(W_,533), &DymArrays8, sizeof(double)*3);
DYNX(W_,558) = 0.0;
DYNX(W_,581) = 0.0;
DYNX(W_,580) = 293.15;
DYNX(W_,575) = 0.0;
DYNX(W_,574) = 293.15;
DYNX(W_,572) = 0.0;
DYNX(W_,571) = 293.15;
DYNX(W_,578) = 0.0;
DYNX(W_,577) = 293.15;
DYNX(W_,569) = 0.0;
DYNX(W_,568) = 293.15;
DYNX(W_,565) = 0.0;
DYNX(W_,564) = 293.15;
DYNX(W_,563) = 0.0;
DYNX(W_,562) = 293.15;
DYNX(W_,567) = 0.0;
DYNX(W_,566) = 293.15;
DYNX(W_,647) = 0.0;
DYNX(W_,649) = 0.0;
DYNX(W_,1109) = 0.0;
DYNX(W_,1108) = 293.15;
DYNX(W_,1110) = 0.0;
DYNX(W_,1097) = 0.0;
DYNX(W_,1099) = 0.0;
DYNX(W_,1095) = 0.0;
DYNX(W_,1089) = 0.0;
DYNX(W_,1111) = 0.0;
DYNX(W_,1319) = 0.0;
DYNX(W_,1318) = 293.15;
DYNX(W_,1315) = 0.0;
DYNX(W_,1314) = 293.15;
DYNX(W_,1320) = 0.0;
DYNX(W_,1313) = 0.0;
DYNX(W_,1312) = 293.15;
memcpy(&DYNX(W_,1309), &DymArrays8, sizeof(double)*3);
DYNX(W_,1317) = 0.0;
DYNX(W_,1316) = 293.15;
DYNX(W_,1205) = 0.0;
DYNX(W_,1210) = 0.0;
DYNX(W_,1208) = 0.0;
DYNX(W_,1207) = 0.0;
DYNX(W_,1251) = 0.0;
DYNX(W_,1250) = 0.0;
DYNX(W_,1249) = 0.0;
DYNX(W_,1248) = 0.0;
DYNX(W_,1223) = 0.0;
DYNX(W_,1222) = 293.15;
memcpy(&DYNX(W_,1224), &DymArrays8, sizeof(double)*3);
DYNX(W_,1269) = 0.0;
DYNX(W_,1268) = 293.15;
DYNX(W_,1270) = 0.0;
DYNX(W_,1259) = 0.0;
DYNX(W_,1261) = 0.0;
memcpy(&DYNX(W_,1253), &DymArrays8, sizeof(double)*3);
DYNX(W_,1278) = 0.0;
DYNX(W_,1301) = 0.0;
DYNX(W_,1300) = 293.15;
DYNX(W_,1295) = 0.0;
DYNX(W_,1294) = 293.15;
DYNX(W_,1292) = 0.0;
DYNX(W_,1291) = 293.15;
DYNX(W_,1298) = 0.0;
DYNX(W_,1297) = 293.15;
DYNX(W_,1289) = 0.0;
DYNX(W_,1288) = 293.15;
DYNX(W_,1285) = 0.0;
DYNX(W_,1284) = 293.15;
DYNX(W_,1283) = 0.0;
DYNX(W_,1282) = 293.15;
DYNX(W_,1287) = 0.0;
DYNX(W_,1286) = 293.15;
DYNX(W_,1367) = 0.0;
DYNX(W_,1369) = 0.0;
DYNX(W_,2312) = 0.0;
DYNX(W_,2311) = 293.15;
DYNX(W_,2313) = 0.0;
DYNX(W_,2300) = 0.0;
DYNX(W_,2302) = 0.0;
DYNX(W_,2298) = 0.0;
DYNX(W_,2292) = 0.0;
DYNX(W_,2314) = 0.0;
DYNX(W_,2522) = 0.0;
DYNX(W_,2521) = 293.15;
DYNX(W_,2518) = 0.0;
DYNX(W_,2517) = 293.15;
DYNX(W_,2523) = 0.0;
DYNX(W_,2516) = 0.0;
DYNX(W_,2515) = 293.15;
memcpy(&DYNX(W_,2512), &DymArrays8, sizeof(double)*3);
DYNX(W_,2520) = 0.0;
DYNX(W_,2519) = 293.15;
DYNX(W_,2408) = 0.0;
DYNX(W_,2413) = 0.0;
DYNX(W_,2411) = 0.0;
DYNX(W_,2410) = 0.0;
DYNX(W_,2454) = 0.0;
DYNX(W_,2453) = 0.0;
DYNX(W_,2452) = 0.0;
DYNX(W_,2451) = 0.0;
DYNX(W_,2426) = 0.0;
DYNX(W_,2425) = 293.15;
memcpy(&DYNX(W_,2427), &DymArrays8, sizeof(double)*3);
DYNX(W_,2472) = 0.0;
DYNX(W_,2471) = 293.15;
DYNX(W_,2473) = 0.0;
DYNX(W_,2462) = 0.0;
DYNX(W_,2464) = 0.0;
memcpy(&DYNX(W_,2456), &DymArrays8, sizeof(double)*3);
DYNX(W_,2481) = 0.0;
DYNX(W_,2504) = 0.0;
DYNX(W_,2503) = 293.15;
DYNX(W_,2498) = 0.0;
DYNX(W_,2497) = 293.15;
DYNX(W_,2495) = 0.0;
DYNX(W_,2494) = 293.15;
DYNX(W_,2501) = 0.0;
DYNX(W_,2500) = 293.15;
DYNX(W_,2492) = 0.0;
DYNX(W_,2491) = 293.15;
DYNX(W_,2488) = 0.0;
DYNX(W_,2487) = 293.15;
DYNX(W_,2486) = 0.0;
DYNX(W_,2485) = 293.15;
DYNX(W_,2490) = 0.0;
DYNX(W_,2489) = 293.15;
DYNX(W_,2570) = 0.0;
DYNX(W_,2572) = 0.0;
DYNX(W_,731) = 0.0;
DYNX(W_,1451) = 0.0;
DYNX(W_,2654) = 0.0;
DYNX(W_,1005) = 0.0;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
AssertModelica(DYNX(DP_,39) >= DYNX(DP_,40),"signalPWM2.limiter.uMax >= signalPWM2.limiter.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(DP_,39), true, 0)),") < uMin (="),Real2String2(DYNX(DP_,40),
   true, 0)),")"));
PopAllMarks();
AssertModelica(DYNX(DP_,63) >= DYNX(DP_,64),"signalPWM[1].limiter.uMax >= signalPWM[1].limiter.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(DP_,63), true, 0)),") < uMin (="),Real2String2(DYNX(DP_,64),
   true, 0)),")"));
PopAllMarks();
AssertModelica(DYNX(DP_,68) >= DYNX(DP_,69),"signalPWM[2].limiter.uMax >= signalPWM[2].limiter.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(DP_,68), true, 0)),") < uMin (="),Real2String2(DYNX(DP_,69),
   true, 0)),")"));
PopAllMarks();
AssertModelica(DYNX(DP_,73) >= DYNX(DP_,74),"signalPWM[3].limiter.uMax >= signalPWM[3].limiter.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(DP_,73), true, 0)),") < uMin (="),Real2String2(DYNX(DP_,74),
   true, 0)),")"));
PopAllMarks();
AssertModelica(DYNX(DP_,113) >= DYNX(DP_,114),"signalPWM1.limiter.uMax >= signalPWM1.limiter.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(DP_,113), true, 0)),") < uMin (="),Real2String2(
  DYNX(DP_,114), true, 0)),")"));
PopAllMarks();
AssertModelica(DYNX(DP_,137) >= DYNX(DP_,138),"signalPWM3[1].limiter.uMax >= signalPWM3[1].limiter.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(DP_,137), true, 0)),") < uMin (="),Real2String2(
  DYNX(DP_,138), true, 0)),")"));
PopAllMarks();
AssertModelica(DYNX(DP_,142) >= DYNX(DP_,143),"signalPWM3[2].limiter.uMax >= signalPWM3[2].limiter.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(DP_,142), true, 0)),") < uMin (="),Real2String2(
  DYNX(DP_,143), true, 0)),")"));
PopAllMarks();
AssertModelica(DYNX(DP_,147) >= DYNX(DP_,148),"signalPWM3[3].limiter.uMax >= signalPWM3[3].limiter.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(DP_,147), true, 0)),") < uMin (="),Real2String2(
  DYNX(DP_,148), true, 0)),")"));
PopAllMarks();
AssertModelica(DYNX(DP_,159) >= 1,"batteryPack.ns >= 1", "The number of grouped cells in series, gs, must be less than or equal to the actual number of cells in series, ns.");
AssertModelica(real2integer(modulusDymola(DYNX(DP_,159), 1)) == 0,
  "mod(batteryPack.ns, 1) == 0", "The actual number of cells in series, ns, must be an even multiple of the number of grouped cells in series, gs.");
AssertModelica(DYNX(DP_,209) >= 0 AND DYNX(DP_,209) <= 1,"batteryPack.core.aging.calendar.const.k >= 0 and batteryPack.core.aging.calendar.const.k <= 1",
   "Capacity aging factor should be in the range 0-1.");
AssertModelica(DYNX(DP_,209) >= 0,"batteryPack.core.aging.calendar.const.k >= 0",
   "Serial resistance aging factor should be >0");
AssertModelica(DYNX(DP_,209) >= 0,"batteryPack.core.aging.calendar.const.k >= 0",
   "Dynamic resistance aging factor should be >0");
AssertModelica(DYNX(DP_,209) >= 0,"batteryPack.core.aging.calendar.const.k >= 0",
   "Dynamic capacitance aging factor should be >0");
AssertModelica(DYNX(DP_,210) >= 0 AND DYNX(DP_,210) <= 1,"batteryPack.core.aging.cyclic.const.k >= 0 and batteryPack.core.aging.cyclic.const.k <= 1",
   "Capacity aging factor should be in the range 0-1.");
AssertModelica(DYNX(DP_,210) >= 0,"batteryPack.core.aging.cyclic.const.k >= 0", 
  "Serial resistance aging factor should be >0");
AssertModelica(DYNX(DP_,210) >= 0,"batteryPack.core.aging.cyclic.const.k >= 0", 
  "Dynamic resistance aging factor should be >0");
AssertModelica(DYNX(DP_,210) >= 0,"batteryPack.core.aging.cyclic.const.k >= 0", 
  "Dynamic capacitance aging factor should be >0");
AssertModelica(DYNX(DP_,312) >= DYNX(DP_,313),"signalPWM4.limiter.uMax >= signalPWM4.limiter.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(DP_,312), true, 0)),") < uMin (="),Real2String2(
  DYNX(DP_,313), true, 0)),")"));
PopAllMarks();
AssertModelica(DYNX(DP_,336) >= DYNX(DP_,337),"signalPWM5[1].limiter.uMax >= signalPWM5[1].limiter.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(DP_,336), true, 0)),") < uMin (="),Real2String2(
  DYNX(DP_,337), true, 0)),")"));
PopAllMarks();
AssertModelica(DYNX(DP_,341) >= DYNX(DP_,342),"signalPWM5[2].limiter.uMax >= signalPWM5[2].limiter.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(DP_,341), true, 0)),") < uMin (="),Real2String2(
  DYNX(DP_,342), true, 0)),")"));
PopAllMarks();
AssertModelica(DYNX(DP_,346) >= DYNX(DP_,347),"signalPWM5[3].limiter.uMax >= signalPWM5[3].limiter.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(DP_,346), true, 0)),") < uMin (="),Real2String2(
  DYNX(DP_,347), true, 0)),")"));
PopAllMarks();
BoundParameterSection
DYNX(W_,1) = DYNX(DP_,5)/(double)(2);
DYNX(W_,3) = DYNX(DP_,3);
DYNX(W_,6) = DYNX(DP_,1);
DYNX(W_,11) = DYNX(DP_,5)/(double)(2);
DYNX(W_,15) = DYNX(DP_,3);
DYNX(W_,18) = DYNX(DP_,6);
DYNX(W_,29) = DYNX(DP_,8);
DYNX(W_,31) = DYNX(W_,29);
DYNX(W_,66) = DYNX(DP_,9);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(4);
DYNX(W_,67) = DYNX(DP_,9);
DYNX(W_,68) = DYNX(DP_,9);
DYNX(W_,69) = DYNX(DP_,10);
DYNX(W_,70) = DYNX(DP_,10);
DYNX(W_,71) = DYNX(DP_,10);
DYNX(W_,72) = DYNX(DP_,11);
DYNX(W_,73) = DYNX(DP_,11);
DYNX(W_,74) = DYNX(DP_,11);
DYNX(W_,84) = DYNX(W_,66);
DYNX(W_,85) = DYNX(W_,69);
DYNX(W_,86) = DYNX(W_,72);
DYNX(W_,94) = DYNX(W_,67);
DYNX(W_,95) = DYNX(W_,70);
DYNX(W_,96) = DYNX(W_,73);
DYNX(W_,104) = DYNX(W_,68);
DYNX(W_,105) = DYNX(W_,71);
DYNX(W_,106) = DYNX(W_,74);
DYNX(W_,122) = DYNX(DP_,12);
DYNX(W_,123) = DYNX(DP_,12);
DYNX(W_,124) = DYNX(DP_,12);
DYNX(W_,125) = DYNX(DP_,13);
DYNX(W_,126) = DYNX(DP_,13);
DYNX(W_,127) = DYNX(DP_,13);
DYNX(W_,128) = DYNX(DP_,14);
DYNX(W_,129) = DYNX(DP_,14);
DYNX(W_,130) = DYNX(DP_,14);
DYNX(W_,137) = DYNX(W_,122);
DYNX(W_,138) = DYNX(W_,125);
DYNX(W_,139) = DYNX(W_,128);
DYNX(W_,147) = DYNX(W_,123);
DYNX(W_,148) = DYNX(W_,126);
DYNX(W_,149) = DYNX(W_,129);
DYNX(W_,157) = DYNX(W_,124);
DYNX(W_,158) = DYNX(W_,127);
DYNX(W_,159) = DYNX(W_,130);
DYNX(W_,180) = DYNX(DP_,9);
DYNX(W_,181) = DYNX(DP_,9);
DYNX(W_,182) = DYNX(DP_,9);
DYNX(W_,183) = DYNX(DP_,10);
DYNX(W_,184) = DYNX(DP_,10);
DYNX(W_,185) = DYNX(DP_,10);
DYNX(W_,186) = DYNX(DP_,11);
DYNX(W_,187) = DYNX(DP_,11);
DYNX(W_,188) = DYNX(DP_,11);
DYNX(W_,198) = DYNX(W_,180);
DYNX(W_,199) = DYNX(W_,183);
DYNX(W_,200) = DYNX(W_,186);
DYNX(W_,208) = DYNX(W_,181);
DYNX(W_,209) = DYNX(W_,184);
DYNX(W_,210) = DYNX(W_,187);
DYNX(W_,218) = DYNX(W_,182);
DYNX(W_,219) = DYNX(W_,185);
DYNX(W_,220) = DYNX(W_,188);
DYNX(W_,236) = DYNX(DP_,12);
DYNX(W_,237) = DYNX(DP_,12);
DYNX(W_,238) = DYNX(DP_,12);
DYNX(W_,239) = DYNX(DP_,13);
DYNX(W_,240) = DYNX(DP_,13);
DYNX(W_,241) = DYNX(DP_,13);
DYNX(W_,242) = DYNX(DP_,14);
DYNX(W_,243) = DYNX(DP_,14);
DYNX(W_,244) = DYNX(DP_,14);
DYNX(W_,251) = DYNX(W_,236);
DYNX(W_,252) = DYNX(W_,239);
DYNX(W_,253) = DYNX(W_,242);
DYNX(W_,261) = DYNX(W_,237);
DYNX(W_,262) = DYNX(W_,240);
DYNX(W_,263) = DYNX(W_,243);
DYNX(W_,271) = DYNX(W_,238);
DYNX(W_,272) = DYNX(W_,241);
DYNX(W_,273) = DYNX(W_,244);
DYNX(W_,297) = DYNX(DP_,33);
DYNX(W_,299) = DYNX(W_,297);
DYNX(W_,305) = DYNX(DP_,27);
DYNX(W_,306) = DYNX(DP_,28);
DYNX(W_,307) = DYNX(DP_,29);
DYNX(W_,315) = DYNX(DP_,30);
DYNX(W_,316) = DYNX(DP_,31);
DYNX(W_,317) = DYNX(DP_,32);
DYNX(W_,326) = DYNX(DP_,36);
DYNX(DYNhelp,0) = divinvGuarded(DYNX(DP_,37),"signalPWM2.f");
DYNX(W_,333) = DYNX(DYNhelp,0);
DYNX(W_,334) = DYNX(DP_,38);
DYNX(W_,339) = DYNX(DYNhelp,0);
DYNX(W_,342) = DYNX(DP_,38);
DYNX(W_,346) = DYNX(DP_,47);
DYNX(W_,347) = DYNX(DP_,48);
DYNX(W_,348) = DYNX(DP_,49);
DYNX(W_,349) = DYNX(DP_,50);
DYNX(W_,350) = DYNX(DP_,51);
DYNX(W_,654) = divGuarded(0.10177640614116878,"0.10177640614116878",
  6.283185307179586*DYNX(DP_,48),"6.283185307179586*threePhaseMotor.aimcData.fsNominal");
DYNX(W_,653) = DYNX(W_,654);
DYNX(W_,351) = DYNX(W_,653);
DYNX(W_,352) = DYNX(W_,654);
DYNX(W_,353) = DYNX(DP_,46);
DYNX(W_,652) = DYNX(DP_,46);
DYNX(W_,355) = DYNX(W_,652);
DYNX(W_,357) = DYNX(W_,655);
DYNX(DYNhelp,1) = divinvGuarded(DYNX(DP_,47),"threePhaseMotor.aimcData.p");
DYNX(W_,656) = DYNX(DYNhelp,1)*6.283185307179586*DYNX(DP_,48);
DYNX(W_,358) = DYNX(W_,656);
DYNX(W_,359) = DYNX(DP_,53);
DYNX(W_,657) = IF DYNX(W_,655) <= 0 THEN 0 ELSE divGuarded(DYNX(W_,655),
  "threePhaseMotor.aimcData.frictionParameters.PRef",DYNX(W_,656),
  "threePhaseMotor.aimcData.frictionParameters.wRef");
DYNX(W_,360) = DYNX(W_,657);
DYNX(W_,659) = DYNX(W_,658)*DYNX(W_,656);
DYNX(W_,362) = DYNX(W_,659);
DYNX(W_,660) = IF DYNX(W_,655) <= 0 THEN 0 ELSE DYNX(W_,657)*powGuarded(
  divGuarded(DYNX(W_,659),"threePhaseMotor.aimcData.frictionParameters.wLinear",
  DYNX(W_,656),"threePhaseMotor.aimcData.frictionParameters.wRef"),
  "threePhaseMotor.aimcData.frictionParameters.wLinear/threePhaseMotor.aimcData.frictionParameters.wRef",
  DYNX(DP_,53),"threePhaseMotor.aimcData.frictionParameters.power_w");
DYNX(W_,363) = DYNX(W_,660);
DYNX(W_,366) = DYNX(W_,353);
DYNX(W_,370) = DYNX(W_,355);
DYNX(W_,380) = DYNX(W_,357);
DYNX(W_,381) = DYNX(W_,358);
DYNX(W_,382) = DYNX(W_,359);
DYNX(W_,383) = DYNX(W_,360);
DYNX(W_,385) = DYNX(W_,362);
DYNX(W_,386) = DYNX(W_,363);
DYNX(W_,393) = DYNX(W_,662);
DYNX(W_,394) = DYNX(DP_,54);
DYNX(W_,663) = 6.283185307179586*DYNX(DP_,48);
DYNX(W_,395) = DYNX(W_,663);
DYNX(W_,665) = IF DYNX(W_,662) <= 0 THEN 0 ELSE divGuarded(divGuarded(
  DYNX(W_,662),"threePhaseMotor.aimcData.statorCoreParameters.PRef",sqr(
  DYNX(DP_,54)),"threePhaseMotor.aimcData.statorCoreParameters.VRef^2"),
  "threePhaseMotor.aimcData.statorCoreParameters.PRef/threePhaseMotor.aimcData.statorCoreParameters.VRef^2",
  DYNX(W_,661),"threePhaseMotor.aimcData.statorCoreParameters.m");
DYNX(W_,397) = DYNX(W_,665);
DYNX(W_,666) = 1E-06*DYNX(W_,663);
DYNX(W_,398) = DYNX(W_,666);
DYNX(W_,399) = DYNX(W_,667);
DYNX(W_,400) = DYNX(DP_,55);
DYNX(W_,668) = DYNX(DYNhelp,1)*6.283185307179586*DYNX(DP_,48);
DYNX(W_,401) = DYNX(W_,668);
DYNX(W_,402) = DYNX(DP_,56);
DYNX(W_,669) = IF DYNX(W_,667) <= 0 THEN 0 ELSE divGuarded(DYNX(W_,667),
  "threePhaseMotor.aimcData.strayLoadParameters.PRef",DYNX(W_,668),
  "threePhaseMotor.aimcData.strayLoadParameters.wRef");
DYNX(W_,403) = DYNX(W_,669);
DYNX(W_,436) = DYNX(W_,348);
DYNX(W_,437) = DYNX(W_,348);
DYNX(W_,438) = DYNX(W_,348);
DYNX(W_,439) = DYNX(W_,349);
DYNX(W_,440) = DYNX(W_,349);
DYNX(W_,441) = DYNX(W_,349);
DYNX(W_,442) = divGuarded(DYNX(W_,350),"threePhaseMotor.aimc.alpha20s",1+
  DYNX(W_,350)*(DYNX(W_,349)-293.15),"1+threePhaseMotor.aimc.alpha20s*(threePhaseMotor.aimc.TsRef-293.15)");
DYNX(W_,443) = divGuarded(DYNX(W_,350),"threePhaseMotor.aimc.alpha20s",1+
  DYNX(W_,350)*(DYNX(W_,349)-293.15),"1+threePhaseMotor.aimc.alpha20s*(threePhaseMotor.aimc.TsRef-293.15)");
DYNX(W_,444) = divGuarded(DYNX(W_,350),"threePhaseMotor.aimc.alpha20s",1+
  DYNX(W_,350)*(DYNX(W_,349)-293.15),"1+threePhaseMotor.aimc.alpha20s*(threePhaseMotor.aimc.TsRef-293.15)");
DYNX(W_,447) = DYNX(W_,349);
DYNX(W_,448) = DYNX(W_,349);
DYNX(W_,449) = DYNX(W_,349);
DYNX(W_,450) = DYNX(W_,436);
DYNX(W_,451) = DYNX(W_,439);
DYNX(W_,452) = DYNX(W_,442);
DYNX(W_,455) = DYNX(W_,451);
DYNX(W_,458) = DYNX(W_,437);
DYNX(W_,459) = DYNX(W_,440);
DYNX(W_,460) = DYNX(W_,443);
DYNX(W_,463) = DYNX(W_,459);
DYNX(W_,466) = DYNX(W_,438);
DYNX(W_,467) = DYNX(W_,441);
DYNX(W_,468) = DYNX(W_,444);
DYNX(W_,471) = DYNX(W_,467);
DYNX(W_,474) = DYNX(W_,352);
DYNX(W_,475) = DYNX(W_,352);
DYNX(W_,491) = DYNX(W_,351);
DYNX(W_,493) = DYNX(W_,393);
DYNX(W_,494) = DYNX(W_,394);
DYNX(W_,495) = DYNX(W_,395);
DYNX(W_,497) = DYNX(W_,397);
DYNX(W_,498) = DYNX(W_,398);
DYNX(W_,542) = DYNX(W_,399);
DYNX(W_,543) = DYNX(W_,400);
DYNX(W_,544) = DYNX(W_,401);
DYNX(W_,545) = DYNX(W_,402);
DYNX(W_,546) = DYNX(W_,403);
DYNX(W_,555) = DYNX(DP_,43);
DYNX(W_,582) = DYNX(W_,555);
DYNX(W_,584) = DYNX(DP_,45);
DYNX(W_,586) = DYNX(W_,584);
DYNX(W_,670) = divGuarded(2.898223593858831,"2.898223593858831",6.283185307179586
  *DYNX(DP_,48),"6.283185307179586*threePhaseMotor.aimcData.fsNominal");
DYNX(W_,630) = DYNX(W_,670);
DYNX(W_,601) = DYNX(W_,630);
DYNX(W_,603) = DYNX(W_,346);
DYNX(W_,626) = DYNX(W_,601);
DYNX(W_,629) = DYNX(W_,601);
DYNX(W_,671) = divGuarded(0.10177640614116878,"0.10177640614116878",
  6.283185307179586*DYNX(DP_,48),"6.283185307179586*threePhaseMotor.aimcData.fsNominal");
DYNX(W_,631) = DYNX(W_,671);
DYNX(W_,632) = DYNX(DP_,57);
DYNX(W_,633) = DYNX(DP_,58);
DYNX(W_,634) = DYNX(DP_,59);
DYNX(W_,635) = DYNX(W_,631);
DYNX(W_,636) = DYNX(W_,632);
DYNX(W_,637) = DYNX(W_,633);
DYNX(W_,638) = divGuarded(DYNX(W_,634),"threePhaseMotor.aimc.alpha20r",1+
  DYNX(W_,634)*(DYNX(W_,633)-293.15),"1+threePhaseMotor.aimc.alpha20r*(threePhaseMotor.aimc.TrRef-293.15)");
DYNX(W_,640) = DYNX(W_,637);
DYNX(W_,673) = 0.10471975511965977*DYNX(DP_,42);
DYNX(DYNhelp,2) = divinvGuarded(DYNX(DP_,61),"signalPWM[1].f");
DYNX(W_,681) = DYNX(DYNhelp,2);
DYNX(W_,682) = DYNX(DP_,62);
DYNX(W_,687) = DYNX(DYNhelp,2);
DYNX(W_,690) = DYNX(DP_,62);
DYNX(DYNhelp,3) = divinvGuarded(DYNX(DP_,66),"signalPWM[2].f");
DYNX(W_,700) = DYNX(DYNhelp,3);
DYNX(W_,701) = DYNX(DP_,67);
DYNX(W_,706) = DYNX(DYNhelp,3);
DYNX(W_,709) = DYNX(DP_,67);
DYNX(DYNhelp,4) = divinvGuarded(DYNX(DP_,71),"signalPWM[3].f");
DYNX(W_,719) = DYNX(DYNhelp,4);
DYNX(W_,720) = DYNX(DP_,72);
DYNX(W_,725) = DYNX(DYNhelp,4);
DYNX(W_,728) = DYNX(DP_,72);
DYNX(W_,732) = DYNX(DP_,79);
DYNX(W_,733) = DYNX(DP_,78);
DYNX(W_,738) = DYNX(DP_,77);
DYNX(W_,740) = DYNX(DP_,80);
DYNX(W_,748) = DYNX(DP_,82);
DYNX(W_,750) = DYNX(W_,748);
DYNX(W_,783) = DYNX(DP_,83);
DYNX(W_,784) = DYNX(DP_,83);
DYNX(W_,785) = DYNX(DP_,83);
DYNX(W_,786) = DYNX(DP_,84);
DYNX(W_,787) = DYNX(DP_,84);
DYNX(W_,788) = DYNX(DP_,84);
DYNX(W_,789) = DYNX(DP_,85);
DYNX(W_,790) = DYNX(DP_,85);
DYNX(W_,791) = DYNX(DP_,85);
DYNX(W_,801) = DYNX(W_,783);
DYNX(W_,802) = DYNX(W_,786);
DYNX(W_,803) = DYNX(W_,789);
DYNX(W_,811) = DYNX(W_,784);
DYNX(W_,812) = DYNX(W_,787);
DYNX(W_,813) = DYNX(W_,790);
DYNX(W_,821) = DYNX(W_,785);
DYNX(W_,822) = DYNX(W_,788);
DYNX(W_,823) = DYNX(W_,791);
DYNX(W_,839) = DYNX(DP_,86);
DYNX(W_,840) = DYNX(DP_,86);
DYNX(W_,841) = DYNX(DP_,86);
DYNX(W_,842) = DYNX(DP_,87);
DYNX(W_,843) = DYNX(DP_,87);
DYNX(W_,844) = DYNX(DP_,87);
DYNX(W_,845) = DYNX(DP_,88);
DYNX(W_,846) = DYNX(DP_,88);
DYNX(W_,847) = DYNX(DP_,88);
DYNX(W_,854) = DYNX(W_,839);
DYNX(W_,855) = DYNX(W_,842);
DYNX(W_,856) = DYNX(W_,845);
DYNX(W_,864) = DYNX(W_,840);
DYNX(W_,865) = DYNX(W_,843);
DYNX(W_,866) = DYNX(W_,846);
DYNX(W_,874) = DYNX(W_,841);
DYNX(W_,875) = DYNX(W_,844);
DYNX(W_,876) = DYNX(W_,847);
DYNX(W_,897) = DYNX(DP_,83);
DYNX(W_,898) = DYNX(DP_,83);
DYNX(W_,899) = DYNX(DP_,83);
DYNX(W_,900) = DYNX(DP_,84);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(5);
DYNX(W_,901) = DYNX(DP_,84);
DYNX(W_,902) = DYNX(DP_,84);
DYNX(W_,903) = DYNX(DP_,85);
DYNX(W_,904) = DYNX(DP_,85);
DYNX(W_,905) = DYNX(DP_,85);
DYNX(W_,915) = DYNX(W_,897);
DYNX(W_,916) = DYNX(W_,900);
DYNX(W_,917) = DYNX(W_,903);
DYNX(W_,925) = DYNX(W_,898);
DYNX(W_,926) = DYNX(W_,901);
DYNX(W_,927) = DYNX(W_,904);
DYNX(W_,935) = DYNX(W_,899);
DYNX(W_,936) = DYNX(W_,902);
DYNX(W_,937) = DYNX(W_,905);
DYNX(W_,953) = DYNX(DP_,86);
DYNX(W_,954) = DYNX(DP_,86);
DYNX(W_,955) = DYNX(DP_,86);
DYNX(W_,956) = DYNX(DP_,87);
DYNX(W_,957) = DYNX(DP_,87);
DYNX(W_,958) = DYNX(DP_,87);
DYNX(W_,959) = DYNX(DP_,88);
DYNX(W_,960) = DYNX(DP_,88);
DYNX(W_,961) = DYNX(DP_,88);
DYNX(W_,968) = DYNX(W_,953);
DYNX(W_,969) = DYNX(W_,956);
DYNX(W_,970) = DYNX(W_,959);
DYNX(W_,978) = DYNX(W_,954);
DYNX(W_,979) = DYNX(W_,957);
DYNX(W_,980) = DYNX(W_,960);
DYNX(W_,988) = DYNX(W_,955);
DYNX(W_,989) = DYNX(W_,958);
DYNX(W_,990) = DYNX(W_,961);
DYNX(W_,1018) = DYNX(DP_,107);
DYNX(W_,1020) = DYNX(W_,1018);
DYNX(W_,1025) = DYNX(DP_,101);
DYNX(W_,1026) = DYNX(DP_,102);
DYNX(W_,1027) = DYNX(DP_,103);
DYNX(W_,1035) = DYNX(DP_,104);
DYNX(W_,1036) = DYNX(DP_,105);
DYNX(W_,1037) = DYNX(DP_,106);
DYNX(W_,1046) = DYNX(DP_,110);
DYNX(DYNhelp,5) = divinvGuarded(DYNX(DP_,111),"signalPWM1.f");
DYNX(W_,1053) = DYNX(DYNhelp,5);
DYNX(W_,1054) = DYNX(DP_,112);
DYNX(W_,1059) = DYNX(DYNhelp,5);
DYNX(W_,1062) = DYNX(DP_,112);
DYNX(W_,1066) = DYNX(DP_,121);
DYNX(W_,1067) = DYNX(DP_,122);
DYNX(W_,1068) = DYNX(DP_,123);
DYNX(W_,1069) = DYNX(DP_,124);
DYNX(W_,1070) = DYNX(DP_,125);
DYNX(W_,1374) = divGuarded(0.10177640614116878,"0.10177640614116878",
  6.283185307179586*DYNX(DP_,122),"6.283185307179586*threePhaseMotor1.aimcData.fsNominal");
DYNX(W_,1373) = DYNX(W_,1374);
DYNX(W_,1071) = DYNX(W_,1373);
DYNX(W_,1072) = DYNX(W_,1374);
DYNX(W_,1073) = DYNX(DP_,120);
DYNX(W_,1372) = DYNX(DP_,120);
DYNX(W_,1075) = DYNX(W_,1372);
DYNX(W_,1077) = DYNX(W_,1375);
DYNX(DYNhelp,6) = divinvGuarded(DYNX(DP_,121),"threePhaseMotor1.aimcData.p");
DYNX(W_,1376) = DYNX(DYNhelp,6)*6.283185307179586*DYNX(DP_,122);
DYNX(W_,1078) = DYNX(W_,1376);
DYNX(W_,1079) = DYNX(DP_,127);
DYNX(W_,1377) = IF DYNX(W_,1375) <= 0 THEN 0 ELSE divGuarded(DYNX(W_,1375),
  "threePhaseMotor1.aimcData.frictionParameters.PRef",DYNX(W_,1376),
  "threePhaseMotor1.aimcData.frictionParameters.wRef");
DYNX(W_,1080) = DYNX(W_,1377);
DYNX(W_,1379) = DYNX(W_,1378)*DYNX(W_,1376);
DYNX(W_,1082) = DYNX(W_,1379);
DYNX(W_,1380) = IF DYNX(W_,1375) <= 0 THEN 0 ELSE DYNX(W_,1377)*powGuarded(
  divGuarded(DYNX(W_,1379),"threePhaseMotor1.aimcData.frictionParameters.wLinear",
  DYNX(W_,1376),"threePhaseMotor1.aimcData.frictionParameters.wRef"),
  "threePhaseMotor1.aimcData.frictionParameters.wLinear/threePhaseMotor1.aimcData.frictionParameters.wRef",
  DYNX(DP_,127),"threePhaseMotor1.aimcData.frictionParameters.power_w");
DYNX(W_,1083) = DYNX(W_,1380);
DYNX(W_,1086) = DYNX(W_,1073);
DYNX(W_,1090) = DYNX(W_,1075);
DYNX(W_,1100) = DYNX(W_,1077);
DYNX(W_,1101) = DYNX(W_,1078);
DYNX(W_,1102) = DYNX(W_,1079);
DYNX(W_,1103) = DYNX(W_,1080);
DYNX(W_,1105) = DYNX(W_,1082);
DYNX(W_,1106) = DYNX(W_,1083);
DYNX(W_,1113) = DYNX(W_,1382);
DYNX(W_,1114) = DYNX(DP_,128);
DYNX(W_,1383) = 6.283185307179586*DYNX(DP_,122);
DYNX(W_,1115) = DYNX(W_,1383);
DYNX(W_,1385) = IF DYNX(W_,1382) <= 0 THEN 0 ELSE divGuarded(divGuarded(
  DYNX(W_,1382),"threePhaseMotor1.aimcData.statorCoreParameters.PRef",sqr(
  DYNX(DP_,128)),"threePhaseMotor1.aimcData.statorCoreParameters.VRef^2"),
  "threePhaseMotor1.aimcData.statorCoreParameters.PRef/threePhaseMotor1.aimcData.statorCoreParameters.VRef^2",
  DYNX(W_,1381),"threePhaseMotor1.aimcData.statorCoreParameters.m");
DYNX(W_,1117) = DYNX(W_,1385);
DYNX(W_,1386) = 1E-06*DYNX(W_,1383);
DYNX(W_,1118) = DYNX(W_,1386);
DYNX(W_,1119) = DYNX(W_,1387);
DYNX(W_,1120) = DYNX(DP_,129);
DYNX(W_,1388) = DYNX(DYNhelp,6)*6.283185307179586*DYNX(DP_,122);
DYNX(W_,1121) = DYNX(W_,1388);
DYNX(W_,1122) = DYNX(DP_,130);
DYNX(W_,1389) = IF DYNX(W_,1387) <= 0 THEN 0 ELSE divGuarded(DYNX(W_,1387),
  "threePhaseMotor1.aimcData.strayLoadParameters.PRef",DYNX(W_,1388),
  "threePhaseMotor1.aimcData.strayLoadParameters.wRef");
DYNX(W_,1123) = DYNX(W_,1389);
DYNX(W_,1156) = DYNX(W_,1068);
DYNX(W_,1157) = DYNX(W_,1068);
DYNX(W_,1158) = DYNX(W_,1068);
DYNX(W_,1159) = DYNX(W_,1069);
DYNX(W_,1160) = DYNX(W_,1069);
DYNX(W_,1161) = DYNX(W_,1069);
DYNX(W_,1162) = divGuarded(DYNX(W_,1070),"threePhaseMotor1.aimc.alpha20s",1+
  DYNX(W_,1070)*(DYNX(W_,1069)-293.15),"1+threePhaseMotor1.aimc.alpha20s*(threePhaseMotor1.aimc.TsRef-293.15)");
DYNX(W_,1163) = divGuarded(DYNX(W_,1070),"threePhaseMotor1.aimc.alpha20s",1+
  DYNX(W_,1070)*(DYNX(W_,1069)-293.15),"1+threePhaseMotor1.aimc.alpha20s*(threePhaseMotor1.aimc.TsRef-293.15)");
DYNX(W_,1164) = divGuarded(DYNX(W_,1070),"threePhaseMotor1.aimc.alpha20s",1+
  DYNX(W_,1070)*(DYNX(W_,1069)-293.15),"1+threePhaseMotor1.aimc.alpha20s*(threePhaseMotor1.aimc.TsRef-293.15)");
DYNX(W_,1167) = DYNX(W_,1069);
DYNX(W_,1168) = DYNX(W_,1069);
DYNX(W_,1169) = DYNX(W_,1069);
DYNX(W_,1170) = DYNX(W_,1156);
DYNX(W_,1171) = DYNX(W_,1159);
DYNX(W_,1172) = DYNX(W_,1162);
DYNX(W_,1175) = DYNX(W_,1171);
DYNX(W_,1178) = DYNX(W_,1157);
DYNX(W_,1179) = DYNX(W_,1160);
DYNX(W_,1180) = DYNX(W_,1163);
DYNX(W_,1183) = DYNX(W_,1179);
DYNX(W_,1186) = DYNX(W_,1158);
DYNX(W_,1187) = DYNX(W_,1161);
DYNX(W_,1188) = DYNX(W_,1164);
DYNX(W_,1191) = DYNX(W_,1187);
DYNX(W_,1194) = DYNX(W_,1072);
DYNX(W_,1195) = DYNX(W_,1072);
DYNX(W_,1211) = DYNX(W_,1071);
DYNX(W_,1213) = DYNX(W_,1113);
DYNX(W_,1214) = DYNX(W_,1114);
DYNX(W_,1215) = DYNX(W_,1115);
DYNX(W_,1217) = DYNX(W_,1117);
DYNX(W_,1218) = DYNX(W_,1118);
DYNX(W_,1262) = DYNX(W_,1119);
DYNX(W_,1263) = DYNX(W_,1120);
DYNX(W_,1264) = DYNX(W_,1121);
DYNX(W_,1265) = DYNX(W_,1122);
DYNX(W_,1266) = DYNX(W_,1123);
DYNX(W_,1275) = DYNX(DP_,117);
DYNX(W_,1302) = DYNX(W_,1275);
DYNX(W_,1304) = DYNX(DP_,119);
DYNX(W_,1306) = DYNX(W_,1304);
DYNX(W_,1390) = divGuarded(2.898223593858831,"2.898223593858831",
  6.283185307179586*DYNX(DP_,122),"6.283185307179586*threePhaseMotor1.aimcData.fsNominal");
DYNX(W_,1350) = DYNX(W_,1390);
DYNX(W_,1321) = DYNX(W_,1350);
DYNX(W_,1323) = DYNX(W_,1066);
DYNX(W_,1346) = DYNX(W_,1321);
DYNX(W_,1349) = DYNX(W_,1321);
DYNX(W_,1391) = divGuarded(0.10177640614116878,"0.10177640614116878",
  6.283185307179586*DYNX(DP_,122),"6.283185307179586*threePhaseMotor1.aimcData.fsNominal");
DYNX(W_,1351) = DYNX(W_,1391);
DYNX(W_,1352) = DYNX(DP_,131);
DYNX(W_,1353) = DYNX(DP_,132);
DYNX(W_,1354) = DYNX(DP_,133);
DYNX(W_,1355) = DYNX(W_,1351);
DYNX(W_,1356) = DYNX(W_,1352);
DYNX(W_,1357) = DYNX(W_,1353);
DYNX(W_,1358) = divGuarded(DYNX(W_,1354),"threePhaseMotor1.aimc.alpha20r",1+
  DYNX(W_,1354)*(DYNX(W_,1353)-293.15),"1+threePhaseMotor1.aimc.alpha20r*(threePhaseMotor1.aimc.TrRef-293.15)");
DYNX(W_,1360) = DYNX(W_,1357);
DYNX(W_,1393) = 0.10471975511965977*DYNX(DP_,116);
DYNX(DYNhelp,7) = divinvGuarded(DYNX(DP_,135),"signalPWM3[1].f");
DYNX(W_,1401) = DYNX(DYNhelp,7);
DYNX(W_,1402) = DYNX(DP_,136);
DYNX(W_,1407) = DYNX(DYNhelp,7);
DYNX(W_,1410) = DYNX(DP_,136);
DYNX(DYNhelp,8) = divinvGuarded(DYNX(DP_,140),"signalPWM3[2].f");
DYNX(W_,1420) = DYNX(DYNhelp,8);
DYNX(W_,1421) = DYNX(DP_,141);
DYNX(W_,1426) = DYNX(DYNhelp,8);
DYNX(W_,1429) = DYNX(DP_,141);
DYNX(DYNhelp,9) = divinvGuarded(DYNX(DP_,145),"signalPWM3[3].f");
DYNX(W_,1439) = DYNX(DYNhelp,9);
DYNX(W_,1440) = DYNX(DP_,146);
DYNX(W_,1445) = DYNX(DYNhelp,9);
DYNX(W_,1448) = DYNX(DP_,146);
DYNX(W_,1452) = DYNX(DP_,153);
DYNX(W_,1453) = DYNX(DP_,152);
DYNX(W_,1458) = DYNX(DP_,151);
DYNX(W_,1460) = DYNX(DP_,154);
DYNX(W_,1475) = real2integer(divideDymola(DYNX(DP_,159), 1));
DYNX(W_,1476) = real2integer(divideDymola(DYNX(DP_,160), 1));
DYNX(W_,1526) = DYNX(DP_,160);
DYNX(W_,1568) = DYNX(W_,1526);
DYNX(W_,1572) = real2integer(divideDymola(DYNX(W_,1568), DYNX(W_,1570)));
DYNX(W_,1580) = DYNX(W_,1572)*DYNX(DP_,183)*DYNX(DP_,184);
DYNX(W_,1535) = DYNX(W_,1580);
DYNX(W_,1480) = DYNX(W_,1535);
DYNX(W_,1488) = DYNX(DP_,159);
DYNX(W_,1489) = DYNX(DP_,160);
DYNX(W_,1492) = real2integer(divideDymola(DYNX(W_,1488), DYNX(W_,1490)));
DYNX(W_,1493) = real2integer(divideDymola(DYNX(W_,1489), DYNX(W_,1491)));
DYNX(W_,1516) = DYNX(DP_,159);
DYNX(W_,1517) = DYNX(DP_,160);
DYNX(W_,1520) = real2integer(divideDymola(DYNX(W_,1516), DYNX(W_,1518)));
DYNX(W_,1521) = real2integer(divideDymola(DYNX(W_,1517), DYNX(W_,1519)));
DYNX(W_,1522) = DYNX(DP_,219);
DYNX(W_,1523) = DYNX(DP_,220);
DYNX(W_,1524) = DYNX(DP_,221);
DYNX(W_,1525) = DYNX(DP_,159);
DYNX(W_,1529) = real2integer(divideDymola(DYNX(W_,1525), DYNX(W_,1527)));
DYNX(W_,1530) = real2integer(divideDymola(DYNX(W_,1526), DYNX(W_,1528)));
DYNX(W_,1532) = DYNX(W_,1481);
DYNX(W_,1533) = DYNX(DP_,163);
DYNX(W_,1536) = DYNX(W_,1483);
DYNX(W_,1537) = DYNX(DP_,164);
DYNX(W_,1538) = DYNX(W_,1484);
DYNX(W_,1539) = DYNX(DP_,165);
DYNX(W_,1540) = DYNX(W_,1485);
DYNX(W_,1541) = DYNX(DP_,166);
DYNX(W_,1542) = DYNX(W_,1486);
DYNX(W_,1543) = DYNX(DP_,167);
DYNX(W_,1547) = DYNX(W_,1525);
DYNX(W_,1548) = DYNX(W_,1526);
DYNX(W_,1551) = real2integer(divideDymola(DYNX(W_,1547), DYNX(W_,1549)));
DYNX(W_,1552) = real2integer(divideDymola(DYNX(W_,1548), DYNX(W_,1550)));
DYNX(W_,1567) = DYNX(W_,1525);
DYNX(W_,1571) = real2integer(divideDymola(DYNX(W_,1567), DYNX(W_,1569)));
DYNX(W_,1573) =  NOT DYNX(W_,1532);
DYNX(W_,1576) = DYNX(W_,1533);
DYNX(W_,1577) = DYNX(W_,1580)/(double)(2);
DYNX(W_,1579) = DYNX(DP_,170);
DYNX(W_,1581) = DYNX(W_,1536);
DYNX(W_,1582) = DYNX(DP_,171);
DYNX(W_,1583) = DYNX(DP_,172);
DYNX(W_,1584) = DYNX(DP_,173);
DYNX(W_,1585) = DYNX(W_,1537);
DYNX(W_,1600) = DYNX(W_,1581);
DYNX(W_,1604) = IF DYNX(W_,1600) == 3 THEN 1 ELSE 2;
DYNX(W_,1607) = DYNX(W_,1525);
DYNX(W_,1608) = DYNX(W_,1526);
DYNX(W_,1611) = real2integer(divideDymola(DYNX(W_,1607), DYNX(W_,1609)));
DYNX(W_,1612) = real2integer(divideDymola(DYNX(W_,1608), DYNX(W_,1610)));
DYNX(W_,1614) = DYNX(DP_,170);
DYNX(W_,1615) = DYNX(W_,1532);
DYNX(W_,1625) = DYNX(W_,1617);
DYNX(W_,1626) = DYNX(DP_,191);
DYNX(W_,1630) = IF DYNX(W_,1625) == 3 THEN 1 ELSE 2;
DYNX(W_,1635) = DYNX(DP_,195)-DYNX(DP_,196);
DYNX(W_,1639) = DYNX(W_,1525);
DYNX(W_,1640) = DYNX(W_,1526);
DYNX(W_,1643) = real2integer(divideDymola(DYNX(W_,1639), DYNX(W_,1641)));
DYNX(W_,1644) = real2integer(divideDymola(DYNX(W_,1640), DYNX(W_,1642)));
DYNX(W_,1646) = DYNX(DP_,170);
DYNX(W_,1651) = DYNX(DP_,199);
DYNX(W_,1652) = DYNX(DP_,200);
DYNX(W_,1658) = DYNX(W_,1646);
DYNX(DYNhelp,10) = divinvGuarded(DYNX(W_,1644),"batteryPack.core.impedance.ngp");
DYNX(W_,1662) = DYNX(DYNhelp,10)*DYNX(DP_,198)*DYNX(DP_,197)*DYNX(W_,1643);
DYNX(W_,1666) = DYNX(W_,1525);
DYNX(W_,1667) = DYNX(W_,1526);
DYNX(W_,1670) = real2integer(divideDymola(DYNX(W_,1666), DYNX(W_,1668)));
DYNX(W_,1671) = real2integer(divideDymola(DYNX(W_,1667), DYNX(W_,1669)));
DYNX(W_,1673) = DYNX(DP_,170);
DYNX(W_,1683) = DYNX(W_,1525);
DYNX(W_,1684) = DYNX(W_,1526);
DYNX(W_,1687) = real2integer(divideDymola(DYNX(W_,1683), DYNX(W_,1685)));
DYNX(W_,1688) = real2integer(divideDymola(DYNX(W_,1684), DYNX(W_,1686)));
DYNX(W_,1690) = DYNX(DP_,170);
DYNX(W_,1702) = DYNX(W_,1538);
DYNX(W_,1703) = DYNX(W_,1539);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(6);
DYNX(W_,1707) = IF DYNX(W_,1702) == 3 THEN 1 ELSE 2;
DYNX(W_,1708) = DYNX(W_,1525);
DYNX(W_,1709) = DYNX(W_,1526);
DYNX(W_,1712) = real2integer(divideDymola(DYNX(W_,1708), DYNX(W_,1710)));
DYNX(W_,1713) = real2integer(divideDymola(DYNX(W_,1709), DYNX(W_,1711)));
DYNX(W_,1728) = DYNX(W_,1540);
DYNX(W_,1729) = DYNX(W_,1541);
DYNX(W_,1733) = IF DYNX(W_,1728) == 3 THEN 1 ELSE 2;
DYNX(W_,1737) = DYNX(W_,1542);
DYNX(W_,1738) = DYNX(W_,1543);
DYNX(W_,1742) = IF DYNX(W_,1737) == 3 THEN 1 ELSE 2;
DYNX(W_,1774) = DYNX(DP_,159);
DYNX(W_,1775) = DYNX(DP_,160);
DYNX(W_,1778) = real2integer(divideDymola(DYNX(W_,1774), 1));
DYNX(W_,1779) = real2integer(divideDymola(DYNX(W_,1775), 1));
DYNX(W_,1785) = DYNX(W_,1774);
DYNX(W_,1786) = DYNX(W_,1775);
DYNX(W_,1789) = real2integer(divideDymola(DYNX(W_,1785), DYNX(W_,1787)));
DYNX(W_,1790) = real2integer(divideDymola(DYNX(W_,1786), DYNX(W_,1788)));
DYNX(W_,1800) = real2integer(divideDymola(DYNX(DP_,222), DYNX(DP_,224)));
DYNX(W_,1801) = real2integer(divideDymola(DYNX(DP_,223), DYNX(DP_,225)));
DYNX(W_,1804) = real2integer(divideDymola(DYNX(DP_,229), DYNX(DP_,231)));
DYNX(W_,1805) = real2integer(divideDymola(DYNX(DP_,230), DYNX(DP_,232)));
DYNX(W_,1807) = DYNX(W_,1774);
DYNX(W_,1808) = DYNX(W_,1775);
DYNX(W_,1811) = real2integer(divideDymola(DYNX(W_,1807), 1));
DYNX(W_,1812) = real2integer(divideDymola(DYNX(W_,1808), 1));
DYNX(W_,1813) = DYNX(W_,1774);
DYNX(W_,1814) = DYNX(W_,1775);
DYNX(W_,1817) = real2integer(divideDymola(DYNX(W_,1813), DYNX(W_,1815)));
DYNX(W_,1818) = real2integer(divideDymola(DYNX(W_,1814), DYNX(W_,1816)));
DYNX(W_,1819) = DYNX(DP_,219);
DYNX(W_,1820) = DYNX(DP_,220);
DYNX(W_,1821) = DYNX(DP_,221);
DYNX(W_,1822) = IF DYNX(DP_,237) THEN DYNX(DP_,239)*DYNX(W_,1774)*DYNX(W_,1775)
   ELSE DYNX(DP_,238);
DYNX(W_,1827) = DYNX(DP_,236);
DYNX(W_,1828) = DYNX(W_,1822);
DYNX(W_,1831) = DYNX(DP_,218);
DYNX(W_,1833) = DYNX(DP_,157);
DYNX(W_,1834) = DYNX(DP_,159);
DYNX(W_,1835) = DYNX(DP_,160);
DYNX(W_,1838) = real2integer(divideDymola(DYNX(W_,1834), 1));
DYNX(W_,1839) = real2integer(divideDymola(DYNX(W_,1835), 1));
DYNX(W_,1846) = DYNX(W_,1487);
DYNX(W_,1847) = DYNX(DP_,168);
DYNX(W_,1851) = IF DYNX(W_,1846) == 3 THEN 1 ELSE 2;
DYNX(W_,1855) = DYNX(DP_,242);
DYNX(W_,1857) = DYNX(DP_,245);
DYNX(W_,1860) = DYNX(DP_,243);
DYNX(W_,1866) = DYNX(DP_,246);
DYNX(W_,1868) = DYNX(DP_,249);
DYNX(W_,1871) = DYNX(DP_,247);
DYNX(W_,1885) = DYNX(DP_,255);
DYNX(W_,1884) = DYNX(W_,1885);
DYNX(W_,1900) = DYNX(DP_,261);
DYNX(W_,1899) = DYNX(W_,1900);
DYNX(W_,1912) = DYNX(DP_,267);
DYNX(W_,1911) = DYNX(W_,1912);
DYNX(W_,1923) = DYNX(DP_,273);
DYNX(W_,1922) = DYNX(W_,1923);
DYNX(W_,1924) = DYNX(DP_,278)/(double)(2);
DYNX(W_,1926) = DYNX(DP_,276);
DYNX(W_,1929) = DYNX(DP_,274);
DYNX(W_,1934) = DYNX(DP_,278)/(double)(2);
DYNX(W_,1938) = DYNX(DP_,276);
DYNX(W_,1941) = DYNX(DP_,279);
DYNX(W_,1952) = DYNX(DP_,281);
DYNX(W_,1954) = DYNX(W_,1952);
DYNX(W_,1989) = DYNX(DP_,282);
DYNX(W_,1990) = DYNX(DP_,282);
DYNX(W_,1991) = DYNX(DP_,282);
DYNX(W_,1992) = DYNX(DP_,283);
DYNX(W_,1993) = DYNX(DP_,283);
DYNX(W_,1994) = DYNX(DP_,283);
DYNX(W_,1995) = DYNX(DP_,284);
DYNX(W_,1996) = DYNX(DP_,284);
DYNX(W_,1997) = DYNX(DP_,284);
DYNX(W_,2007) = DYNX(W_,1989);
DYNX(W_,2008) = DYNX(W_,1992);
DYNX(W_,2009) = DYNX(W_,1995);
DYNX(W_,2017) = DYNX(W_,1990);
DYNX(W_,2018) = DYNX(W_,1993);
DYNX(W_,2019) = DYNX(W_,1996);
DYNX(W_,2027) = DYNX(W_,1991);
DYNX(W_,2028) = DYNX(W_,1994);
DYNX(W_,2029) = DYNX(W_,1997);
DYNX(W_,2045) = DYNX(DP_,285);
DYNX(W_,2046) = DYNX(DP_,285);
DYNX(W_,2047) = DYNX(DP_,285);
DYNX(W_,2048) = DYNX(DP_,286);
DYNX(W_,2049) = DYNX(DP_,286);
DYNX(W_,2050) = DYNX(DP_,286);
DYNX(W_,2051) = DYNX(DP_,287);
DYNX(W_,2052) = DYNX(DP_,287);
DYNX(W_,2053) = DYNX(DP_,287);
DYNX(W_,2060) = DYNX(W_,2045);
DYNX(W_,2061) = DYNX(W_,2048);
DYNX(W_,2062) = DYNX(W_,2051);
DYNX(W_,2070) = DYNX(W_,2046);
DYNX(W_,2071) = DYNX(W_,2049);
DYNX(W_,2072) = DYNX(W_,2052);
DYNX(W_,2080) = DYNX(W_,2047);
DYNX(W_,2081) = DYNX(W_,2050);
DYNX(W_,2082) = DYNX(W_,2053);
DYNX(W_,2103) = DYNX(DP_,282);
DYNX(W_,2104) = DYNX(DP_,282);
DYNX(W_,2105) = DYNX(DP_,282);
DYNX(W_,2106) = DYNX(DP_,283);
DYNX(W_,2107) = DYNX(DP_,283);
DYNX(W_,2108) = DYNX(DP_,283);
DYNX(W_,2109) = DYNX(DP_,284);
DYNX(W_,2110) = DYNX(DP_,284);
DYNX(W_,2111) = DYNX(DP_,284);
DYNX(W_,2121) = DYNX(W_,2103);
DYNX(W_,2122) = DYNX(W_,2106);
DYNX(W_,2123) = DYNX(W_,2109);
DYNX(W_,2131) = DYNX(W_,2104);
DYNX(W_,2132) = DYNX(W_,2107);
DYNX(W_,2133) = DYNX(W_,2110);
DYNX(W_,2141) = DYNX(W_,2105);
DYNX(W_,2142) = DYNX(W_,2108);
DYNX(W_,2143) = DYNX(W_,2111);
DYNX(W_,2159) = DYNX(DP_,285);
DYNX(W_,2160) = DYNX(DP_,285);
DYNX(W_,2161) = DYNX(DP_,285);
DYNX(W_,2162) = DYNX(DP_,286);
DYNX(W_,2163) = DYNX(DP_,286);
DYNX(W_,2164) = DYNX(DP_,286);
DYNX(W_,2165) = DYNX(DP_,287);
DYNX(W_,2166) = DYNX(DP_,287);
DYNX(W_,2167) = DYNX(DP_,287);
DYNX(W_,2174) = DYNX(W_,2159);
DYNX(W_,2175) = DYNX(W_,2162);
DYNX(W_,2176) = DYNX(W_,2165);
DYNX(W_,2184) = DYNX(W_,2160);
DYNX(W_,2185) = DYNX(W_,2163);
DYNX(W_,2186) = DYNX(W_,2166);
DYNX(W_,2194) = DYNX(W_,2161);
DYNX(W_,2195) = DYNX(W_,2164);
DYNX(W_,2196) = DYNX(W_,2167);
DYNX(W_,2220) = DYNX(DP_,306);
DYNX(W_,2222) = DYNX(W_,2220);
DYNX(W_,2228) = DYNX(DP_,300);
DYNX(W_,2229) = DYNX(DP_,301);
DYNX(W_,2230) = DYNX(DP_,302);
DYNX(W_,2238) = DYNX(DP_,303);
DYNX(W_,2239) = DYNX(DP_,304);
DYNX(W_,2240) = DYNX(DP_,305);
DYNX(W_,2249) = DYNX(DP_,309);
DYNX(DYNhelp,11) = divinvGuarded(DYNX(DP_,310),"signalPWM4.f");
DYNX(W_,2256) = DYNX(DYNhelp,11);
DYNX(W_,2257) = DYNX(DP_,311);
DYNX(W_,2262) = DYNX(DYNhelp,11);
DYNX(W_,2265) = DYNX(DP_,311);
DYNX(W_,2269) = DYNX(DP_,320);
DYNX(W_,2270) = DYNX(DP_,321);
DYNX(W_,2271) = DYNX(DP_,322);
DYNX(W_,2272) = DYNX(DP_,323);
DYNX(W_,2273) = DYNX(DP_,324);
DYNX(W_,2577) = divGuarded(0.10177640614116878,"0.10177640614116878",
  6.283185307179586*DYNX(DP_,321),"6.283185307179586*threePhaseMotor2.aimcData.fsNominal");
DYNX(W_,2576) = DYNX(W_,2577);
DYNX(W_,2274) = DYNX(W_,2576);
DYNX(W_,2275) = DYNX(W_,2577);
DYNX(W_,2276) = DYNX(DP_,319);
DYNX(W_,2575) = DYNX(DP_,319);
DYNX(W_,2278) = DYNX(W_,2575);
DYNX(W_,2280) = DYNX(W_,2578);
DYNX(DYNhelp,12) = divinvGuarded(DYNX(DP_,320),"threePhaseMotor2.aimcData.p");
DYNX(W_,2579) = DYNX(DYNhelp,12)*6.283185307179586*DYNX(DP_,321);
DYNX(W_,2281) = DYNX(W_,2579);
DYNX(W_,2282) = DYNX(DP_,326);
DYNX(W_,2580) = IF DYNX(W_,2578) <= 0 THEN 0 ELSE divGuarded(DYNX(W_,2578),
  "threePhaseMotor2.aimcData.frictionParameters.PRef",DYNX(W_,2579),
  "threePhaseMotor2.aimcData.frictionParameters.wRef");
DYNX(W_,2283) = DYNX(W_,2580);
DYNX(W_,2582) = DYNX(W_,2581)*DYNX(W_,2579);
DYNX(W_,2285) = DYNX(W_,2582);
DYNX(W_,2583) = IF DYNX(W_,2578) <= 0 THEN 0 ELSE DYNX(W_,2580)*powGuarded(
  divGuarded(DYNX(W_,2582),"threePhaseMotor2.aimcData.frictionParameters.wLinear",
  DYNX(W_,2579),"threePhaseMotor2.aimcData.frictionParameters.wRef"),
  "threePhaseMotor2.aimcData.frictionParameters.wLinear/threePhaseMotor2.aimcData.frictionParameters.wRef",
  DYNX(DP_,326),"threePhaseMotor2.aimcData.frictionParameters.power_w");
DYNX(W_,2286) = DYNX(W_,2583);
DYNX(W_,2289) = DYNX(W_,2276);
DYNX(W_,2293) = DYNX(W_,2278);
DYNX(W_,2303) = DYNX(W_,2280);
DYNX(W_,2304) = DYNX(W_,2281);
DYNX(W_,2305) = DYNX(W_,2282);
DYNX(W_,2306) = DYNX(W_,2283);
DYNX(W_,2308) = DYNX(W_,2285);
DYNX(W_,2309) = DYNX(W_,2286);
DYNX(W_,2316) = DYNX(W_,2585);
DYNX(W_,2317) = DYNX(DP_,327);
DYNX(W_,2586) = 6.283185307179586*DYNX(DP_,321);
DYNX(W_,2318) = DYNX(W_,2586);
DYNX(W_,2588) = IF DYNX(W_,2585) <= 0 THEN 0 ELSE divGuarded(divGuarded(
  DYNX(W_,2585),"threePhaseMotor2.aimcData.statorCoreParameters.PRef",sqr(
  DYNX(DP_,327)),"threePhaseMotor2.aimcData.statorCoreParameters.VRef^2"),
  "threePhaseMotor2.aimcData.statorCoreParameters.PRef/threePhaseMotor2.aimcData.statorCoreParameters.VRef^2",
  DYNX(W_,2584),"threePhaseMotor2.aimcData.statorCoreParameters.m");
DYNX(W_,2320) = DYNX(W_,2588);
DYNX(W_,2589) = 1E-06*DYNX(W_,2586);
DYNX(W_,2321) = DYNX(W_,2589);
DYNX(W_,2322) = DYNX(W_,2590);
DYNX(W_,2323) = DYNX(DP_,328);
DYNX(W_,2591) = DYNX(DYNhelp,12)*6.283185307179586*DYNX(DP_,321);
DYNX(W_,2324) = DYNX(W_,2591);
DYNX(W_,2325) = DYNX(DP_,329);
DYNX(W_,2592) = IF DYNX(W_,2590) <= 0 THEN 0 ELSE divGuarded(DYNX(W_,2590),
  "threePhaseMotor2.aimcData.strayLoadParameters.PRef",DYNX(W_,2591),
  "threePhaseMotor2.aimcData.strayLoadParameters.wRef");
DYNX(W_,2326) = DYNX(W_,2592);
DYNX(W_,2359) = DYNX(W_,2271);
DYNX(W_,2360) = DYNX(W_,2271);
DYNX(W_,2361) = DYNX(W_,2271);
DYNX(W_,2362) = DYNX(W_,2272);
DYNX(W_,2363) = DYNX(W_,2272);
DYNX(W_,2364) = DYNX(W_,2272);
DYNX(W_,2365) = divGuarded(DYNX(W_,2273),"threePhaseMotor2.aimc.alpha20s",1+
  DYNX(W_,2273)*(DYNX(W_,2272)-293.15),"1+threePhaseMotor2.aimc.alpha20s*(threePhaseMotor2.aimc.TsRef-293.15)");
DYNX(W_,2366) = divGuarded(DYNX(W_,2273),"threePhaseMotor2.aimc.alpha20s",1+
  DYNX(W_,2273)*(DYNX(W_,2272)-293.15),"1+threePhaseMotor2.aimc.alpha20s*(threePhaseMotor2.aimc.TsRef-293.15)");
DYNX(W_,2367) = divGuarded(DYNX(W_,2273),"threePhaseMotor2.aimc.alpha20s",1+
  DYNX(W_,2273)*(DYNX(W_,2272)-293.15),"1+threePhaseMotor2.aimc.alpha20s*(threePhaseMotor2.aimc.TsRef-293.15)");
DYNX(W_,2370) = DYNX(W_,2272);
DYNX(W_,2371) = DYNX(W_,2272);
DYNX(W_,2372) = DYNX(W_,2272);
DYNX(W_,2373) = DYNX(W_,2359);
DYNX(W_,2374) = DYNX(W_,2362);
DYNX(W_,2375) = DYNX(W_,2365);
DYNX(W_,2378) = DYNX(W_,2374);
DYNX(W_,2381) = DYNX(W_,2360);
DYNX(W_,2382) = DYNX(W_,2363);
DYNX(W_,2383) = DYNX(W_,2366);
DYNX(W_,2386) = DYNX(W_,2382);
DYNX(W_,2389) = DYNX(W_,2361);
DYNX(W_,2390) = DYNX(W_,2364);
DYNX(W_,2391) = DYNX(W_,2367);
DYNX(W_,2394) = DYNX(W_,2390);
DYNX(W_,2397) = DYNX(W_,2275);
DYNX(W_,2398) = DYNX(W_,2275);
DYNX(W_,2414) = DYNX(W_,2274);
DYNX(W_,2416) = DYNX(W_,2316);
DYNX(W_,2417) = DYNX(W_,2317);
DYNX(W_,2418) = DYNX(W_,2318);
DYNX(W_,2420) = DYNX(W_,2320);
DYNX(W_,2421) = DYNX(W_,2321);
DYNX(W_,2465) = DYNX(W_,2322);
DYNX(W_,2466) = DYNX(W_,2323);
DYNX(W_,2467) = DYNX(W_,2324);
DYNX(W_,2468) = DYNX(W_,2325);
DYNX(W_,2469) = DYNX(W_,2326);
DYNX(W_,2478) = DYNX(DP_,316);
DYNX(W_,2505) = DYNX(W_,2478);
DYNX(W_,2507) = DYNX(DP_,318);
DYNX(W_,2509) = DYNX(W_,2507);
DYNX(W_,2593) = divGuarded(2.898223593858831,"2.898223593858831",
  6.283185307179586*DYNX(DP_,321),"6.283185307179586*threePhaseMotor2.aimcData.fsNominal");
DYNX(W_,2553) = DYNX(W_,2593);
DYNX(W_,2524) = DYNX(W_,2553);
DYNX(W_,2526) = DYNX(W_,2269);
DYNX(W_,2549) = DYNX(W_,2524);
DYNX(W_,2552) = DYNX(W_,2524);
DYNX(W_,2594) = divGuarded(0.10177640614116878,"0.10177640614116878",
  6.283185307179586*DYNX(DP_,321),"6.283185307179586*threePhaseMotor2.aimcData.fsNominal");
DYNX(W_,2554) = DYNX(W_,2594);
DYNX(W_,2555) = DYNX(DP_,330);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(7);
DYNX(W_,2556) = DYNX(DP_,331);
DYNX(W_,2557) = DYNX(DP_,332);
DYNX(W_,2558) = DYNX(W_,2554);
DYNX(W_,2559) = DYNX(W_,2555);
DYNX(W_,2560) = DYNX(W_,2556);
DYNX(W_,2561) = divGuarded(DYNX(W_,2557),"threePhaseMotor2.aimc.alpha20r",1+
  DYNX(W_,2557)*(DYNX(W_,2556)-293.15),"1+threePhaseMotor2.aimc.alpha20r*(threePhaseMotor2.aimc.TrRef-293.15)");
DYNX(W_,2563) = DYNX(W_,2560);
DYNX(W_,2596) = 0.10471975511965977*DYNX(DP_,315);
DYNX(DYNhelp,13) = divinvGuarded(DYNX(DP_,334),"signalPWM5[1].f");
DYNX(W_,2604) = DYNX(DYNhelp,13);
DYNX(W_,2605) = DYNX(DP_,335);
DYNX(W_,2610) = DYNX(DYNhelp,13);
DYNX(W_,2613) = DYNX(DP_,335);
DYNX(DYNhelp,14) = divinvGuarded(DYNX(DP_,339),"signalPWM5[2].f");
DYNX(W_,2623) = DYNX(DYNhelp,14);
DYNX(W_,2624) = DYNX(DP_,340);
DYNX(W_,2629) = DYNX(DYNhelp,14);
DYNX(W_,2632) = DYNX(DP_,340);
DYNX(DYNhelp,15) = divinvGuarded(DYNX(DP_,344),"signalPWM5[3].f");
DYNX(W_,2642) = DYNX(DYNhelp,15);
DYNX(W_,2643) = DYNX(DP_,345);
DYNX(W_,2648) = DYNX(DYNhelp,15);
DYNX(W_,2651) = DYNX(DP_,345);
DYNX(W_,2655) = DYNX(DP_,352);
DYNX(W_,2656) = DYNX(DP_,351);
DYNX(W_,2661) = DYNX(DP_,350);
DYNX(W_,2663) = DYNX(DP_,353);
DYNX(W_,2667) = DYNX(DP_,356);
DYNX(W_,2672) = DYNX(DP_,359);
BoundParameterConstantSection
DYNX(W_,330) = homotopy(IF DYNX(W_,326) > DYNX(DP_,39) THEN DYNX(DP_,39) ELSE 
  IF DYNX(W_,326) < DYNX(DP_,40) THEN DYNX(DP_,40) ELSE DYNX(W_,326), 
  DYNX(W_,326));
DYNX(W_,641) = DYNX(W_,636)*(1+DYNX(W_,638)*(DYNX(W_,586)-DYNX(W_,637)));
DYNX(W_,473) = DYNX(W_,466)*(1+DYNX(W_,468)*(DYNX(W_,582)-DYNX(W_,467)));
DYNX(W_,2669) = DYNX(DP_,355)*(1+DYNX(DP_,357)*(DYNX(W_,2667)-DYNX(DP_,356)));
DYNX(W_,2674) = DYNX(DP_,358)*(1+DYNX(DP_,360)*(DYNX(W_,2672)-DYNX(DP_,359)));
DYNX(W_,457) = DYNX(W_,450)*(1+DYNX(W_,452)*(DYNX(W_,582)-DYNX(W_,451)));
DYNX(W_,465) = DYNX(W_,458)*(1+DYNX(W_,460)*(DYNX(W_,582)-DYNX(W_,459)));
DYNX(W_,20) = DYNX(W_,15)*(1+DYNX(DP_,7)*(DYNX(W_,18)-DYNX(DP_,6)));
DYNX(W_,8) = DYNX(W_,3)*(1+DYNX(DP_,2)*(DYNX(W_,6)-DYNX(DP_,1)));
DYNX(W_,1050) = homotopy(IF DYNX(W_,1046) > DYNX(DP_,113) THEN DYNX(DP_,113)
   ELSE IF DYNX(W_,1046) < DYNX(DP_,114) THEN DYNX(DP_,114) ELSE DYNX(W_,1046), 
  DYNX(W_,1046));
DYNX(W_,1361) = DYNX(W_,1356)*(1+DYNX(W_,1358)*(DYNX(W_,1306)-DYNX(W_,1357)));
DYNX(W_,1193) = DYNX(W_,1186)*(1+DYNX(W_,1188)*(DYNX(W_,1302)-DYNX(W_,1187)));
DYNX(W_,1177) = DYNX(W_,1170)*(1+DYNX(W_,1172)*(DYNX(W_,1302)-DYNX(W_,1171)));
DYNX(W_,1185) = DYNX(W_,1178)*(1+DYNX(W_,1180)*(DYNX(W_,1302)-DYNX(W_,1179)));
DYNX(W_,1862) = DYNX(W_,1857)*(1+DYNX(DP_,244)*(DYNX(W_,1860)-DYNX(DP_,243)));
DYNX(W_,1873) = DYNX(W_,1868)*(1+DYNX(DP_,248)*(DYNX(W_,1871)-DYNX(DP_,247)));
DYNX(W_,1593) = IF DYNX(DP_,205) THEN DYNX(DP_,209)*DYNX(DP_,210) ELSE 1;
DYNX(W_,1661) = DYNX(W_,1662)*DYNX(W_,1593);
DYNX(W_,1586) = DYNX(DP_,183)*DYNX(DP_,184);
DYNX(W_,1594) = IF DYNX(DP_,204) THEN DYNX(DP_,209)+DYNX(DP_,210)-1 ELSE 1;
DYNX(W_,1561) = DYNX(W_,1586)*DYNX(W_,1594);
DYNX(W_,1512) = DYNX(W_,1572)*DYNX(W_,1561);
DYNX(W_,1598) = DYNX(W_,1582)+DYNX(W_,1584);
DYNX(W_,1599) = DYNX(W_,1583)-DYNX(W_,1584);
DYNX(W_,1623) = DYNX(DP_,188);
DYNX(W_,1624) = DYNX(DP_,189)-DYNX(DP_,190);
DYNX(W_,1700) = DYNX(DP_,174)+DYNX(DP_,176);
DYNX(W_,1701) = DYNX(DP_,175)-DYNX(DP_,176);
DYNX(W_,1726) = DYNX(DP_,178);
DYNX(W_,1727) =  -DYNX(DP_,177);
DYNX(W_,1735) = DYNX(DP_,181);
DYNX(W_,1736) =  -DYNX(DP_,180);
DYNX(W_,2253) = homotopy(IF DYNX(W_,2249) > DYNX(DP_,312) THEN DYNX(DP_,312)
   ELSE IF DYNX(W_,2249) < DYNX(DP_,313) THEN DYNX(DP_,313) ELSE DYNX(W_,2249), 
  DYNX(W_,2249));
DYNX(W_,2564) = DYNX(W_,2559)*(1+DYNX(W_,2561)*(DYNX(W_,2509)-DYNX(W_,2560)));
DYNX(W_,2396) = DYNX(W_,2389)*(1+DYNX(W_,2391)*(DYNX(W_,2505)-DYNX(W_,2390)));
DYNX(W_,2388) = DYNX(W_,2381)*(1+DYNX(W_,2383)*(DYNX(W_,2505)-DYNX(W_,2382)));
DYNX(W_,2380) = DYNX(W_,2373)*(1+DYNX(W_,2375)*(DYNX(W_,2505)-DYNX(W_,2374)));
 /* Linear system of equations to solve. */
DYNX(W_,1824) = 0.0;
SolveScalarLinearParametric( -DYNX(W_,1827)," -batteryPack.thermal.ambientTransfer.G",
   0.0,"0.0", DYNX(W_,1824),"batteryPack.thermal.ambientTransfer.dT");
 /* End of Equation Block */ 

DYNX(W_,1931) = DYNX(W_,1926)*(1+DYNX(DP_,275)*(DYNX(W_,1929)-DYNX(DP_,274)));
DYNX(W_,1943) = DYNX(W_,1938)*(1+DYNX(DP_,280)*(DYNX(W_,1941)-DYNX(DP_,279)));
DYNX(DYNhelp,16) = fabs(DYNX(W_,395));
DYNX(W_,508) = RealBmax(DYNX(DYNhelp,16), DYNX(W_,498));
DYNX(DYNhelp,17) = fabs(DYNX(W_,1115));
DYNX(W_,1228) = RealBmax(DYNX(DYNhelp,17), DYNX(W_,1218));
DYNX(W_,1504) = (PushModelContext(1,"Electrification.Batteries.Core.Capacity.Functions.arrayCapacity(batteryPack.summary.core_Q_cap_aged, 1, 1)")
  Electrification_Batteries_Core_Capacity_Functions_arrayCapacity(
  RealTemporaryDense( &DYNX(W_,1512), 2, 1, 1), 1, 1));
PopAllMarks();
DYNX(W_,1587) = DYNX(W_,1572)*DYNX(W_,1586);
DYNX(W_,1591) = IF DYNX(DP_,207) THEN DYNX(DP_,209)*DYNX(DP_,210) ELSE 1;
DYNX(W_,1592) = IF DYNX(DP_,206) THEN DYNX(DP_,209)*DYNX(DP_,210) ELSE 1;
DYNX(W_,1595) = IF DYNX(DP_,208) THEN DYNX(DP_,209)*DYNX(DP_,210) ELSE 1;
DYNX(DYNhelp,18) = divinvGuarded(DYNX(W_,1611),"batteryPack.core.voltage.ngs");
DYNX(DYNhelp,19) = divinvGuarded(DYNX(DP_,192),"batteryPack.core.voltage.k_OCV");
DYNX(W_,1632) = DYNX(DYNhelp,19)*DYNX(DYNhelp,18)*300.0;
DYNX(DYNhelp,20) = fabs(DYNX(W_,2318));
DYNX(W_,2431) = RealBmax(DYNX(DYNhelp,20), DYNX(W_,2421));
BoundParameterSection
InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,89) = true;
DYNX(W_,90) = 0;
DYNX(W_,99) = true;
DYNX(W_,100) = 0;
DYNX(W_,109) = true;
DYNX(W_,110) = 0;
DYNX(W_,142) = true;
DYNX(W_,143) = 0;
DYNX(W_,152) = true;
DYNX(W_,153) = 0;
DYNX(W_,162) = true;
DYNX(W_,163) = 0;
DYNX(W_,203) = true;
DYNX(W_,204) = 0;
DYNX(W_,213) = true;
DYNX(W_,214) = 0;
DYNX(W_,223) = true;
DYNX(W_,224) = 0;
DYNX(W_,256) = true;
DYNX(W_,257) = 0;
DYNX(W_,266) = true;
DYNX(W_,267) = 0;
DYNX(W_,276) = true;
DYNX(W_,277) = 0;
DYNX(W_,310) = true;
DYNX(W_,311) = 0;
DYNX(W_,320) = true;
DYNX(W_,321) = 0;
DYNX(W_,336) = false;
DYNX(W_,337) = 0;
DYNX(W_,364) = 0;
DYNX(W_,684) = false;
DYNX(W_,685) = 0;
DYNX(W_,703) = false;
DYNX(W_,704) = 0;
DYNX(W_,722) = false;
DYNX(W_,723) = 0;
DYNX(W_,806) = true;
DYNX(W_,807) = 0;
DYNX(W_,816) = true;
DYNX(W_,817) = 0;
DYNX(W_,826) = true;
DYNX(W_,827) = 0;
DYNX(W_,859) = true;
DYNX(W_,860) = 0;
DYNX(W_,869) = true;
DYNX(W_,870) = 0;
DYNX(W_,879) = true;
DYNX(W_,880) = 0;
DYNX(W_,920) = true;
DYNX(W_,921) = 0;
DYNX(W_,930) = true;
DYNX(W_,931) = 0;
DYNX(W_,940) = true;
DYNX(W_,941) = 0;
DYNX(W_,973) = true;
DYNX(W_,974) = 0;
DYNX(W_,983) = true;
DYNX(W_,984) = 0;
DYNX(W_,993) = true;
DYNX(W_,994) = 0;
DYNX(W_,1030) = true;
DYNX(W_,1031) = 0;
DYNX(W_,1040) = true;
DYNX(W_,1041) = 0;
DYNX(W_,1056) = false;
DYNX(W_,1057) = 0;
DYNX(W_,1084) = 0;
DYNX(W_,1404) = false;
DYNX(W_,1405) = 0;
DYNX(W_,1423) = false;
DYNX(W_,1424) = 0;
DYNX(W_,1442) = false;
DYNX(W_,1443) = 0;
DYNX(W_,1602) = false;
DYNX(W_,1603) = false;
DYNX(W_,1628) = false;
DYNX(W_,1629) = false;
DYNX(W_,1705) = false;
DYNX(W_,1706) = false;
DYNX(W_,1731) = false;
DYNX(W_,1732) = false;
DYNX(W_,1740) = false;
DYNX(W_,1741) = false;
DYNX(W_,1802) = 288.15;
DYNX(W_,1849) = false;
DYNX(W_,1850) = false;
DYNX(W_,2012) = true;
DYNX(W_,2013) = 0;
DYNX(W_,2022) = true;
DYNX(W_,2023) = 0;
DYNX(W_,2032) = true;
DYNX(W_,2033) = 0;
DYNX(W_,2065) = true;
DYNX(W_,2066) = 0;
DYNX(W_,2075) = true;
DYNX(W_,2076) = 0;
DYNX(W_,2085) = true;
DYNX(W_,2086) = 0;
DYNX(W_,2126) = true;
DYNX(W_,2127) = 0;
DYNX(W_,2136) = true;
DYNX(W_,2137) = 0;
DYNX(W_,2146) = true;
DYNX(W_,2147) = 0;
DYNX(W_,2179) = true;
DYNX(W_,2180) = 0;
DYNX(W_,2189) = true;
DYNX(W_,2190) = 0;
DYNX(W_,2199) = true;
DYNX(W_,2200) = 0;
DYNX(W_,2233) = true;
DYNX(W_,2234) = 0;
DYNX(W_,2243) = true;
DYNX(W_,2244) = 0;
DYNX(W_,2259) = false;
DYNX(W_,2260) = 0;
DYNX(W_,2287) = 0;
DYNX(W_,2607) = false;
DYNX(W_,2608) = 0;
DYNX(W_,2626) = false;
DYNX(W_,2627) = 0;
DYNX(W_,2645) = false;
DYNX(W_,2646) = 0;
#endif
InitialSection
InitialStartSection
InitialStartSection2
DYNX(W_,343) = DYNX(W_,342);
DYNX(W_,691) = DYNX(W_,690);
DYNX(W_,710) = DYNX(W_,709);
DYNX(W_,729) = DYNX(W_,728);
DYNX(W_,1063) = DYNX(W_,1062);
DYNX(W_,1411) = DYNX(W_,1410);
DYNX(W_,1430) = DYNX(W_,1429);
DYNX(W_,1449) = DYNX(W_,1448);
DYNX(W_,1511) = DYNX(W_,1577);
DYNX(W_,1597) = DYNX(W_,1576);
DYNX(W_,2266) = DYNX(W_,2265);
DYNX(W_,2614) = DYNX(W_,2613);
DYNX(W_,2633) = DYNX(W_,2632);
DYNX(W_,2652) = DYNX(W_,2651);
DYNX(X_,5) = DYNX(DP_,75);
DYNX(X_,12) = DYNX(DP_,149);
DYNX(X_,14) = DYNX(W_,1577);
DYNX(X_,15) = DYNX(W_,1831);
DYNX(X_,22) = DYNX(DP_,348);
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialBoundSection
DYNX(Aux_,0) = DYNX(W_,1603);
DYNX(Aux_,1) = DYNX(W_,1602);
DYNX(Aux_,2) = DYNX(W_,1732);
DYNX(Aux_,3) = DYNX(W_,1731);
DYNX(Aux_,4) = DYNX(W_,1741);
DYNX(Aux_,5) = DYNX(W_,1740);
DYNX(Aux_,6) = DYNX(W_,1706);
DYNX(Aux_,7) = DYNX(W_,1705);
DYNX(Aux_,8) = DYNX(W_,1629);
DYNX(Aux_,9) = DYNX(W_,1628);
DYNX(Aux_,10) = DYNX(W_,1850);
DYNX(Aux_,11) = DYNX(W_,1849);
DYNX(Aux_,12) = DYNX(W_,1063);
DYNX(Aux_,13) = DYNX(W_,1064);
DYNX(Aux_,14) = DYNX(W_,1056);
DYNX(Aux_,15) = DYNX(W_,1057);
DYNX(Aux_,16) = DYNX(W_,343);
DYNX(Aux_,17) = DYNX(W_,344);
DYNX(Aux_,18) = DYNX(W_,336);
DYNX(Aux_,19) = DYNX(W_,337);
DYNX(Aux_,20) = DYNX(W_,1411);
DYNX(Aux_,21) = DYNX(W_,1412);
DYNX(Aux_,22) = DYNX(W_,1404);
DYNX(Aux_,23) = DYNX(W_,1405);
DYNX(Aux_,24) = DYNX(W_,1430);
DYNX(Aux_,25) = DYNX(W_,1431);
DYNX(Aux_,26) = DYNX(W_,1423);
DYNX(Aux_,27) = DYNX(W_,1424);
DYNX(Aux_,28) = DYNX(W_,1449);
DYNX(Aux_,29) = DYNX(W_,1450);
DYNX(Aux_,30) = DYNX(W_,1442);
DYNX(Aux_,31) = DYNX(W_,1443);
DYNX(Aux_,32) = DYNX(W_,2266);
DYNX(Aux_,33) = DYNX(W_,2267);
DYNX(Aux_,34) = DYNX(W_,2259);
DYNX(Aux_,35) = DYNX(W_,2260);
DYNX(Aux_,36) = DYNX(W_,2614);
DYNX(Aux_,37) = DYNX(W_,2615);
DYNX(Aux_,38) = DYNX(W_,2607);
DYNX(Aux_,39) = DYNX(W_,2608);
DYNX(Aux_,40) = DYNX(W_,2633);
DYNX(Aux_,41) = DYNX(W_,2634);
DYNX(Aux_,42) = DYNX(W_,2626);
DYNX(Aux_,43) = DYNX(W_,2627);
DYNX(Aux_,44) = DYNX(W_,2652);
DYNX(Aux_,45) = DYNX(W_,2653);
DYNX(Aux_,46) = DYNX(W_,2645);
DYNX(Aux_,47) = DYNX(W_,2646);
DYNX(Aux_,48) = DYNX(W_,691);
DYNX(Aux_,49) = DYNX(W_,692);
DYNX(Aux_,50) = DYNX(W_,684);
DYNX(Aux_,51) = DYNX(W_,685);
DYNX(Aux_,52) = DYNX(W_,710);
DYNX(Aux_,53) = DYNX(W_,711);
DYNX(Aux_,54) = DYNX(W_,703);
DYNX(Aux_,55) = DYNX(W_,704);
DYNX(Aux_,56) = DYNX(W_,729);
DYNX(Aux_,57) = DYNX(W_,730);
DYNX(Aux_,58) = DYNX(W_,722);
DYNX(Aux_,59) = DYNX(W_,723);
InitialSection
InitialSection2
DYNX(F_,5) = 0;
DYNX(F_,12) = 0;
DYNX(F_,14) = 0.0;
DYNX(F_,22) = 0;
DYNX(W_,1005) = 0.0;
DYNX(W_,1) = DYNX(DP_,5)/(double)(2);
DYNX(W_,3) = DYNX(DP_,3);
DYNX(W_,6) = DYNX(DP_,1);
AssertModelica(1+DYNX(DP_,2)*(DYNX(W_,6)-DYNX(DP_,1)) >= 1E-15,"1+simplifiedFuelCell.resistor.alpha*(simplifiedFuelCell.resistor.T-simplifiedFuelCell.resistor.T_ref) >= 1E-15",
   "Temperature outside scope of model!");
DYNX(W_,11) = DYNX(DP_,5)/(double)(2);
DYNX(W_,15) = DYNX(DP_,3);
DYNX(W_,18) = DYNX(DP_,6);
AssertModelica(1+DYNX(DP_,7)*(DYNX(W_,18)-DYNX(DP_,6)) >= 1E-15,"1+simplifiedFuelCell.resistor1.alpha*(simplifiedFuelCell.resistor1.T-simplifiedFuelCell.resistor1.T_ref) >= 1E-15",
   "Temperature outside scope of model!");
DYNX(W_,66) = DYNX(DP_,9);
DYNX(W_,67) = DYNX(DP_,9);
DYNX(W_,68) = DYNX(DP_,9);
DYNX(W_,69) = DYNX(DP_,10);
DYNX(W_,70) = DYNX(DP_,10);
DYNX(W_,71) = DYNX(DP_,10);
DYNX(W_,72) = DYNX(DP_,11);
DYNX(W_,73) = DYNX(DP_,11);
DYNX(W_,74) = DYNX(DP_,11);
DYNX(W_,84) = DYNX(W_,66);
DYNX(W_,85) = DYNX(W_,69);
DYNX(W_,86) = DYNX(W_,72);
DYNX(W_,94) = DYNX(W_,67);
DYNX(W_,95) = DYNX(W_,70);
DYNX(W_,96) = DYNX(W_,73);
DYNX(W_,104) = DYNX(W_,68);
DYNX(W_,105) = DYNX(W_,71);
DYNX(W_,106) = DYNX(W_,74);
DYNX(W_,122) = DYNX(DP_,12);
DYNX(W_,123) = DYNX(DP_,12);
DYNX(W_,124) = DYNX(DP_,12);
DYNX(W_,125) = DYNX(DP_,13);
DYNX(W_,126) = DYNX(DP_,13);
DYNX(W_,127) = DYNX(DP_,13);
DYNX(W_,128) = DYNX(DP_,14);
DYNX(W_,129) = DYNX(DP_,14);
DYNX(W_,130) = DYNX(DP_,14);
DYNX(W_,137) = DYNX(W_,122);
DYNX(W_,138) = DYNX(W_,125);
DYNX(W_,139) = DYNX(W_,128);
DYNX(W_,147) = DYNX(W_,123);
DYNX(W_,148) = DYNX(W_,126);
DYNX(W_,149) = DYNX(W_,129);
DYNX(W_,157) = DYNX(W_,124);
DYNX(W_,158) = DYNX(W_,127);
DYNX(W_,159) = DYNX(W_,130);
DYNX(W_,180) = DYNX(DP_,9);
DYNX(W_,181) = DYNX(DP_,9);
DYNX(W_,182) = DYNX(DP_,9);
DYNX(W_,183) = DYNX(DP_,10);
DYNX(W_,184) = DYNX(DP_,10);
DYNX(W_,185) = DYNX(DP_,10);
DYNX(W_,186) = DYNX(DP_,11);
DYNX(W_,187) = DYNX(DP_,11);
DYNX(W_,188) = DYNX(DP_,11);
DYNX(W_,198) = DYNX(W_,180);
DYNX(W_,199) = DYNX(W_,183);
DYNX(W_,200) = DYNX(W_,186);
DYNX(W_,208) = DYNX(W_,181);
DYNX(W_,209) = DYNX(W_,184);
DYNX(W_,210) = DYNX(W_,187);
DYNX(W_,218) = DYNX(W_,182);
DYNX(W_,219) = DYNX(W_,185);
DYNX(W_,220) = DYNX(W_,188);
DYNX(W_,236) = DYNX(DP_,12);
DYNX(W_,237) = DYNX(DP_,12);
DYNX(W_,238) = DYNX(DP_,12);
DYNX(W_,239) = DYNX(DP_,13);
DYNX(W_,240) = DYNX(DP_,13);
DYNX(W_,241) = DYNX(DP_,13);
DYNX(W_,242) = DYNX(DP_,14);
DYNX(W_,243) = DYNX(DP_,14);
DYNX(W_,244) = DYNX(DP_,14);
DYNX(W_,251) = DYNX(W_,236);
DYNX(W_,252) = DYNX(W_,239);
DYNX(W_,253) = DYNX(W_,242);
DYNX(W_,261) = DYNX(W_,237);
DYNX(W_,262) = DYNX(W_,240);
DYNX(W_,263) = DYNX(W_,243);
DYNX(W_,271) = DYNX(W_,238);
DYNX(W_,272) = DYNX(W_,241);
DYNX(W_,273) = DYNX(W_,244);
DYNX(W_,305) = DYNX(DP_,27);
DYNX(W_,306) = DYNX(DP_,28);
DYNX(W_,307) = DYNX(DP_,29);
DYNX(W_,315) = DYNX(DP_,30);
DYNX(W_,316) = DYNX(DP_,31);
DYNX(W_,317) = DYNX(DP_,32);
DYNX(W_,326) = DYNX(DP_,36);
DYNX(W_,333) = divinvGuarded(DYNX(DP_,37),"signalPWM2.f");
DYNX(W_,334) = DYNX(DP_,38);
DYNX(W_,339) = divinvGuarded(DYNX(DP_,37),"signalPWM2.f");
DYNX(W_,342) = DYNX(DP_,38);
DYNX(W_,347) = DYNX(DP_,48);
DYNX(W_,348) = DYNX(DP_,49);
DYNX(W_,349) = DYNX(DP_,50);
DYNX(W_,350) = DYNX(DP_,51);
DYNX(W_,654) = divGuarded(0.10177640614116878,"0.10177640614116878",
  6.283185307179586*DYNX(DP_,48),"6.283185307179586*threePhaseMotor.aimcData.fsNominal");
DYNX(W_,653) = DYNX(W_,654);
DYNX(W_,351) = DYNX(W_,653);
DYNX(W_,352) = DYNX(W_,654);
DYNX(W_,353) = DYNX(DP_,46);
DYNX(W_,652) = DYNX(DP_,46);
DYNX(W_,355) = DYNX(W_,652);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(8);
DYNX(W_,357) = DYNX(W_,655);
DYNX(W_,656) = divGuarded(6.283185307179586*DYNX(DP_,48),"6.283185307179586*threePhaseMotor.aimcData.fsNominal",
  DYNX(DP_,47),"threePhaseMotor.aimcData.p");
DYNX(W_,358) = DYNX(W_,656);
DYNX(W_,359) = DYNX(DP_,53);
DYNX(W_,657) = IF DYNX(W_,655) <= 0 THEN 0 ELSE divGuarded(DYNX(W_,655),
  "threePhaseMotor.aimcData.frictionParameters.PRef",DYNX(W_,656),
  "threePhaseMotor.aimcData.frictionParameters.wRef");
DYNX(W_,360) = DYNX(W_,657);
DYNX(W_,659) = DYNX(W_,658)*DYNX(W_,656);
DYNX(W_,362) = DYNX(W_,659);
DYNX(W_,660) = IF DYNX(W_,655) <= 0 THEN 0 ELSE DYNX(W_,657)*powGuarded(
  divGuarded(DYNX(W_,659),"threePhaseMotor.aimcData.frictionParameters.wLinear",
  DYNX(W_,656),"threePhaseMotor.aimcData.frictionParameters.wRef"),
  "threePhaseMotor.aimcData.frictionParameters.wLinear/threePhaseMotor.aimcData.frictionParameters.wRef",
  DYNX(DP_,53),"threePhaseMotor.aimcData.frictionParameters.power_w");
DYNX(W_,363) = DYNX(W_,660);
DYNX(W_,366) = DYNX(W_,353);
DYNX(W_,370) = DYNX(W_,355);
DYNX(W_,380) = DYNX(W_,357);
DYNX(W_,381) = DYNX(W_,358);
DYNX(W_,382) = DYNX(W_,359);
DYNX(W_,383) = DYNX(W_,360);
DYNX(W_,385) = DYNX(W_,362);
DYNX(W_,386) = DYNX(W_,363);
DYNX(W_,393) = DYNX(W_,662);
DYNX(W_,394) = DYNX(DP_,54);
DYNX(W_,663) = 6.283185307179586*DYNX(DP_,48);
DYNX(W_,395) = DYNX(W_,663);
DYNX(W_,665) = IF DYNX(W_,662) <= 0 THEN 0 ELSE divGuarded(divGuarded(
  DYNX(W_,662),"threePhaseMotor.aimcData.statorCoreParameters.PRef",sqr(
  DYNX(DP_,54)),"threePhaseMotor.aimcData.statorCoreParameters.VRef^2"),
  "threePhaseMotor.aimcData.statorCoreParameters.PRef/threePhaseMotor.aimcData.statorCoreParameters.VRef^2",
  DYNX(W_,661),"threePhaseMotor.aimcData.statorCoreParameters.m");
DYNX(W_,397) = DYNX(W_,665);
DYNX(W_,666) = 1E-06*DYNX(W_,663);
DYNX(W_,398) = DYNX(W_,666);
DYNX(W_,399) = DYNX(W_,667);
DYNX(W_,400) = DYNX(DP_,55);
DYNX(W_,668) = divGuarded(6.283185307179586*DYNX(DP_,48),"6.283185307179586*threePhaseMotor.aimcData.fsNominal",
  DYNX(DP_,47),"threePhaseMotor.aimcData.p");
DYNX(W_,401) = DYNX(W_,668);
DYNX(W_,402) = DYNX(DP_,56);
DYNX(W_,669) = IF DYNX(W_,667) <= 0 THEN 0 ELSE divGuarded(DYNX(W_,667),
  "threePhaseMotor.aimcData.strayLoadParameters.PRef",DYNX(W_,668),
  "threePhaseMotor.aimcData.strayLoadParameters.wRef");
DYNX(W_,403) = DYNX(W_,669);
DYNX(W_,436) = DYNX(W_,348);
DYNX(W_,437) = DYNX(W_,348);
DYNX(W_,438) = DYNX(W_,348);
DYNX(W_,439) = DYNX(W_,349);
DYNX(W_,440) = DYNX(W_,349);
DYNX(W_,441) = DYNX(W_,349);
DYNX(W_,442) = divGuarded(DYNX(W_,350),"threePhaseMotor.aimc.alpha20s",1+
  DYNX(W_,350)*(DYNX(W_,349)-293.15),"1+threePhaseMotor.aimc.alpha20s*(threePhaseMotor.aimc.TsRef-293.15)");
DYNX(W_,443) = divGuarded(DYNX(W_,350),"threePhaseMotor.aimc.alpha20s",1+
  DYNX(W_,350)*(DYNX(W_,349)-293.15),"1+threePhaseMotor.aimc.alpha20s*(threePhaseMotor.aimc.TsRef-293.15)");
DYNX(W_,444) = divGuarded(DYNX(W_,350),"threePhaseMotor.aimc.alpha20s",1+
  DYNX(W_,350)*(DYNX(W_,349)-293.15),"1+threePhaseMotor.aimc.alpha20s*(threePhaseMotor.aimc.TsRef-293.15)");
DYNX(W_,447) = DYNX(W_,349);
DYNX(W_,448) = DYNX(W_,349);
DYNX(W_,449) = DYNX(W_,349);
DYNX(W_,450) = DYNX(W_,436);
DYNX(W_,451) = DYNX(W_,439);
DYNX(W_,452) = DYNX(W_,442);
DYNX(W_,455) = DYNX(W_,451);
DYNX(W_,458) = DYNX(W_,437);
DYNX(W_,459) = DYNX(W_,440);
DYNX(W_,460) = DYNX(W_,443);
DYNX(W_,463) = DYNX(W_,459);
DYNX(W_,466) = DYNX(W_,438);
DYNX(W_,467) = DYNX(W_,441);
DYNX(W_,468) = DYNX(W_,444);
DYNX(W_,471) = DYNX(W_,467);
DYNX(W_,474) = DYNX(W_,352);
DYNX(W_,475) = DYNX(W_,352);
DYNX(W_,491) = DYNX(W_,351);
DYNX(W_,493) = DYNX(W_,393);
DYNX(W_,494) = DYNX(W_,394);
DYNX(W_,495) = DYNX(W_,395);
DYNX(W_,497) = DYNX(W_,397);
DYNX(W_,498) = DYNX(W_,398);
DYNX(W_,542) = DYNX(W_,399);
DYNX(W_,543) = DYNX(W_,400);
DYNX(W_,544) = DYNX(W_,401);
DYNX(W_,545) = DYNX(W_,402);
DYNX(W_,546) = DYNX(W_,403);
DYNX(W_,555) = DYNX(DP_,43);
DYNX(W_,582) = DYNX(W_,555);
AssertModelica(1+DYNX(W_,452)*(DYNX(W_,582)-DYNX(W_,451)) >= 1E-15,
  "1+threePhaseMotor.aimc.rs.resistor[1].alpha*(threePhaseMotor.aimc.thermalAmbient.constTs.k-threePhaseMotor.aimc.rs.resistor[1].T_ref) >= 1E-15",
   "Temperature outside scope of model!");
AssertModelica(1+DYNX(W_,460)*(DYNX(W_,582)-DYNX(W_,459)) >= 1E-15,
  "1+threePhaseMotor.aimc.rs.resistor[2].alpha*(threePhaseMotor.aimc.thermalAmbient.constTs.k-threePhaseMotor.aimc.rs.resistor[2].T_ref) >= 1E-15",
   "Temperature outside scope of model!");
AssertModelica(1+DYNX(W_,468)*(DYNX(W_,582)-DYNX(W_,467)) >= 1E-15,
  "1+threePhaseMotor.aimc.rs.resistor[3].alpha*(threePhaseMotor.aimc.thermalAmbient.constTs.k-threePhaseMotor.aimc.rs.resistor[3].T_ref) >= 1E-15",
   "Temperature outside scope of model!");
DYNX(W_,584) = DYNX(DP_,45);
DYNX(W_,586) = DYNX(W_,584);
DYNX(W_,670) = divGuarded(2.898223593858831,"2.898223593858831",6.283185307179586
  *DYNX(DP_,48),"6.283185307179586*threePhaseMotor.aimcData.fsNominal");
DYNX(W_,630) = DYNX(W_,670);
DYNX(W_,601) = DYNX(W_,630);
DYNX(W_,626) = DYNX(W_,601);
DYNX(W_,629) = DYNX(W_,601);
DYNX(W_,671) = divGuarded(0.10177640614116878,"0.10177640614116878",
  6.283185307179586*DYNX(DP_,48),"6.283185307179586*threePhaseMotor.aimcData.fsNominal");
DYNX(W_,631) = DYNX(W_,671);
DYNX(W_,632) = DYNX(DP_,57);
DYNX(W_,633) = DYNX(DP_,58);
DYNX(W_,634) = DYNX(DP_,59);
DYNX(W_,635) = DYNX(W_,631);
DYNX(W_,636) = DYNX(W_,632);
DYNX(W_,637) = DYNX(W_,633);
DYNX(W_,638) = divGuarded(DYNX(W_,634),"threePhaseMotor.aimc.alpha20r",1+
  DYNX(W_,634)*(DYNX(W_,633)-293.15),"1+threePhaseMotor.aimc.alpha20r*(threePhaseMotor.aimc.TrRef-293.15)");
AssertModelica(1+DYNX(W_,638)*(DYNX(W_,586)-DYNX(W_,637)) >= 1E-15,
  "1+threePhaseMotor.aimc.squirrelCageR.alpha*(threePhaseMotor.aimc.thermalAmbient.constTr.k-threePhaseMotor.aimc.squirrelCageR.T_ref) >= 1E-15",
   "Temperature outside scope of model!");
DYNX(W_,640) = DYNX(W_,637);
DYNX(W_,673) = 0.10471975511965977*DYNX(DP_,42);
DYNX(W_,681) = divinvGuarded(DYNX(DP_,61),"signalPWM[1].f");
DYNX(W_,682) = DYNX(DP_,62);
DYNX(W_,687) = divinvGuarded(DYNX(DP_,61),"signalPWM[1].f");
DYNX(W_,690) = DYNX(DP_,62);
DYNX(W_,700) = divinvGuarded(DYNX(DP_,66),"signalPWM[2].f");
DYNX(W_,701) = DYNX(DP_,67);
DYNX(W_,706) = divinvGuarded(DYNX(DP_,66),"signalPWM[2].f");
DYNX(W_,709) = DYNX(DP_,67);
DYNX(W_,719) = divinvGuarded(DYNX(DP_,71),"signalPWM[3].f");
DYNX(W_,720) = DYNX(DP_,72);
DYNX(W_,725) = divinvGuarded(DYNX(DP_,71),"signalPWM[3].f");
DYNX(W_,728) = DYNX(DP_,72);
DYNX(W_,732) = DYNX(DP_,79);
DYNX(W_,733) = DYNX(DP_,78);
DYNX(W_,738) = DYNX(DP_,77);
DYNX(W_,740) = DYNX(DP_,80);
DYNX(W_,783) = DYNX(DP_,83);
DYNX(W_,784) = DYNX(DP_,83);
DYNX(W_,785) = DYNX(DP_,83);
DYNX(W_,786) = DYNX(DP_,84);
DYNX(W_,787) = DYNX(DP_,84);
DYNX(W_,788) = DYNX(DP_,84);
DYNX(W_,789) = DYNX(DP_,85);
DYNX(W_,790) = DYNX(DP_,85);
DYNX(W_,791) = DYNX(DP_,85);
DYNX(W_,801) = DYNX(W_,783);
DYNX(W_,802) = DYNX(W_,786);
DYNX(W_,803) = DYNX(W_,789);
DYNX(W_,811) = DYNX(W_,784);
DYNX(W_,812) = DYNX(W_,787);
DYNX(W_,813) = DYNX(W_,790);
DYNX(W_,821) = DYNX(W_,785);
DYNX(W_,822) = DYNX(W_,788);
DYNX(W_,823) = DYNX(W_,791);
DYNX(W_,839) = DYNX(DP_,86);
DYNX(W_,840) = DYNX(DP_,86);
DYNX(W_,841) = DYNX(DP_,86);
DYNX(W_,842) = DYNX(DP_,87);
DYNX(W_,843) = DYNX(DP_,87);
DYNX(W_,844) = DYNX(DP_,87);
DYNX(W_,845) = DYNX(DP_,88);
DYNX(W_,846) = DYNX(DP_,88);
DYNX(W_,847) = DYNX(DP_,88);
DYNX(W_,854) = DYNX(W_,839);
DYNX(W_,855) = DYNX(W_,842);
DYNX(W_,856) = DYNX(W_,845);
DYNX(W_,864) = DYNX(W_,840);
DYNX(W_,865) = DYNX(W_,843);
DYNX(W_,866) = DYNX(W_,846);
DYNX(W_,874) = DYNX(W_,841);
DYNX(W_,875) = DYNX(W_,844);
DYNX(W_,876) = DYNX(W_,847);
DYNX(W_,897) = DYNX(DP_,83);
DYNX(W_,898) = DYNX(DP_,83);
DYNX(W_,899) = DYNX(DP_,83);
DYNX(W_,900) = DYNX(DP_,84);
DYNX(W_,901) = DYNX(DP_,84);
DYNX(W_,902) = DYNX(DP_,84);
DYNX(W_,903) = DYNX(DP_,85);
DYNX(W_,904) = DYNX(DP_,85);
DYNX(W_,905) = DYNX(DP_,85);
DYNX(W_,915) = DYNX(W_,897);
DYNX(W_,916) = DYNX(W_,900);
DYNX(W_,917) = DYNX(W_,903);
DYNX(W_,925) = DYNX(W_,898);
DYNX(W_,926) = DYNX(W_,901);
DYNX(W_,927) = DYNX(W_,904);
DYNX(W_,935) = DYNX(W_,899);
DYNX(W_,936) = DYNX(W_,902);
DYNX(W_,937) = DYNX(W_,905);
DYNX(W_,953) = DYNX(DP_,86);
DYNX(W_,954) = DYNX(DP_,86);
DYNX(W_,955) = DYNX(DP_,86);
DYNX(W_,956) = DYNX(DP_,87);
DYNX(W_,957) = DYNX(DP_,87);
DYNX(W_,958) = DYNX(DP_,87);
DYNX(W_,959) = DYNX(DP_,88);
DYNX(W_,960) = DYNX(DP_,88);
DYNX(W_,961) = DYNX(DP_,88);
DYNX(W_,968) = DYNX(W_,953);
DYNX(W_,969) = DYNX(W_,956);
DYNX(W_,970) = DYNX(W_,959);
DYNX(W_,978) = DYNX(W_,954);
DYNX(W_,979) = DYNX(W_,957);
DYNX(W_,980) = DYNX(W_,960);
DYNX(W_,988) = DYNX(W_,955);
DYNX(W_,989) = DYNX(W_,958);
DYNX(W_,990) = DYNX(W_,961);
DYNX(W_,1025) = DYNX(DP_,101);
DYNX(W_,1026) = DYNX(DP_,102);
DYNX(W_,1027) = DYNX(DP_,103);
DYNX(W_,1035) = DYNX(DP_,104);
DYNX(W_,1036) = DYNX(DP_,105);
DYNX(W_,1037) = DYNX(DP_,106);
DYNX(W_,1046) = DYNX(DP_,110);
DYNX(W_,1053) = divinvGuarded(DYNX(DP_,111),"signalPWM1.f");
DYNX(W_,1054) = DYNX(DP_,112);
DYNX(W_,1059) = divinvGuarded(DYNX(DP_,111),"signalPWM1.f");
DYNX(W_,1062) = DYNX(DP_,112);
DYNX(W_,1067) = DYNX(DP_,122);
DYNX(W_,1068) = DYNX(DP_,123);
DYNX(W_,1069) = DYNX(DP_,124);
DYNX(W_,1070) = DYNX(DP_,125);
DYNX(W_,1374) = divGuarded(0.10177640614116878,"0.10177640614116878",
  6.283185307179586*DYNX(DP_,122),"6.283185307179586*threePhaseMotor1.aimcData.fsNominal");
DYNX(W_,1373) = DYNX(W_,1374);
DYNX(W_,1071) = DYNX(W_,1373);
DYNX(W_,1072) = DYNX(W_,1374);
DYNX(W_,1073) = DYNX(DP_,120);
DYNX(W_,1372) = DYNX(DP_,120);
DYNX(W_,1075) = DYNX(W_,1372);
DYNX(W_,1077) = DYNX(W_,1375);
DYNX(W_,1376) = divGuarded(6.283185307179586*DYNX(DP_,122),"6.283185307179586*threePhaseMotor1.aimcData.fsNominal",
  DYNX(DP_,121),"threePhaseMotor1.aimcData.p");
DYNX(W_,1078) = DYNX(W_,1376);
DYNX(W_,1079) = DYNX(DP_,127);
DYNX(W_,1377) = IF DYNX(W_,1375) <= 0 THEN 0 ELSE divGuarded(DYNX(W_,1375),
  "threePhaseMotor1.aimcData.frictionParameters.PRef",DYNX(W_,1376),
  "threePhaseMotor1.aimcData.frictionParameters.wRef");
DYNX(W_,1080) = DYNX(W_,1377);
DYNX(W_,1379) = DYNX(W_,1378)*DYNX(W_,1376);
DYNX(W_,1082) = DYNX(W_,1379);
DYNX(W_,1380) = IF DYNX(W_,1375) <= 0 THEN 0 ELSE DYNX(W_,1377)*powGuarded(
  divGuarded(DYNX(W_,1379),"threePhaseMotor1.aimcData.frictionParameters.wLinear",
  DYNX(W_,1376),"threePhaseMotor1.aimcData.frictionParameters.wRef"),
  "threePhaseMotor1.aimcData.frictionParameters.wLinear/threePhaseMotor1.aimcData.frictionParameters.wRef",
  DYNX(DP_,127),"threePhaseMotor1.aimcData.frictionParameters.power_w");
DYNX(W_,1083) = DYNX(W_,1380);
DYNX(W_,1086) = DYNX(W_,1073);
DYNX(W_,1090) = DYNX(W_,1075);
DYNX(W_,1100) = DYNX(W_,1077);
DYNX(W_,1101) = DYNX(W_,1078);
DYNX(W_,1102) = DYNX(W_,1079);
DYNX(W_,1103) = DYNX(W_,1080);
DYNX(W_,1105) = DYNX(W_,1082);
DYNX(W_,1106) = DYNX(W_,1083);
DYNX(W_,1113) = DYNX(W_,1382);
DYNX(W_,1114) = DYNX(DP_,128);
DYNX(W_,1383) = 6.283185307179586*DYNX(DP_,122);
DYNX(W_,1115) = DYNX(W_,1383);
DYNX(W_,1385) = IF DYNX(W_,1382) <= 0 THEN 0 ELSE divGuarded(divGuarded(
  DYNX(W_,1382),"threePhaseMotor1.aimcData.statorCoreParameters.PRef",sqr(
  DYNX(DP_,128)),"threePhaseMotor1.aimcData.statorCoreParameters.VRef^2"),
  "threePhaseMotor1.aimcData.statorCoreParameters.PRef/threePhaseMotor1.aimcData.statorCoreParameters.VRef^2",
  DYNX(W_,1381),"threePhaseMotor1.aimcData.statorCoreParameters.m");
DYNX(W_,1117) = DYNX(W_,1385);
DYNX(W_,1386) = 1E-06*DYNX(W_,1383);
DYNX(W_,1118) = DYNX(W_,1386);
DYNX(W_,1119) = DYNX(W_,1387);
DYNX(W_,1120) = DYNX(DP_,129);
DYNX(W_,1388) = divGuarded(6.283185307179586*DYNX(DP_,122),"6.283185307179586*threePhaseMotor1.aimcData.fsNominal",
  DYNX(DP_,121),"threePhaseMotor1.aimcData.p");
DYNX(W_,1121) = DYNX(W_,1388);
DYNX(W_,1122) = DYNX(DP_,130);
DYNX(W_,1389) = IF DYNX(W_,1387) <= 0 THEN 0 ELSE divGuarded(DYNX(W_,1387),
  "threePhaseMotor1.aimcData.strayLoadParameters.PRef",DYNX(W_,1388),
  "threePhaseMotor1.aimcData.strayLoadParameters.wRef");
DYNX(W_,1123) = DYNX(W_,1389);
DYNX(W_,1156) = DYNX(W_,1068);
DYNX(W_,1157) = DYNX(W_,1068);
DYNX(W_,1158) = DYNX(W_,1068);
DYNX(W_,1159) = DYNX(W_,1069);
DYNX(W_,1160) = DYNX(W_,1069);
DYNX(W_,1161) = DYNX(W_,1069);
DYNX(W_,1162) = divGuarded(DYNX(W_,1070),"threePhaseMotor1.aimc.alpha20s",1+
  DYNX(W_,1070)*(DYNX(W_,1069)-293.15),"1+threePhaseMotor1.aimc.alpha20s*(threePhaseMotor1.aimc.TsRef-293.15)");
DYNX(W_,1163) = divGuarded(DYNX(W_,1070),"threePhaseMotor1.aimc.alpha20s",1+
  DYNX(W_,1070)*(DYNX(W_,1069)-293.15),"1+threePhaseMotor1.aimc.alpha20s*(threePhaseMotor1.aimc.TsRef-293.15)");
DYNX(W_,1164) = divGuarded(DYNX(W_,1070),"threePhaseMotor1.aimc.alpha20s",1+
  DYNX(W_,1070)*(DYNX(W_,1069)-293.15),"1+threePhaseMotor1.aimc.alpha20s*(threePhaseMotor1.aimc.TsRef-293.15)");
DYNX(W_,1167) = DYNX(W_,1069);
DYNX(W_,1168) = DYNX(W_,1069);
DYNX(W_,1169) = DYNX(W_,1069);
DYNX(W_,1170) = DYNX(W_,1156);
DYNX(W_,1171) = DYNX(W_,1159);
DYNX(W_,1172) = DYNX(W_,1162);
DYNX(W_,1175) = DYNX(W_,1171);
DYNX(W_,1178) = DYNX(W_,1157);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(9);
DYNX(W_,1179) = DYNX(W_,1160);
DYNX(W_,1180) = DYNX(W_,1163);
DYNX(W_,1183) = DYNX(W_,1179);
DYNX(W_,1186) = DYNX(W_,1158);
DYNX(W_,1187) = DYNX(W_,1161);
DYNX(W_,1188) = DYNX(W_,1164);
DYNX(W_,1191) = DYNX(W_,1187);
DYNX(W_,1194) = DYNX(W_,1072);
DYNX(W_,1195) = DYNX(W_,1072);
DYNX(W_,1211) = DYNX(W_,1071);
DYNX(W_,1213) = DYNX(W_,1113);
DYNX(W_,1214) = DYNX(W_,1114);
DYNX(W_,1215) = DYNX(W_,1115);
DYNX(W_,1217) = DYNX(W_,1117);
DYNX(W_,1218) = DYNX(W_,1118);
DYNX(W_,1262) = DYNX(W_,1119);
DYNX(W_,1263) = DYNX(W_,1120);
DYNX(W_,1264) = DYNX(W_,1121);
DYNX(W_,1265) = DYNX(W_,1122);
DYNX(W_,1266) = DYNX(W_,1123);
DYNX(W_,1275) = DYNX(DP_,117);
DYNX(W_,1302) = DYNX(W_,1275);
AssertModelica(1+DYNX(W_,1172)*(DYNX(W_,1302)-DYNX(W_,1171)) >= 1E-15,
  "1+threePhaseMotor1.aimc.rs.resistor[1].alpha*(threePhaseMotor1.aimc.thermalAmbient.constTs.k-threePhaseMotor1.aimc.rs.resistor[1].T_ref) >= 1E-15",
   "Temperature outside scope of model!");
AssertModelica(1+DYNX(W_,1180)*(DYNX(W_,1302)-DYNX(W_,1179)) >= 1E-15,
  "1+threePhaseMotor1.aimc.rs.resistor[2].alpha*(threePhaseMotor1.aimc.thermalAmbient.constTs.k-threePhaseMotor1.aimc.rs.resistor[2].T_ref) >= 1E-15",
   "Temperature outside scope of model!");
AssertModelica(1+DYNX(W_,1188)*(DYNX(W_,1302)-DYNX(W_,1187)) >= 1E-15,
  "1+threePhaseMotor1.aimc.rs.resistor[3].alpha*(threePhaseMotor1.aimc.thermalAmbient.constTs.k-threePhaseMotor1.aimc.rs.resistor[3].T_ref) >= 1E-15",
   "Temperature outside scope of model!");
DYNX(W_,1304) = DYNX(DP_,119);
DYNX(W_,1306) = DYNX(W_,1304);
DYNX(W_,1390) = divGuarded(2.898223593858831,"2.898223593858831",
  6.283185307179586*DYNX(DP_,122),"6.283185307179586*threePhaseMotor1.aimcData.fsNominal");
DYNX(W_,1350) = DYNX(W_,1390);
DYNX(W_,1321) = DYNX(W_,1350);
DYNX(W_,1346) = DYNX(W_,1321);
DYNX(W_,1349) = DYNX(W_,1321);
DYNX(W_,1391) = divGuarded(0.10177640614116878,"0.10177640614116878",
  6.283185307179586*DYNX(DP_,122),"6.283185307179586*threePhaseMotor1.aimcData.fsNominal");
DYNX(W_,1351) = DYNX(W_,1391);
DYNX(W_,1352) = DYNX(DP_,131);
DYNX(W_,1353) = DYNX(DP_,132);
DYNX(W_,1354) = DYNX(DP_,133);
DYNX(W_,1355) = DYNX(W_,1351);
DYNX(W_,1356) = DYNX(W_,1352);
DYNX(W_,1357) = DYNX(W_,1353);
DYNX(W_,1358) = divGuarded(DYNX(W_,1354),"threePhaseMotor1.aimc.alpha20r",1+
  DYNX(W_,1354)*(DYNX(W_,1353)-293.15),"1+threePhaseMotor1.aimc.alpha20r*(threePhaseMotor1.aimc.TrRef-293.15)");
AssertModelica(1+DYNX(W_,1358)*(DYNX(W_,1306)-DYNX(W_,1357)) >= 1E-15,
  "1+threePhaseMotor1.aimc.squirrelCageR.alpha*(threePhaseMotor1.aimc.thermalAmbient.constTr.k-threePhaseMotor1.aimc.squirrelCageR.T_ref) >= 1E-15",
   "Temperature outside scope of model!");
DYNX(W_,1360) = DYNX(W_,1357);
DYNX(W_,1393) = 0.10471975511965977*DYNX(DP_,116);
DYNX(W_,1401) = divinvGuarded(DYNX(DP_,135),"signalPWM3[1].f");
DYNX(W_,1402) = DYNX(DP_,136);
DYNX(W_,1407) = divinvGuarded(DYNX(DP_,135),"signalPWM3[1].f");
DYNX(W_,1410) = DYNX(DP_,136);
DYNX(W_,1420) = divinvGuarded(DYNX(DP_,140),"signalPWM3[2].f");
DYNX(W_,1421) = DYNX(DP_,141);
DYNX(W_,1426) = divinvGuarded(DYNX(DP_,140),"signalPWM3[2].f");
DYNX(W_,1429) = DYNX(DP_,141);
DYNX(W_,1439) = divinvGuarded(DYNX(DP_,145),"signalPWM3[3].f");
DYNX(W_,1440) = DYNX(DP_,146);
DYNX(W_,1445) = divinvGuarded(DYNX(DP_,145),"signalPWM3[3].f");
DYNX(W_,1448) = DYNX(DP_,146);
DYNX(W_,1452) = DYNX(DP_,153);
DYNX(W_,1453) = DYNX(DP_,152);
DYNX(W_,1458) = DYNX(DP_,151);
DYNX(W_,1460) = DYNX(DP_,154);
DYNX(W_,1526) = DYNX(DP_,160);
DYNX(W_,1568) = DYNX(W_,1526);
DYNX(W_,1572) = real2integer(divideDymola(DYNX(W_,1568), DYNX(W_,1570)));
DYNX(W_,1580) = DYNX(W_,1572)*DYNX(DP_,183)*DYNX(DP_,184);
DYNX(W_,1535) = DYNX(W_,1580);
DYNX(W_,1480) = DYNX(W_,1535);
DYNX(W_,1533) = DYNX(DP_,163);
DYNX(W_,1537) = DYNX(DP_,164);
DYNX(W_,1539) = DYNX(DP_,165);
DYNX(W_,1541) = DYNX(DP_,166);
DYNX(W_,1543) = DYNX(DP_,167);
DYNX(W_,1576) = DYNX(W_,1533);
DYNX(W_,1577) = DYNX(W_,1580)/(double)(2);
DYNX(W_,1579) = DYNX(DP_,170);
DYNX(W_,1582) = DYNX(DP_,171);
DYNX(W_,1583) = DYNX(DP_,172);
DYNX(W_,1584) = DYNX(DP_,173);
DYNX(W_,1585) = DYNX(W_,1537);
DYNX(W_,1614) = DYNX(DP_,170);
DYNX(W_,1626) = DYNX(DP_,191);
DYNX(W_,1635) = DYNX(DP_,195)-DYNX(DP_,196);
DYNX(W_,1646) = DYNX(DP_,170);
DYNX(W_,1651) = DYNX(DP_,199);
DYNX(W_,1652) = DYNX(DP_,200);
DYNX(W_,1658) = DYNX(W_,1646);
DYNX(W_,1525) = DYNX(DP_,159);
AssertModelica(DYNX(W_,1525) >= 1,"batteryPack.core.ns >= 1", "The number of grouped cells in series, gs, must be less than or equal to the actual number of cells in series, ns.");
AssertModelica(real2integer(modulusDymola(DYNX(W_,1525), 1)) == 0,
  "mod(batteryPack.core.ns, 1) == 0", "The actual number of cells in series, ns, must be an even multiple of the number of grouped cells in series, gs.");
DYNX(W_,1639) = DYNX(W_,1525);
AssertModelica(DYNX(W_,1639) >= 1,"batteryPack.core.impedance.ns >= 1", 
  "The number of grouped cells in series, gs, must be less than or equal to the actual number of cells in series, ns.");
AssertModelica(real2integer(modulusDymola(DYNX(W_,1639), 1)) == 0,
  "mod(batteryPack.core.impedance.ns, 1) == 0", "The actual number of cells in series, ns, must be an even multiple of the number of grouped cells in series, gs.");
DYNX(W_,1643) = real2integer(divideDymola(DYNX(W_,1639), DYNX(W_,1641)));
DYNX(W_,1640) = DYNX(W_,1526);
DYNX(W_,1644) = real2integer(divideDymola(DYNX(W_,1640), DYNX(W_,1642)));
DYNX(W_,1662) = divGuarded(DYNX(DP_,198)*DYNX(DP_,197)*DYNX(W_,1643),
  "batteryPack.core.impedance.k_R*batteryPack.core.impedance.R0*batteryPack.core.impedance.ngs",
  DYNX(W_,1644),"batteryPack.core.impedance.ngp");
DYNX(W_,1673) = DYNX(DP_,170);
DYNX(W_,1690) = DYNX(DP_,170);
DYNX(W_,1703) = DYNX(W_,1539);
DYNX(W_,1729) = DYNX(W_,1541);
DYNX(W_,1738) = DYNX(W_,1543);
DYNX(W_,1774) = DYNX(DP_,159);
AssertModelica(DYNX(W_,1774) >= 1,"batteryPack.thermal.ns >= 1", 
  "The number of grouped cells in series, gs, must be less than or equal to the actual number of cells in series, ns.");
AssertModelica(real2integer(modulusDymola(DYNX(W_,1774), 1)) == 0,
  "mod(batteryPack.thermal.ns, 1) == 0", "The actual number of cells in series, ns, must be an even multiple of the number of grouped cells in series, gs.");
DYNX(W_,1775) = DYNX(DP_,160);
DYNX(W_,1822) = IF DYNX(DP_,237) THEN DYNX(DP_,239)*DYNX(W_,1774)*DYNX(W_,1775)
   ELSE DYNX(DP_,238);
DYNX(W_,1827) = DYNX(DP_,236);
DYNX(W_,1828) = DYNX(W_,1822);
DYNX(W_,1831) = DYNX(DP_,218);
DYNX(W_,1847) = DYNX(DP_,168);
DYNX(W_,1855) = DYNX(DP_,242);
DYNX(W_,1857) = DYNX(DP_,245);
DYNX(W_,1860) = DYNX(DP_,243);
AssertModelica(1+DYNX(DP_,244)*(DYNX(W_,1860)-DYNX(DP_,243)) >= 1E-15,
  "1+simpleLine2.resistor.alpha*(simpleLine2.resistor.T-simpleLine2.resistor.T_ref) >= 1E-15",
   "Temperature outside scope of model!");
DYNX(W_,1866) = DYNX(DP_,246);
DYNX(W_,1868) = DYNX(DP_,249);
DYNX(W_,1871) = DYNX(DP_,247);
AssertModelica(1+DYNX(DP_,248)*(DYNX(W_,1871)-DYNX(DP_,247)) >= 1E-15,
  "1+simpleLine3.resistor.alpha*(simpleLine3.resistor.T-simpleLine3.resistor.T_ref) >= 1E-15",
   "Temperature outside scope of model!");
DYNX(W_,1885) = DYNX(DP_,255);
DYNX(W_,1884) = DYNX(W_,1885);
DYNX(W_,1900) = DYNX(DP_,261);
DYNX(W_,1899) = DYNX(W_,1900);
DYNX(W_,1912) = DYNX(DP_,267);
DYNX(W_,1911) = DYNX(W_,1912);
DYNX(W_,1923) = DYNX(DP_,273);
DYNX(W_,1922) = DYNX(W_,1923);
DYNX(W_,1924) = DYNX(DP_,278)/(double)(2);
DYNX(W_,1926) = DYNX(DP_,276);
DYNX(W_,1929) = DYNX(DP_,274);
AssertModelica(1+DYNX(DP_,275)*(DYNX(W_,1929)-DYNX(DP_,274)) >= 1E-15,
  "1+simplifiedFuelCell1.resistor.alpha*(simplifiedFuelCell1.resistor.T-simplifiedFuelCell1.resistor.T_ref) >= 1E-15",
   "Temperature outside scope of model!");
DYNX(W_,1934) = DYNX(DP_,278)/(double)(2);
DYNX(W_,1938) = DYNX(DP_,276);
DYNX(W_,1941) = DYNX(DP_,279);
AssertModelica(1+DYNX(DP_,280)*(DYNX(W_,1941)-DYNX(DP_,279)) >= 1E-15,
  "1+simplifiedFuelCell1.resistor1.alpha*(simplifiedFuelCell1.resistor1.T-simplifiedFuelCell1.resistor1.T_ref) >= 1E-15",
   "Temperature outside scope of model!");
DYNX(W_,1989) = DYNX(DP_,282);
DYNX(W_,1990) = DYNX(DP_,282);
DYNX(W_,1991) = DYNX(DP_,282);
DYNX(W_,1992) = DYNX(DP_,283);
DYNX(W_,1993) = DYNX(DP_,283);
DYNX(W_,1994) = DYNX(DP_,283);
DYNX(W_,1995) = DYNX(DP_,284);
DYNX(W_,1996) = DYNX(DP_,284);
DYNX(W_,1997) = DYNX(DP_,284);
DYNX(W_,2007) = DYNX(W_,1989);
DYNX(W_,2008) = DYNX(W_,1992);
DYNX(W_,2009) = DYNX(W_,1995);
DYNX(W_,2017) = DYNX(W_,1990);
DYNX(W_,2018) = DYNX(W_,1993);
DYNX(W_,2019) = DYNX(W_,1996);
DYNX(W_,2027) = DYNX(W_,1991);
DYNX(W_,2028) = DYNX(W_,1994);
DYNX(W_,2029) = DYNX(W_,1997);
DYNX(W_,2045) = DYNX(DP_,285);
DYNX(W_,2046) = DYNX(DP_,285);
DYNX(W_,2047) = DYNX(DP_,285);
DYNX(W_,2048) = DYNX(DP_,286);
DYNX(W_,2049) = DYNX(DP_,286);
DYNX(W_,2050) = DYNX(DP_,286);
DYNX(W_,2051) = DYNX(DP_,287);
DYNX(W_,2052) = DYNX(DP_,287);
DYNX(W_,2053) = DYNX(DP_,287);
DYNX(W_,2060) = DYNX(W_,2045);
DYNX(W_,2061) = DYNX(W_,2048);
DYNX(W_,2062) = DYNX(W_,2051);
DYNX(W_,2070) = DYNX(W_,2046);
DYNX(W_,2071) = DYNX(W_,2049);
DYNX(W_,2072) = DYNX(W_,2052);
DYNX(W_,2080) = DYNX(W_,2047);
DYNX(W_,2081) = DYNX(W_,2050);
DYNX(W_,2082) = DYNX(W_,2053);
DYNX(W_,2103) = DYNX(DP_,282);
DYNX(W_,2104) = DYNX(DP_,282);
DYNX(W_,2105) = DYNX(DP_,282);
DYNX(W_,2106) = DYNX(DP_,283);
DYNX(W_,2107) = DYNX(DP_,283);
DYNX(W_,2108) = DYNX(DP_,283);
DYNX(W_,2109) = DYNX(DP_,284);
DYNX(W_,2110) = DYNX(DP_,284);
DYNX(W_,2111) = DYNX(DP_,284);
DYNX(W_,2121) = DYNX(W_,2103);
DYNX(W_,2122) = DYNX(W_,2106);
DYNX(W_,2123) = DYNX(W_,2109);
DYNX(W_,2131) = DYNX(W_,2104);
DYNX(W_,2132) = DYNX(W_,2107);
DYNX(W_,2133) = DYNX(W_,2110);
DYNX(W_,2141) = DYNX(W_,2105);
DYNX(W_,2142) = DYNX(W_,2108);
DYNX(W_,2143) = DYNX(W_,2111);
DYNX(W_,2159) = DYNX(DP_,285);
DYNX(W_,2160) = DYNX(DP_,285);
DYNX(W_,2161) = DYNX(DP_,285);
DYNX(W_,2162) = DYNX(DP_,286);
DYNX(W_,2163) = DYNX(DP_,286);
DYNX(W_,2164) = DYNX(DP_,286);
DYNX(W_,2165) = DYNX(DP_,287);
DYNX(W_,2166) = DYNX(DP_,287);
DYNX(W_,2167) = DYNX(DP_,287);
DYNX(W_,2174) = DYNX(W_,2159);
DYNX(W_,2175) = DYNX(W_,2162);
DYNX(W_,2176) = DYNX(W_,2165);
DYNX(W_,2184) = DYNX(W_,2160);
DYNX(W_,2185) = DYNX(W_,2163);
DYNX(W_,2186) = DYNX(W_,2166);
DYNX(W_,2194) = DYNX(W_,2161);
DYNX(W_,2195) = DYNX(W_,2164);
DYNX(W_,2196) = DYNX(W_,2167);
DYNX(W_,2228) = DYNX(DP_,300);
DYNX(W_,2229) = DYNX(DP_,301);
DYNX(W_,2230) = DYNX(DP_,302);
DYNX(W_,2238) = DYNX(DP_,303);
DYNX(W_,2239) = DYNX(DP_,304);
DYNX(W_,2240) = DYNX(DP_,305);
DYNX(W_,2249) = DYNX(DP_,309);
DYNX(W_,2256) = divinvGuarded(DYNX(DP_,310),"signalPWM4.f");
DYNX(W_,2257) = DYNX(DP_,311);
DYNX(W_,2262) = divinvGuarded(DYNX(DP_,310),"signalPWM4.f");
DYNX(W_,2265) = DYNX(DP_,311);
DYNX(W_,2270) = DYNX(DP_,321);
DYNX(W_,2271) = DYNX(DP_,322);
DYNX(W_,2272) = DYNX(DP_,323);
DYNX(W_,2273) = DYNX(DP_,324);
DYNX(W_,2577) = divGuarded(0.10177640614116878,"0.10177640614116878",
  6.283185307179586*DYNX(DP_,321),"6.283185307179586*threePhaseMotor2.aimcData.fsNominal");
DYNX(W_,2576) = DYNX(W_,2577);
DYNX(W_,2274) = DYNX(W_,2576);
DYNX(W_,2275) = DYNX(W_,2577);
DYNX(W_,2276) = DYNX(DP_,319);
DYNX(W_,2575) = DYNX(DP_,319);
DYNX(W_,2278) = DYNX(W_,2575);
DYNX(W_,2280) = DYNX(W_,2578);
DYNX(W_,2579) = divGuarded(6.283185307179586*DYNX(DP_,321),"6.283185307179586*threePhaseMotor2.aimcData.fsNominal",
  DYNX(DP_,320),"threePhaseMotor2.aimcData.p");
DYNX(W_,2281) = DYNX(W_,2579);
DYNX(W_,2282) = DYNX(DP_,326);
DYNX(W_,2580) = IF DYNX(W_,2578) <= 0 THEN 0 ELSE divGuarded(DYNX(W_,2578),
  "threePhaseMotor2.aimcData.frictionParameters.PRef",DYNX(W_,2579),
  "threePhaseMotor2.aimcData.frictionParameters.wRef");
DYNX(W_,2283) = DYNX(W_,2580);
DYNX(W_,2582) = DYNX(W_,2581)*DYNX(W_,2579);
DYNX(W_,2285) = DYNX(W_,2582);
DYNX(W_,2583) = IF DYNX(W_,2578) <= 0 THEN 0 ELSE DYNX(W_,2580)*powGuarded(
  divGuarded(DYNX(W_,2582),"threePhaseMotor2.aimcData.frictionParameters.wLinear",
  DYNX(W_,2579),"threePhaseMotor2.aimcData.frictionParameters.wRef"),
  "threePhaseMotor2.aimcData.frictionParameters.wLinear/threePhaseMotor2.aimcData.frictionParameters.wRef",
  DYNX(DP_,326),"threePhaseMotor2.aimcData.frictionParameters.power_w");
DYNX(W_,2286) = DYNX(W_,2583);
DYNX(W_,2289) = DYNX(W_,2276);
DYNX(W_,2293) = DYNX(W_,2278);
DYNX(W_,2303) = DYNX(W_,2280);
DYNX(W_,2304) = DYNX(W_,2281);
DYNX(W_,2305) = DYNX(W_,2282);
DYNX(W_,2306) = DYNX(W_,2283);
DYNX(W_,2308) = DYNX(W_,2285);
DYNX(W_,2309) = DYNX(W_,2286);
DYNX(W_,2316) = DYNX(W_,2585);
DYNX(W_,2317) = DYNX(DP_,327);
DYNX(W_,2586) = 6.283185307179586*DYNX(DP_,321);
DYNX(W_,2318) = DYNX(W_,2586);
DYNX(W_,2588) = IF DYNX(W_,2585) <= 0 THEN 0 ELSE divGuarded(divGuarded(
  DYNX(W_,2585),"threePhaseMotor2.aimcData.statorCoreParameters.PRef",sqr(
  DYNX(DP_,327)),"threePhaseMotor2.aimcData.statorCoreParameters.VRef^2"),
  "threePhaseMotor2.aimcData.statorCoreParameters.PRef/threePhaseMotor2.aimcData.statorCoreParameters.VRef^2",
  DYNX(W_,2584),"threePhaseMotor2.aimcData.statorCoreParameters.m");
DYNX(W_,2320) = DYNX(W_,2588);
DYNX(W_,2589) = 1E-06*DYNX(W_,2586);
DYNX(W_,2321) = DYNX(W_,2589);
DYNX(W_,2322) = DYNX(W_,2590);
DYNX(W_,2323) = DYNX(DP_,328);
DYNX(W_,2591) = divGuarded(6.283185307179586*DYNX(DP_,321),"6.283185307179586*threePhaseMotor2.aimcData.fsNominal",
  DYNX(DP_,320),"threePhaseMotor2.aimcData.p");
DYNX(W_,2324) = DYNX(W_,2591);
DYNX(W_,2325) = DYNX(DP_,329);
DYNX(W_,2592) = IF DYNX(W_,2590) <= 0 THEN 0 ELSE divGuarded(DYNX(W_,2590),
  "threePhaseMotor2.aimcData.strayLoadParameters.PRef",DYNX(W_,2591),
  "threePhaseMotor2.aimcData.strayLoadParameters.wRef");
DYNX(W_,2326) = DYNX(W_,2592);
DYNX(W_,2359) = DYNX(W_,2271);
DYNX(W_,2360) = DYNX(W_,2271);
DYNX(W_,2361) = DYNX(W_,2271);
DYNX(W_,2362) = DYNX(W_,2272);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(10);
DYNX(W_,2363) = DYNX(W_,2272);
DYNX(W_,2364) = DYNX(W_,2272);
DYNX(W_,2365) = divGuarded(DYNX(W_,2273),"threePhaseMotor2.aimc.alpha20s",1+
  DYNX(W_,2273)*(DYNX(W_,2272)-293.15),"1+threePhaseMotor2.aimc.alpha20s*(threePhaseMotor2.aimc.TsRef-293.15)");
DYNX(W_,2366) = divGuarded(DYNX(W_,2273),"threePhaseMotor2.aimc.alpha20s",1+
  DYNX(W_,2273)*(DYNX(W_,2272)-293.15),"1+threePhaseMotor2.aimc.alpha20s*(threePhaseMotor2.aimc.TsRef-293.15)");
DYNX(W_,2367) = divGuarded(DYNX(W_,2273),"threePhaseMotor2.aimc.alpha20s",1+
  DYNX(W_,2273)*(DYNX(W_,2272)-293.15),"1+threePhaseMotor2.aimc.alpha20s*(threePhaseMotor2.aimc.TsRef-293.15)");
DYNX(W_,2370) = DYNX(W_,2272);
DYNX(W_,2371) = DYNX(W_,2272);
DYNX(W_,2372) = DYNX(W_,2272);
DYNX(W_,2373) = DYNX(W_,2359);
DYNX(W_,2374) = DYNX(W_,2362);
DYNX(W_,2375) = DYNX(W_,2365);
DYNX(W_,2378) = DYNX(W_,2374);
DYNX(W_,2381) = DYNX(W_,2360);
DYNX(W_,2382) = DYNX(W_,2363);
DYNX(W_,2383) = DYNX(W_,2366);
DYNX(W_,2386) = DYNX(W_,2382);
DYNX(W_,2389) = DYNX(W_,2361);
DYNX(W_,2390) = DYNX(W_,2364);
DYNX(W_,2391) = DYNX(W_,2367);
DYNX(W_,2394) = DYNX(W_,2390);
DYNX(W_,2397) = DYNX(W_,2275);
DYNX(W_,2398) = DYNX(W_,2275);
DYNX(W_,2414) = DYNX(W_,2274);
DYNX(W_,2416) = DYNX(W_,2316);
DYNX(W_,2417) = DYNX(W_,2317);
DYNX(W_,2418) = DYNX(W_,2318);
DYNX(W_,2420) = DYNX(W_,2320);
DYNX(W_,2421) = DYNX(W_,2321);
DYNX(W_,2465) = DYNX(W_,2322);
DYNX(W_,2466) = DYNX(W_,2323);
DYNX(W_,2467) = DYNX(W_,2324);
DYNX(W_,2468) = DYNX(W_,2325);
DYNX(W_,2469) = DYNX(W_,2326);
DYNX(W_,2478) = DYNX(DP_,316);
DYNX(W_,2505) = DYNX(W_,2478);
AssertModelica(1+DYNX(W_,2375)*(DYNX(W_,2505)-DYNX(W_,2374)) >= 1E-15,
  "1+threePhaseMotor2.aimc.rs.resistor[1].alpha*(threePhaseMotor2.aimc.thermalAmbient.constTs.k-threePhaseMotor2.aimc.rs.resistor[1].T_ref) >= 1E-15",
   "Temperature outside scope of model!");
AssertModelica(1+DYNX(W_,2383)*(DYNX(W_,2505)-DYNX(W_,2382)) >= 1E-15,
  "1+threePhaseMotor2.aimc.rs.resistor[2].alpha*(threePhaseMotor2.aimc.thermalAmbient.constTs.k-threePhaseMotor2.aimc.rs.resistor[2].T_ref) >= 1E-15",
   "Temperature outside scope of model!");
AssertModelica(1+DYNX(W_,2391)*(DYNX(W_,2505)-DYNX(W_,2390)) >= 1E-15,
  "1+threePhaseMotor2.aimc.rs.resistor[3].alpha*(threePhaseMotor2.aimc.thermalAmbient.constTs.k-threePhaseMotor2.aimc.rs.resistor[3].T_ref) >= 1E-15",
   "Temperature outside scope of model!");
DYNX(W_,2507) = DYNX(DP_,318);
DYNX(W_,2509) = DYNX(W_,2507);
DYNX(W_,2593) = divGuarded(2.898223593858831,"2.898223593858831",
  6.283185307179586*DYNX(DP_,321),"6.283185307179586*threePhaseMotor2.aimcData.fsNominal");
DYNX(W_,2553) = DYNX(W_,2593);
DYNX(W_,2524) = DYNX(W_,2553);
DYNX(W_,2549) = DYNX(W_,2524);
DYNX(W_,2552) = DYNX(W_,2524);
DYNX(W_,2594) = divGuarded(0.10177640614116878,"0.10177640614116878",
  6.283185307179586*DYNX(DP_,321),"6.283185307179586*threePhaseMotor2.aimcData.fsNominal");
DYNX(W_,2554) = DYNX(W_,2594);
DYNX(W_,2555) = DYNX(DP_,330);
DYNX(W_,2556) = DYNX(DP_,331);
DYNX(W_,2557) = DYNX(DP_,332);
DYNX(W_,2558) = DYNX(W_,2554);
DYNX(W_,2559) = DYNX(W_,2555);
DYNX(W_,2560) = DYNX(W_,2556);
DYNX(W_,2561) = divGuarded(DYNX(W_,2557),"threePhaseMotor2.aimc.alpha20r",1+
  DYNX(W_,2557)*(DYNX(W_,2556)-293.15),"1+threePhaseMotor2.aimc.alpha20r*(threePhaseMotor2.aimc.TrRef-293.15)");
AssertModelica(1+DYNX(W_,2561)*(DYNX(W_,2509)-DYNX(W_,2560)) >= 1E-15,
  "1+threePhaseMotor2.aimc.squirrelCageR.alpha*(threePhaseMotor2.aimc.thermalAmbient.constTr.k-threePhaseMotor2.aimc.squirrelCageR.T_ref) >= 1E-15",
   "Temperature outside scope of model!");
DYNX(W_,2563) = DYNX(W_,2560);
DYNX(W_,2596) = 0.10471975511965977*DYNX(DP_,315);
DYNX(W_,2604) = divinvGuarded(DYNX(DP_,334),"signalPWM5[1].f");
DYNX(W_,2605) = DYNX(DP_,335);
DYNX(W_,2610) = divinvGuarded(DYNX(DP_,334),"signalPWM5[1].f");
DYNX(W_,2613) = DYNX(DP_,335);
DYNX(W_,2623) = divinvGuarded(DYNX(DP_,339),"signalPWM5[2].f");
DYNX(W_,2624) = DYNX(DP_,340);
DYNX(W_,2629) = divinvGuarded(DYNX(DP_,339),"signalPWM5[2].f");
DYNX(W_,2632) = DYNX(DP_,340);
DYNX(W_,2642) = divinvGuarded(DYNX(DP_,344),"signalPWM5[3].f");
DYNX(W_,2643) = DYNX(DP_,345);
DYNX(W_,2648) = divinvGuarded(DYNX(DP_,344),"signalPWM5[3].f");
DYNX(W_,2651) = DYNX(DP_,345);
DYNX(W_,2655) = DYNX(DP_,352);
DYNX(W_,2656) = DYNX(DP_,351);
DYNX(W_,2661) = DYNX(DP_,350);
DYNX(W_,2663) = DYNX(DP_,353);
DYNX(W_,2667) = DYNX(DP_,356);
AssertModelica(1+DYNX(DP_,357)*(DYNX(W_,2667)-DYNX(DP_,356)) >= 1E-15,
  "1+resistor.alpha*(resistor.T-resistor.T_ref) >= 1E-15", "Temperature outside scope of model!");
DYNX(W_,2672) = DYNX(DP_,359);
AssertModelica(1+DYNX(DP_,360)*(DYNX(W_,2672)-DYNX(DP_,359)) >= 1E-15,
  "1+resistor1.alpha*(resistor1.T-resistor1.T_ref) >= 1E-15", "Temperature outside scope of model!");
DYNX(W_,346) = DYNX(DP_,47);
DYNX(W_,603) = DYNX(W_,346);
DYNX(W_,1066) = DYNX(DP_,121);
DYNX(W_,1323) = DYNX(W_,1066);
DYNX(W_,1475) = real2integer(divideDymola(DYNX(DP_,159), 1));
DYNX(W_,1476) = real2integer(divideDymola(DYNX(DP_,160), 1));
DYNX(W_,1488) = DYNX(DP_,159);
DYNX(W_,1489) = DYNX(DP_,160);
DYNX(W_,1492) = real2integer(divideDymola(DYNX(W_,1488), DYNX(W_,1490)));
DYNX(W_,1493) = real2integer(divideDymola(DYNX(W_,1489), DYNX(W_,1491)));
DYNX(W_,1516) = DYNX(DP_,159);
DYNX(W_,1517) = DYNX(DP_,160);
DYNX(W_,1520) = real2integer(divideDymola(DYNX(W_,1516), DYNX(W_,1518)));
DYNX(W_,1521) = real2integer(divideDymola(DYNX(W_,1517), DYNX(W_,1519)));
DYNX(W_,1522) = DYNX(DP_,219);
DYNX(W_,1523) = DYNX(DP_,220);
DYNX(W_,1524) = DYNX(DP_,221);
DYNX(W_,1529) = real2integer(divideDymola(DYNX(W_,1525), DYNX(W_,1527)));
DYNX(W_,1530) = real2integer(divideDymola(DYNX(W_,1526), DYNX(W_,1528)));
DYNX(W_,1536) = DYNX(W_,1483);
DYNX(W_,1538) = DYNX(W_,1484);
DYNX(W_,1540) = DYNX(W_,1485);
DYNX(W_,1542) = DYNX(W_,1486);
DYNX(W_,1547) = DYNX(W_,1525);
DYNX(W_,1548) = DYNX(W_,1526);
DYNX(W_,1551) = real2integer(divideDymola(DYNX(W_,1547), DYNX(W_,1549)));
DYNX(W_,1552) = real2integer(divideDymola(DYNX(W_,1548), DYNX(W_,1550)));
DYNX(W_,1567) = DYNX(W_,1525);
AssertModelica(DYNX(W_,1567) >= 1,"batteryPack.core.capacity.ns >= 1", 
  "The number of grouped cells in series, gs, must be less than or equal to the actual number of cells in series, ns.");
AssertModelica(real2integer(modulusDymola(DYNX(W_,1567), 1)) == 0,
  "mod(batteryPack.core.capacity.ns, 1) == 0", "The actual number of cells in series, ns, must be an even multiple of the number of grouped cells in series, gs.");
DYNX(W_,1571) = real2integer(divideDymola(DYNX(W_,1567), DYNX(W_,1569)));
DYNX(W_,1581) = DYNX(W_,1536);
DYNX(W_,1600) = DYNX(W_,1581);
DYNX(W_,1604) = IF DYNX(W_,1600) == 3 THEN 1 ELSE 2;
DYNX(W_,1607) = DYNX(W_,1525);
AssertModelica(DYNX(W_,1607) >= 1,"batteryPack.core.voltage.ns >= 1", 
  "The number of grouped cells in series, gs, must be less than or equal to the actual number of cells in series, ns.");
AssertModelica(real2integer(modulusDymola(DYNX(W_,1607), 1)) == 0,
  "mod(batteryPack.core.voltage.ns, 1) == 0", "The actual number of cells in series, ns, must be an even multiple of the number of grouped cells in series, gs.");
DYNX(W_,1608) = DYNX(W_,1526);
DYNX(W_,1611) = real2integer(divideDymola(DYNX(W_,1607), DYNX(W_,1609)));
DYNX(W_,1612) = real2integer(divideDymola(DYNX(W_,1608), DYNX(W_,1610)));
DYNX(W_,1625) = DYNX(W_,1617);
DYNX(W_,1630) = IF DYNX(W_,1625) == 3 THEN 1 ELSE 2;
DYNX(W_,1666) = DYNX(W_,1525);
AssertModelica(DYNX(W_,1666) >= 1,"batteryPack.core.selfDischarge.ns >= 1", 
  "The number of grouped cells in series, gs, must be less than or equal to the actual number of cells in series, ns.");
AssertModelica(real2integer(modulusDymola(DYNX(W_,1666), 1)) == 0,
  "mod(batteryPack.core.selfDischarge.ns, 1) == 0", "The actual number of cells in series, ns, must be an even multiple of the number of grouped cells in series, gs.");
DYNX(W_,1667) = DYNX(W_,1526);
DYNX(W_,1670) = real2integer(divideDymola(DYNX(W_,1666), DYNX(W_,1668)));
DYNX(W_,1671) = real2integer(divideDymola(DYNX(W_,1667), DYNX(W_,1669)));
DYNX(W_,1683) = DYNX(W_,1525);
AssertModelica(DYNX(W_,1683) >= 1,"batteryPack.core.aging.ns >= 1", 
  "The number of grouped cells in series, gs, must be less than or equal to the actual number of cells in series, ns.");
AssertModelica(real2integer(modulusDymola(DYNX(W_,1683), 1)) == 0,
  "mod(batteryPack.core.aging.ns, 1) == 0", "The actual number of cells in series, ns, must be an even multiple of the number of grouped cells in series, gs.");
DYNX(W_,1684) = DYNX(W_,1526);
DYNX(W_,1687) = real2integer(divideDymola(DYNX(W_,1683), DYNX(W_,1685)));
DYNX(W_,1688) = real2integer(divideDymola(DYNX(W_,1684), DYNX(W_,1686)));
DYNX(W_,1702) = DYNX(W_,1538);
DYNX(W_,1707) = IF DYNX(W_,1702) == 3 THEN 1 ELSE 2;
DYNX(W_,1708) = DYNX(W_,1525);
AssertModelica(DYNX(W_,1708) >= 1,"batteryPack.core.sensors.ns >= 1", 
  "The number of grouped cells in series, gs, must be less than or equal to the actual number of cells in series, ns.");
AssertModelica(real2integer(modulusDymola(DYNX(W_,1708), 1)) == 0,
  "mod(batteryPack.core.sensors.ns, 1) == 0", "The actual number of cells in series, ns, must be an even multiple of the number of grouped cells in series, gs.");
DYNX(W_,1709) = DYNX(W_,1526);
DYNX(W_,1712) = real2integer(divideDymola(DYNX(W_,1708), DYNX(W_,1710)));
DYNX(W_,1713) = real2integer(divideDymola(DYNX(W_,1709), DYNX(W_,1711)));
DYNX(W_,1728) = DYNX(W_,1540);
DYNX(W_,1733) = IF DYNX(W_,1728) == 3 THEN 1 ELSE 2;
DYNX(W_,1737) = DYNX(W_,1542);
DYNX(W_,1742) = IF DYNX(W_,1737) == 3 THEN 1 ELSE 2;
DYNX(W_,1778) = real2integer(divideDymola(DYNX(W_,1774), 1));
DYNX(W_,1779) = real2integer(divideDymola(DYNX(W_,1775), 1));
DYNX(W_,1785) = DYNX(W_,1774);
DYNX(W_,1786) = DYNX(W_,1775);
DYNX(W_,1789) = real2integer(divideDymola(DYNX(W_,1785), DYNX(W_,1787)));
DYNX(W_,1790) = real2integer(divideDymola(DYNX(W_,1786), DYNX(W_,1788)));
DYNX(W_,1800) = real2integer(divideDymola(DYNX(DP_,222), DYNX(DP_,224)));
DYNX(W_,1801) = real2integer(divideDymola(DYNX(DP_,223), DYNX(DP_,225)));
DYNX(W_,1804) = real2integer(divideDymola(DYNX(DP_,229), DYNX(DP_,231)));
DYNX(W_,1805) = real2integer(divideDymola(DYNX(DP_,230), DYNX(DP_,232)));
DYNX(W_,1807) = DYNX(W_,1774);
AssertModelica(DYNX(W_,1807) >= 1,"batteryPack.thermal.sensors.ns >= 1", 
  "The number of grouped cells in series, gs, must be less than or equal to the actual number of cells in series, ns.");
AssertModelica(real2integer(modulusDymola(DYNX(W_,1807), 1)) == 0,
  "mod(batteryPack.thermal.sensors.ns, 1) == 0", "The actual number of cells in series, ns, must be an even multiple of the number of grouped cells in series, gs.");
DYNX(W_,1808) = DYNX(W_,1775);
DYNX(W_,1811) = real2integer(divideDymola(DYNX(W_,1807), 1));
DYNX(W_,1812) = real2integer(divideDymola(DYNX(W_,1808), 1));
DYNX(W_,1813) = DYNX(W_,1774);
DYNX(W_,1814) = DYNX(W_,1775);
DYNX(W_,1817) = real2integer(divideDymola(DYNX(W_,1813), DYNX(W_,1815)));
DYNX(W_,1818) = real2integer(divideDymola(DYNX(W_,1814), DYNX(W_,1816)));
DYNX(W_,1819) = DYNX(DP_,219);
DYNX(W_,1820) = DYNX(DP_,220);
DYNX(W_,1821) = DYNX(DP_,221);
DYNX(W_,1833) = DYNX(DP_,157);
DYNX(W_,1834) = DYNX(DP_,159);
AssertModelica(DYNX(W_,1834) >= 1,"batteryPack.controller.ns >= 1", 
  "The number of grouped cells in series, gs, must be less than or equal to the actual number of cells in series, ns.");
AssertModelica(real2integer(modulusDymola(DYNX(W_,1834), 1)) == 0,
  "mod(batteryPack.controller.ns, 1) == 0", "The actual number of cells in series, ns, must be an even multiple of the number of grouped cells in series, gs.");
DYNX(W_,1835) = DYNX(DP_,160);
DYNX(W_,1838) = real2integer(divideDymola(DYNX(W_,1834), 1));
DYNX(W_,1839) = real2integer(divideDymola(DYNX(W_,1835), 1));
DYNX(W_,1846) = DYNX(W_,1487);
DYNX(W_,1851) = IF DYNX(W_,1846) == 3 THEN 1 ELSE 2;
DYNX(W_,2269) = DYNX(DP_,320);
DYNX(W_,2526) = DYNX(W_,2269);
DYNX(W_,29) = DYNX(DP_,8);
DYNX(W_,31) = DYNX(W_,29);
DYNX(W_,297) = DYNX(DP_,33);
DYNX(W_,299) = DYNX(W_,297);
DYNX(W_,748) = DYNX(DP_,82);
DYNX(W_,750) = DYNX(W_,748);
DYNX(W_,1018) = DYNX(DP_,107);
DYNX(W_,1020) = DYNX(W_,1018);
DYNX(W_,1532) = DYNX(W_,1481);
DYNX(W_,1573) =  NOT DYNX(W_,1532);
DYNX(W_,1615) = DYNX(W_,1532);
DYNX(W_,1952) = DYNX(DP_,281);
DYNX(W_,1954) = DYNX(W_,1952);
DYNX(W_,2220) = DYNX(DP_,306);
DYNX(W_,2222) = DYNX(W_,2220);
DYNX(W_,1601) = IF DYNX(DP_,185) THEN DYNX(DP_,186) ELSE DYNTime;
DYNX(W_,1627) = IF DYNX(DP_,193) THEN DYNX(W_,1626) ELSE DYNTime;
DYNX(W_,1704) = IF DYNX(DP_,211) THEN DYNX(W_,1703) ELSE DYNTime;
DYNX(W_,1730) = IF DYNX(DP_,214) THEN DYNX(W_,1729) ELSE DYNTime;
DYNX(W_,1739) = IF DYNX(DP_,216) THEN DYNX(W_,1738) ELSE DYNTime;
DYNX(W_,1848) = IF DYNX(DP_,240) THEN DYNX(W_,1847) ELSE DYNTime;
  DYNX(W_,344) = real2integerEvent(divGuarded(DYNTime-DYNX(W_,342),
    "time-signalPWM2.sawtooth.startTime",DYNX(W_,339),"signalPWM2.sawtooth.period"),
    "(time-signalPWM2.sawtooth.startTime)/signalPWM2.sawtooth.period", 0);
  DYNX(W_,343) = DYNX(W_,342)+DYNX(W_,344)*DYNX(W_,339);
  DYNX(W_,711) = real2integerEvent(divGuarded(DYNTime-DYNX(W_,709),
    "time-signalPWM[2].sawtooth.startTime",DYNX(W_,706),"signalPWM[2].sawtooth.period"),
    "(time-signalPWM[2].sawtooth.startTime)/signalPWM[2].sawtooth.period", 1);
  DYNX(W_,710) = DYNX(W_,709)+DYNX(W_,711)*DYNX(W_,706);
  DYNX(W_,730) = real2integerEvent(divGuarded(DYNTime-DYNX(W_,728),
    "time-signalPWM[3].sawtooth.startTime",DYNX(W_,725),"signalPWM[3].sawtooth.period"),
    "(time-signalPWM[3].sawtooth.startTime)/signalPWM[3].sawtooth.period", 2);
  DYNX(W_,729) = DYNX(W_,728)+DYNX(W_,730)*DYNX(W_,725);
  DYNX(W_,692) = real2integerEvent(divGuarded(DYNTime-DYNX(W_,690),
    "time-signalPWM[1].sawtooth.startTime",DYNX(W_,687),"signalPWM[1].sawtooth.period"),
    "(time-signalPWM[1].sawtooth.startTime)/signalPWM[1].sawtooth.period", 3);
  DYNX(W_,691) = DYNX(W_,690)+DYNX(W_,692)*DYNX(W_,687);
  DYNX(W_,1064) = real2integerEvent(divGuarded(DYNTime-DYNX(W_,1062),
    "time-signalPWM1.sawtooth.startTime",DYNX(W_,1059),"signalPWM1.sawtooth.period"),
    "(time-signalPWM1.sawtooth.startTime)/signalPWM1.sawtooth.period", 4);
  DYNX(W_,1063) = DYNX(W_,1062)+DYNX(W_,1064)*DYNX(W_,1059);
  DYNX(W_,1431) = real2integerEvent(divGuarded(DYNTime-DYNX(W_,1429),
    "time-signalPWM3[2].sawtooth.startTime",DYNX(W_,1426),"signalPWM3[2].sawtooth.period"),
    "(time-signalPWM3[2].sawtooth.startTime)/signalPWM3[2].sawtooth.period", 5);
  DYNX(W_,1430) = DYNX(W_,1429)+DYNX(W_,1431)*DYNX(W_,1426);
  DYNX(W_,1450) = real2integerEvent(divGuarded(DYNTime-DYNX(W_,1448),
    "time-signalPWM3[3].sawtooth.startTime",DYNX(W_,1445),"signalPWM3[3].sawtooth.period"),
    "(time-signalPWM3[3].sawtooth.startTime)/signalPWM3[3].sawtooth.period", 6);
  DYNX(W_,1449) = DYNX(W_,1448)+DYNX(W_,1450)*DYNX(W_,1445);
  DYNX(W_,1412) = real2integerEvent(divGuarded(DYNTime-DYNX(W_,1410),
    "time-signalPWM3[1].sawtooth.startTime",DYNX(W_,1407),"signalPWM3[1].sawtooth.period"),
    "(time-signalPWM3[1].sawtooth.startTime)/signalPWM3[1].sawtooth.period", 7);
  DYNX(W_,1411) = DYNX(W_,1410)+DYNX(W_,1412)*DYNX(W_,1407);
  DYNX(W_,2615) = real2integerEvent(divGuarded(DYNTime-DYNX(W_,2613),
    "time-signalPWM5[1].sawtooth.startTime",DYNX(W_,2610),"signalPWM5[1].sawtooth.period"),
    "(time-signalPWM5[1].sawtooth.startTime)/signalPWM5[1].sawtooth.period", 8);
  DYNX(W_,2614) = DYNX(W_,2613)+DYNX(W_,2615)*DYNX(W_,2610);
  DYNX(W_,2653) = real2integerEvent(divGuarded(DYNTime-DYNX(W_,2651),
    "time-signalPWM5[3].sawtooth.startTime",DYNX(W_,2648),"signalPWM5[3].sawtooth.period"),
    "(time-signalPWM5[3].sawtooth.startTime)/signalPWM5[3].sawtooth.period", 9);
  DYNX(W_,2652) = DYNX(W_,2651)+DYNX(W_,2653)*DYNX(W_,2648);
  DYNX(W_,2634) = real2integerEvent(divGuarded(DYNTime-DYNX(W_,2632),
    "time-signalPWM5[2].sawtooth.startTime",DYNX(W_,2629),"signalPWM5[2].sawtooth.period"),
    "(time-signalPWM5[2].sawtooth.startTime)/signalPWM5[2].sawtooth.period", 10);
  DYNX(W_,2633) = DYNX(W_,2632)+DYNX(W_,2634)*DYNX(W_,2629);
DYNX(W_,330) = homotopy(IF DYNX(W_,326) > DYNX(DP_,39) THEN DYNX(DP_,39) ELSE 
  IF DYNX(W_,326) < DYNX(DP_,40) THEN DYNX(DP_,40) ELSE DYNX(W_,326), 
  DYNX(W_,326));
DYNX(W_,337) = DYNX(W_,330);
DYNX(X_,5) = DYNX(DP_,75);
 /* Linear system of equations to solve. */
/* Introducing 1 common subexpressions used in 1 expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,21) = divinvGuarded(DYNX(W_,733),"variableSpeedDrive_ThreePhase.currentController.T");
DYNX(W_,735) = 0.0;
SolveScalarLinearParametric( -DYNX(DYNhelp,21)," -1.0/variableSpeedDrive_ThreePhase.currentController.T",
   0.0,"0.0", DYNX(W_,735),"variableSpeedDrive_ThreePhase.currentController.u");
 /* End of Equation Block */ 

DYNX(W_,737) = DYNX(W_,732)*(DYNX(X_,5)+DYNX(W_,735));
DYNX(W_,697) = homotopy(IF GreaterS(DYNX(W_,737),"variableSpeedDrive_ThreePhase.y1[1]",
   DYNX(DP_,68),"signalPWM[2].limiter.uMax", 11) THEN DYNX(DP_,68) ELSE IF LessS
  (DYNX(W_,737),"variableSpeedDrive_ThreePhase.y1[1]", DYNX(DP_,69),
  "signalPWM[2].limiter.uMin", 12) THEN DYNX(DP_,69) ELSE DYNX(W_,737), 
  DYNX(W_,737));
DYNX(W_,704) = DYNX(W_,697);
DYNX(W_,716) = homotopy(IF GreaterS(DYNX(W_,737),"variableSpeedDrive_ThreePhase.y1[1]",
   DYNX(DP_,73),"signalPWM[3].limiter.uMax", 13) THEN DYNX(DP_,73) ELSE IF LessS
  (DYNX(W_,737),"variableSpeedDrive_ThreePhase.y1[1]", DYNX(DP_,74),
  "signalPWM[3].limiter.uMin", 14) THEN DYNX(DP_,74) ELSE DYNX(W_,737), 
  DYNX(W_,737));
DYNX(W_,723) = DYNX(W_,716);
DYNX(W_,678) = homotopy(IF GreaterS(DYNX(W_,737),"variableSpeedDrive_ThreePhase.y1[1]",
   DYNX(DP_,63),"signalPWM[1].limiter.uMax", 15) THEN DYNX(DP_,63) ELSE IF LessS
  (DYNX(W_,737),"variableSpeedDrive_ThreePhase.y1[1]", DYNX(DP_,64),
  "signalPWM[1].limiter.uMin", 16) THEN DYNX(DP_,64) ELSE DYNX(W_,737), 
  DYNX(W_,737));
DYNX(W_,685) = DYNX(W_,678);
DYNX(W_,1050) = homotopy(IF DYNX(W_,1046) > DYNX(DP_,113) THEN DYNX(DP_,113)
   ELSE IF DYNX(W_,1046) < DYNX(DP_,114) THEN DYNX(DP_,114) ELSE DYNX(W_,1046), 
  DYNX(W_,1046));
DYNX(W_,1057) = DYNX(W_,1050);
DYNX(X_,12) = DYNX(DP_,149);
 /* Linear system of equations to solve. */
/* Introducing 1 common subexpressions used in 1 expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,22) = divinvGuarded(DYNX(W_,1453),"variableSpeedDrive_ThreePhase1.currentController.T");
DYNX(W_,1455) = 0.0;
SolveScalarLinearParametric( -DYNX(DYNhelp,22)," -1.0/variableSpeedDrive_ThreePhase1.currentController.T",
   0.0,"0.0", DYNX(W_,1455),"variableSpeedDrive_ThreePhase1.currentController.u");
 /* End of Equation Block */ 

DYNX(W_,1457) = DYNX(W_,1452)*(DYNX(X_,12)+DYNX(W_,1455));
DYNX(W_,1417) = homotopy(IF GreaterS(DYNX(W_,1457),"variableSpeedDrive_ThreePhase1.y1[1]",
   DYNX(DP_,142),"signalPWM3[2].limiter.uMax", 17) THEN DYNX(DP_,142) ELSE IF 
  LessS(DYNX(W_,1457),"variableSpeedDrive_ThreePhase1.y1[1]", DYNX(DP_,143),
  "signalPWM3[2].limiter.uMin", 18) THEN DYNX(DP_,143) ELSE DYNX(W_,1457), 
  DYNX(W_,1457));
DYNX(W_,1424) = DYNX(W_,1417);
DYNX(W_,1436) = homotopy(IF GreaterS(DYNX(W_,1457),"variableSpeedDrive_ThreePhase1.y1[1]",
   DYNX(DP_,147),"signalPWM3[3].limiter.uMax", 19) THEN DYNX(DP_,147) ELSE IF 
  LessS(DYNX(W_,1457),"variableSpeedDrive_ThreePhase1.y1[1]", DYNX(DP_,148),
  "signalPWM3[3].limiter.uMin", 20) THEN DYNX(DP_,148) ELSE DYNX(W_,1457), 
  DYNX(W_,1457));
DYNX(W_,1443) = DYNX(W_,1436);
DYNX(W_,1398) = homotopy(IF GreaterS(DYNX(W_,1457),"variableSpeedDrive_ThreePhase1.y1[1]",
   DYNX(DP_,137),"signalPWM3[1].limiter.uMax", 21) THEN DYNX(DP_,137) ELSE IF 
  LessS(DYNX(W_,1457),"variableSpeedDrive_ThreePhase1.y1[1]", DYNX(DP_,138),
  "signalPWM3[1].limiter.uMin", 22) THEN DYNX(DP_,138) ELSE DYNX(W_,1457), 
  DYNX(W_,1457));
DYNX(W_,1405) = DYNX(W_,1398);
DYNX(X_,22) = DYNX(DP_,348);
 /* Linear system of equations to solve. */
/* Introducing 1 common subexpressions used in 1 expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,23) = divinvGuarded(DYNX(W_,2656),"variableSpeedDrive_ThreePhase2.currentController.T");
DYNX(W_,2658) = 0.0;
SolveScalarLinearParametric( -DYNX(DYNhelp,23)," -1.0/variableSpeedDrive_ThreePhase2.currentController.T",
   0.0,"0.0", DYNX(W_,2658),"variableSpeedDrive_ThreePhase2.currentController.u");
 /* End of Equation Block */ 

DYNX(W_,2660) = DYNX(W_,2655)*(DYNX(X_,22)+DYNX(W_,2658));
DYNX(W_,2601) = homotopy(IF GreaterS(DYNX(W_,2660),"variableSpeedDrive_ThreePhase2.y1[1]",
   DYNX(DP_,336),"signalPWM5[1].limiter.uMax", 23) THEN DYNX(DP_,336) ELSE IF 
  LessS(DYNX(W_,2660),"variableSpeedDrive_ThreePhase2.y1[1]", DYNX(DP_,337),
  "signalPWM5[1].limiter.uMin", 24) THEN DYNX(DP_,337) ELSE DYNX(W_,2660), 
  DYNX(W_,2660));
DYNX(W_,2608) = DYNX(W_,2601);
DYNX(W_,2639) = homotopy(IF GreaterS(DYNX(W_,2660),"variableSpeedDrive_ThreePhase2.y1[1]",
   DYNX(DP_,346),"signalPWM5[3].limiter.uMax", 25) THEN DYNX(DP_,346) ELSE IF 
  LessS(DYNX(W_,2660),"variableSpeedDrive_ThreePhase2.y1[1]", DYNX(DP_,347),
  "signalPWM5[3].limiter.uMin", 26) THEN DYNX(DP_,347) ELSE DYNX(W_,2660), 
  DYNX(W_,2660));
DYNX(W_,2646) = DYNX(W_,2639);
DYNX(W_,2620) = homotopy(IF GreaterS(DYNX(W_,2660),"variableSpeedDrive_ThreePhase2.y1[1]",
   DYNX(DP_,341),"signalPWM5[2].limiter.uMax", 27) THEN DYNX(DP_,341) ELSE IF 
  LessS(DYNX(W_,2660),"variableSpeedDrive_ThreePhase2.y1[1]", DYNX(DP_,342),
  "signalPWM5[2].limiter.uMin", 28) THEN DYNX(DP_,342) ELSE DYNX(W_,2660), 
  DYNX(W_,2660));
DYNX(W_,2627) = DYNX(W_,2620);
DYNX(W_,2253) = homotopy(IF DYNX(W_,2249) > DYNX(DP_,312) THEN DYNX(DP_,312)
   ELSE IF DYNX(W_,2249) < DYNX(DP_,313) THEN DYNX(DP_,313) ELSE DYNX(W_,2249), 
  DYNX(W_,2249));
DYNX(W_,2260) = DYNX(W_,2253);
  DYNX(W_,2267) = real2integerEvent(divGuarded(DYNTime-DYNX(W_,2265),
    "time-signalPWM4.sawtooth.startTime",DYNX(W_,2262),"signalPWM4.sawtooth.period"),
    "(time-signalPWM4.sawtooth.startTime)/signalPWM4.sawtooth.period", 29);
  DYNX(W_,2266) = DYNX(W_,2265)+DYNX(W_,2267)*DYNX(W_,2262);
DYNX(W_,641) = DYNX(W_,636)*(1+DYNX(W_,638)*(DYNX(W_,586)-DYNX(W_,637)));
DYNX(W_,473) = DYNX(W_,466)*(1+DYNX(W_,468)*(DYNX(W_,582)-DYNX(W_,467)));
DYNX(W_,2669) = DYNX(DP_,355)*(1+DYNX(DP_,357)*(DYNX(W_,2667)-DYNX(DP_,356)));
DYNX(W_,2674) = DYNX(DP_,358)*(1+DYNX(DP_,360)*(DYNX(W_,2672)-DYNX(DP_,359)));
DYNX(W_,457) = DYNX(W_,450)*(1+DYNX(W_,452)*(DYNX(W_,582)-DYNX(W_,451)));
DYNX(W_,465) = DYNX(W_,458)*(1+DYNX(W_,460)*(DYNX(W_,582)-DYNX(W_,459)));
DYNX(W_,20) = DYNX(W_,15)*(1+DYNX(DP_,7)*(DYNX(W_,18)-DYNX(DP_,6)));
DYNX(W_,8) = DYNX(W_,3)*(1+DYNX(DP_,2)*(DYNX(W_,6)-DYNX(DP_,1)));
DYNX(W_,1361) = DYNX(W_,1356)*(1+DYNX(W_,1358)*(DYNX(W_,1306)-DYNX(W_,1357)));
DYNX(W_,1193) = DYNX(W_,1186)*(1+DYNX(W_,1188)*(DYNX(W_,1302)-DYNX(W_,1187)));
DYNX(W_,1177) = DYNX(W_,1170)*(1+DYNX(W_,1172)*(DYNX(W_,1302)-DYNX(W_,1171)));
DYNX(W_,1185) = DYNX(W_,1178)*(1+DYNX(W_,1180)*(DYNX(W_,1302)-DYNX(W_,1179)));
DYNX(W_,1862) = DYNX(W_,1857)*(1+DYNX(DP_,244)*(DYNX(W_,1860)-DYNX(DP_,243)));
DYNX(W_,1873) = DYNX(W_,1868)*(1+DYNX(DP_,248)*(DYNX(W_,1871)-DYNX(DP_,247)));
DYNX(W_,1593) = IF DYNX(DP_,205) THEN DYNX(DP_,209)*DYNX(DP_,210) ELSE 1;
DYNX(W_,1661) = DYNX(W_,1662)*DYNX(W_,1593);
DYNX(W_,1586) = DYNX(DP_,183)*DYNX(DP_,184);
DYNX(W_,1594) = IF DYNX(DP_,204) THEN DYNX(DP_,209)+DYNX(DP_,210)-1 ELSE 1;
BreakSectionFunctionEnd()
BreakSectionFunctionStart(11);
DYNX(W_,1561) = DYNX(W_,1586)*DYNX(W_,1594);
DYNX(W_,1512) = DYNX(W_,1572)*DYNX(W_,1561);
DYNX(W_,1598) = DYNX(W_,1582)+DYNX(W_,1584);
DYNX(W_,1599) = DYNX(W_,1583)-DYNX(W_,1584);
DYNX(W_,1623) = DYNX(DP_,188);
DYNX(W_,1624) = DYNX(DP_,189)-DYNX(DP_,190);
DYNX(W_,1700) = DYNX(DP_,174)+DYNX(DP_,176);
DYNX(W_,1701) = DYNX(DP_,175)-DYNX(DP_,176);
DYNX(W_,1726) = DYNX(DP_,178);
DYNX(W_,1727) =  -DYNX(DP_,177);
DYNX(W_,1735) = DYNX(DP_,181);
DYNX(W_,1736) =  -DYNX(DP_,180);
DYNX(W_,2564) = DYNX(W_,2559)*(1+DYNX(W_,2561)*(DYNX(W_,2509)-DYNX(W_,2560)));
DYNX(W_,2396) = DYNX(W_,2389)*(1+DYNX(W_,2391)*(DYNX(W_,2505)-DYNX(W_,2390)));
DYNX(W_,2388) = DYNX(W_,2381)*(1+DYNX(W_,2383)*(DYNX(W_,2505)-DYNX(W_,2382)));
DYNX(W_,2380) = DYNX(W_,2373)*(1+DYNX(W_,2375)*(DYNX(W_,2505)-DYNX(W_,2374)));
 /* Linear system of equations to solve. */
DYNX(W_,1824) = 0.0;
SolveScalarLinearParametric( -DYNX(W_,1827)," -batteryPack.thermal.ambientTransfer.G",
   0.0,"0.0", DYNX(W_,1824),"batteryPack.thermal.ambientTransfer.dT");
 /* End of Equation Block */ 

DYNX(W_,1931) = DYNX(W_,1926)*(1+DYNX(DP_,275)*(DYNX(W_,1929)-DYNX(DP_,274)));
DYNX(W_,1943) = DYNX(W_,1938)*(1+DYNX(DP_,280)*(DYNX(W_,1941)-DYNX(DP_,279)));
DYNX(W_,508) = RealBmax(fabs(DYNX(W_,395)), DYNX(W_,498));
DYNX(W_,1228) = RealBmax(fabs(DYNX(W_,1115)), DYNX(W_,1218));
DYNX(W_,1504) = (PushModelContext(1,"Electrification.Batteries.Core.Capacity.Functions.arrayCapacity(batteryPack.summary.core_Q_cap_aged, 1, 1)")
  Electrification_Batteries_Core_Capacity_Functions_arrayCapacity(
  RealTemporaryDense( &DYNX(W_,1512), 2, 1, 1), 1, 1));
PopAllMarks();
DYNX(W_,1587) = DYNX(W_,1572)*DYNX(W_,1586);
DYNX(W_,1591) = IF DYNX(DP_,207) THEN DYNX(DP_,209)*DYNX(DP_,210) ELSE 1;
DYNX(W_,1592) = IF DYNX(DP_,206) THEN DYNX(DP_,209)*DYNX(DP_,210) ELSE 1;
DYNX(W_,1595) = IF DYNX(DP_,208) THEN DYNX(DP_,209)*DYNX(DP_,210) ELSE 1;
DYNX(W_,1632) = divGuarded(divGuarded(300.0,"300.0",DYNX(W_,1611),
  "batteryPack.core.voltage.ngs"),"300.0/batteryPack.core.voltage.ngs",
  DYNX(DP_,192),"batteryPack.core.voltage.k_OCV");
DYNX(W_,2431) = RealBmax(fabs(DYNX(W_,2318)), DYNX(W_,2421));
InitialBoundSection
DYNX(Aux_,12) = DYNX(W_,1063);
DYNX(Aux_,16) = DYNX(W_,343);
DYNX(Aux_,20) = DYNX(W_,1411);
DYNX(Aux_,24) = DYNX(W_,1430);
DYNX(Aux_,28) = DYNX(W_,1449);
DYNX(Aux_,32) = DYNX(W_,2266);
DYNX(Aux_,36) = DYNX(W_,2614);
DYNX(Aux_,40) = DYNX(W_,2633);
DYNX(Aux_,44) = DYNX(W_,2652);
DYNX(Aux_,48) = DYNX(W_,691);
DYNX(Aux_,52) = DYNX(W_,710);
DYNX(Aux_,56) = DYNX(W_,729);
InitialSection2
DYNX(X_,6) = DYNX(W_,735)+DYNX(W_,738);
DYNX(X_,13) = DYNX(W_,1455)+DYNX(W_,1458);
DYNX(X_,15) = DYNX(W_,1831);
AssertModelica(GreaterEqual(1+DYNX(W_,1652)*(DYNX(X_,15)-DYNX(W_,1651)),
  "1+batteryPack.core.impedance.r0.alpha*(batteryPack.thermal.internalMass.T-batteryPack.core.impedance.r0.T_ref)",
   1E-15,"1E-15", 30),"1+batteryPack.core.impedance.r0.alpha*(batteryPack.thermal.internalMass.T-batteryPack.core.impedance.r0.T_ref) >= 1E-15",
   "Temperature outside scope of model!");
DYNX(X_,14) = DYNX(W_,1587)*DYNX(W_,1576);
DYNX(X_,23) = DYNX(W_,2658)+DYNX(W_,2661);
InitialBoundSection
DYNX(Aux_,13) = DYNX(W_,1064);
DYNX(Aux_,17) = DYNX(W_,344);
DYNX(Aux_,21) = DYNX(W_,1412);
DYNX(Aux_,25) = DYNX(W_,1431);
DYNX(Aux_,29) = DYNX(W_,1450);
DYNX(Aux_,33) = DYNX(W_,2267);
DYNX(Aux_,37) = DYNX(W_,2615);
DYNX(Aux_,41) = DYNX(W_,2634);
DYNX(Aux_,45) = DYNX(W_,2653);
DYNX(Aux_,49) = DYNX(W_,692);
DYNX(Aux_,53) = DYNX(W_,711);
DYNX(Aux_,57) = DYNX(W_,730);
InitialSection2
DYNX(W_,1597) = divGuarded(DYNX(X_,14),"batteryPack.core.capacity.Q",
  DYNX(W_,1512),"batteryPack.summary.core_Q_cap_aged[1, 1]");
  DYNX(W_,1602) = IF GreaterEqualTime(DYNX(W_,1601), 0) THEN (IF DYNX(DP_,187)
     THEN Less(DYNX(W_,1597),"batteryPack.core.capacity.limitSoC.x", 
    DYNX(W_,1598),"batteryPack.core.capacity.limitSoC.xMax", 31) ELSE true)
     ELSE false;
  DYNX(W_,1603) = IF GreaterEqualTime(DYNX(W_,1601), 0) THEN (IF DYNX(DP_,187)
     THEN Greater(DYNX(W_,1597),"batteryPack.core.capacity.limitSoC.x", 
    DYNX(W_,1599),"batteryPack.core.capacity.limitSoC.xMin", 32) ELSE true)
     ELSE false;
DYNX(W_,1618) = DYNX(DP_,196)+DYNX(W_,1597)*DYNX(W_,1635);
DYNX(W_,1622) = DYNX(W_,1618)*DYNX(W_,1611)*DYNX(DP_,192);
  DYNX(W_,1628) = IF GreaterEqualTime(DYNX(W_,1627), 1) THEN (IF DYNX(DP_,194)
     THEN Less(DYNX(W_,1622),"batteryPack.core.voltage.limitCellOCV.x", 
    DYNX(W_,1623),"batteryPack.core.voltage.limitCellOCV.xMax", 33) ELSE true)
     ELSE false;
  DYNX(W_,1629) = IF GreaterEqualTime(DYNX(W_,1627), 1) THEN (IF DYNX(DP_,194)
     THEN Greater(DYNX(W_,1622),"batteryPack.core.voltage.limitCellOCV.x", 
    DYNX(W_,1624),"batteryPack.core.voltage.limitCellOCV.xMin", 34) ELSE true)
     ELSE false;
DYNX(W_,1699) = divGuarded(DYNX(W_,1622),"batteryPack.core.voltage.limitCellOCV.x",
  DYNX(W_,1551),"batteryPack.core.summary.ngs");
  DYNX(W_,1705) = IF GreaterEqualTime(DYNX(W_,1704), 2) THEN (IF DYNX(DP_,212)
     THEN Less(DYNX(W_,1699),"batteryPack.core.limitVoltage.x", DYNX(W_,1700),
    "batteryPack.core.limitVoltage.xMax", 35) ELSE true) ELSE false;
  DYNX(W_,1706) = IF GreaterEqualTime(DYNX(W_,1704), 2) THEN (IF DYNX(DP_,212)
     THEN Greater(DYNX(W_,1699),"batteryPack.core.limitVoltage.x", DYNX(W_,1701),
    "batteryPack.core.limitVoltage.xMin", 36) ELSE true) ELSE false;
  DYNX(W_,1731) = IF GreaterEqualTime(DYNX(W_,1730), 3) THEN (IF DYNX(DP_,215)
     THEN 0.0 < DYNX(W_,1726) ELSE true) ELSE false;
  DYNX(W_,1732) = IF GreaterEqualTime(DYNX(W_,1730), 3) THEN (IF DYNX(DP_,215)
     THEN 0.0 > DYNX(W_,1727) ELSE true) ELSE false;
  DYNX(W_,1740) = IF GreaterEqualTime(DYNX(W_,1739), 4) THEN (IF DYNX(DP_,217)
     THEN 0.0 < DYNX(W_,1735) ELSE true) ELSE false;
  DYNX(W_,1741) = IF GreaterEqualTime(DYNX(W_,1739), 4) THEN (IF DYNX(DP_,217)
     THEN 0.0 > DYNX(W_,1736) ELSE true) ELSE false;
DYNX(W_,1508) = DYNX(W_,1622);
DYNX(W_,1510) = DYNX(W_,1661)*(1+DYNX(W_,1652)*(DYNX(X_,15)-DYNX(W_,1651)));
DYNX(W_,1502) = (PushModelContext(1,"Electrification.Batteries.Utilities.Functions.CurrentAtMaximumPower(batteryPack.summary.core_ocv, batteryPack.summary.core_R_max_dch, 1, 1)")
  Electrification_Batteries_Utilities_Functions_CurrentAtMaximumPower(
  RealTemporaryDense( &DYNX(W_,1508), 2, 1, 1), RealTemporaryDense( 
  &DYNX(W_,1510), 2, 1, 1), 1, 1));
PopAllMarks();
DYNX(W_,1844) = DYNX(W_,1502)+DYNX(DP_,169);
  DYNX(W_,1849) = IF GreaterEqualTime(DYNX(W_,1848), 5) THEN (IF DYNX(DP_,241)
     THEN Less(0.0,"0.0", DYNX(W_,1844),"batteryPack.limitDischarge.xMax", 37)
     ELSE true) ELSE false;
  DYNX(W_,1850) = IF GreaterEqualTime(DYNX(W_,1848), 5) THEN true ELSE false;
DYNX(W_,336) = DYNX(Aux_,18);
DYNX(W_,684) = DYNX(Aux_,50);
DYNX(W_,703) = DYNX(Aux_,54);
DYNX(W_,722) = DYNX(Aux_,58);
DYNX(W_,1056) = DYNX(Aux_,14);
DYNX(W_,1404) = DYNX(Aux_,22);
DYNX(W_,1423) = DYNX(Aux_,26);
DYNX(W_,1442) = DYNX(Aux_,30);
DYNX(W_,2259) = DYNX(Aux_,34);
DYNX(W_,2607) = DYNX(Aux_,38);
DYNX(W_,2626) = DYNX(Aux_,42);
DYNX(W_,2645) = DYNX(Aux_,46);
DYNX(W_,1633) = DYNX(X_,15)-273.15;
DYNX(W_,1619) = homotopy(DYNX(W_,1633), DYNX(W_,1614));
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection
AssertModelica(GreaterEqual(1+DYNX(W_,1652)*(DYNX(X_,15)-DYNX(W_,1651)),
  "1+batteryPack.core.impedance.r0.alpha*(batteryPack.thermal.internalMass.T-batteryPack.core.impedance.r0.T_ref)",
   1E-15,"1E-15", 30),"1+batteryPack.core.impedance.r0.alpha*(batteryPack.thermal.internalMass.T-batteryPack.core.impedance.r0.T_ref) >= 1E-15",
   "Temperature outside scope of model!");

DynamicsSection
DYNX(F_,4) = DYNX(X_,6);
DYNX(F_,11) = DYNX(X_,13);
DYNX(F_,21) = DYNX(X_,23);
DYNX(W_,605) = DYNX(W_,603)*DYNX(X_,6);
DYNX(W_,604) = DYNX(W_,603)*(DYNX(X_,4)-DYNX(DP_,44));
DYNX(DYNhelp,24) = cos(DYNX(W_,604));
DYNX(W_,619) =  -DYNX(W_,605)*DYNX(DYNhelp,24);
DYNX(W_,614) = DYNX(DYNhelp,24);
DYNX(DYNhelp,25) = sin(DYNX(W_,604));
DYNX(W_,615) =  -DYNX(DYNhelp,25);
DYNX(W_,478) = DYNX(W_,614)*DYNX(X_,0)+DYNX(W_,615)*DYNX(X_,1);
DYNX(W_,420) = DYNX(W_,614)*DYNX(X_,2)+DYNX(W_,615)*DYNX(X_,3);
DYNX(W_,622) = DYNX(W_,478)+DYNX(W_,420);
DYNX(W_,606) = DYNX(W_,626)*DYNX(W_,622);
DYNX(W_,616) = DYNX(DYNhelp,25);
DYNX(W_,617) = DYNX(DYNhelp,24);
DYNX(W_,479) = DYNX(W_,616)*DYNX(X_,0)+DYNX(W_,617)*DYNX(X_,1);

 /* Linear system of equations to solve. */
/* Tag: simulation.linear[1] */
/* Automatic tearing of linear system of 3 simultaneous equations
gave a linear system of 2 equations for numerical solution.*/
{
  const char*const varnames_[]={"inverter2.ac.pin[3].i", "inverter2.ac.pin[1].i"};
  const double nominal_[]={1, 1};
  static double J__internal[4]={-1.154700538379252, -1.3322676295501878E-15, 
    1.154700538379252, 3.000000000000001};
  static SizeType J__dims[2]={2,2};
  static RealArray J={2,J__dims,J__internal};
  static int J__m=2;
  static int factoredForParametersV_=0;
  int*factoredForParametersP_=&factoredForParametersV_;
  static double J__DWork[16]={-1.154700538379252, 1.153777611830138E-15, 
    1.154700538379252, 2.9999999999999996, -1.5326920704511053, -0.6666666666666672,
     -0.8660254037844387, -3.845925372767127E-16, 1.153777611830138E-15, 0.0, 
    0.0, 1.154700538379252, 0.8660254037844384, 0.33333333333333326, 1.0, 1.0};
  static int J__IWork[5]={1, 2, 0, -1, -1};
  static int J__FactoredV=1;
  int* J__FactoredP=&(J__FactoredV);
  DeclareDidRealVector1(b, 2, DYNX(DYNhelp,26));
  DeclareDidRealVector1(y, 2, DYNX(DYNhelp,28));
  DeclareDidRealVector2(b, 2, DYNX(DYNhelp,26));
  DeclareDidRealVector2(y, 2, DYNX(DYNhelp,28));
  RealFillAssign(b,0.0);
  SetVector(b, 1,  -(DYNX(W_,479)+1.7320508075688783*DYNX(W_,478)));
  SetVector(b, 2, (-3.0000000000000018)*DYNX(W_,478));
  SetVector(y, 1, RememberSimple_(DYNX(W_,48), 0));
  SetVector(y, 2, RememberSimple_(DYNX(W_,44), 1));
  SolveLinearSystemOfEquations(J, b, y, 1);
  DYNX(W_,48) = GetVector(y, 1);
  DYNX(W_,44) = GetVector(y, 2);
  EndStaticLinearSystemOfEquations(J);
}
DYNX(W_,46) = 3.0000000000000018*(DYNX(W_,478)-0.3333333333333336*DYNX(W_,48)+
  0.6666666666666666*DYNX(W_,44));
 /* End of Equation Block */ 

DYNX(W_,453) =  -DYNX(W_,457)*DYNX(W_,44);
beginwhenBlock
if (NewParameters_) {
DYNX(DYNhelp,30) = divinvGuarded(DYNX(W_,339),"signalPWM2.sawtooth.period");
}
DYNX(DYNhelp,31) = real2integer(DYNX(DYNhelp,30)*(DYNTime-DYNX(W_,342)));
whenModelica(real2integerEventMinor(divGuarded(DYNTime-DYNX(W_,342),
  "time-signalPWM2.sawtooth.startTime",DYNX(W_,339),"signalPWM2.sawtooth.period"),
  "(time-signalPWM2.sawtooth.startTime)/signalPWM2.sawtooth.period", 0) > PRE(
  DYNX(W_,344), 26), 0) 
  DYNX(W_,343) = DYNTime;
endwhenModelica()
endwhenBlock


DYNX(W_,331) = IF LessTime(DYNX(W_,342), 6) THEN 0 ELSE divGuarded(DYNTime-
  DYNX(W_,343),"time-signalPWM2.sawtooth.T_start",DYNX(W_,339),"signalPWM2.sawtooth.period");
DYNX(W_,332) = PRE(DYNX(W_,337), 27);
DYNX(W_,302) = Less(DYNX(W_,331),"signalPWM2.greaterEqual.u1", DYNX(W_,332),
  "signalPWM2.greaterEqual.u2", 38);
DYNX(W_,301) = DYNX(W_,302) AND DYNX(W_,299);
beginwhenBlock
if (NewParameters_) {
DYNX(DYNhelp,32) = divinvGuarded(DYNX(W_,706),"signalPWM[2].sawtooth.period");
}
DYNX(DYNhelp,33) = real2integer(DYNX(DYNhelp,32)*(DYNTime-DYNX(W_,709)));
whenModelica(real2integerEventMinor(divGuarded(DYNTime-DYNX(W_,709),
  "time-signalPWM[2].sawtooth.startTime",DYNX(W_,706),"signalPWM[2].sawtooth.period"),
  "(time-signalPWM[2].sawtooth.startTime)/signalPWM[2].sawtooth.period", 1) > 
  PRE(DYNX(W_,711), 28), 1) 
  DYNX(W_,710) = DYNTime;
endwhenModelica()
endwhenBlock


DYNX(W_,698) = IF LessTime(DYNX(W_,709), 7) THEN 0 ELSE divGuarded(DYNTime-
  DYNX(W_,710),"time-signalPWM[2].sawtooth.T_start",DYNX(W_,706),
  "signalPWM[2].sawtooth.period");
DYNX(W_,699) = PRE(DYNX(W_,704), 29);
DYNX(W_,34) = Less(DYNX(W_,698),"signalPWM[2].greaterEqual.u1", DYNX(W_,699),
  "signalPWM[2].greaterEqual.u2", 39);
DYNX(W_,195) = DYNX(W_,34) AND DYNX(W_,31);
beginwhenBlock
if (NewParameters_) {
DYNX(DYNhelp,34) = divinvGuarded(DYNX(W_,725),"signalPWM[3].sawtooth.period");
}
DYNX(DYNhelp,35) = real2integer(DYNX(DYNhelp,34)*(DYNTime-DYNX(W_,728)));
whenModelica(real2integerEventMinor(divGuarded(DYNTime-DYNX(W_,728),
  "time-signalPWM[3].sawtooth.startTime",DYNX(W_,725),"signalPWM[3].sawtooth.period"),
  "(time-signalPWM[3].sawtooth.startTime)/signalPWM[3].sawtooth.period", 2) > 
  PRE(DYNX(W_,730), 30), 2) 
  DYNX(W_,729) = DYNTime;
endwhenModelica()
endwhenBlock


DYNX(W_,717) = IF LessTime(DYNX(W_,728), 8) THEN 0 ELSE divGuarded(DYNTime-
  DYNX(W_,729),"time-signalPWM[3].sawtooth.T_start",DYNX(W_,725),
  "signalPWM[3].sawtooth.period");
DYNX(W_,718) = PRE(DYNX(W_,723), 31);
DYNX(W_,35) = Less(DYNX(W_,717),"signalPWM[3].greaterEqual.u1", DYNX(W_,718),
  "signalPWM[3].greaterEqual.u2", 40);
DYNX(W_,196) = DYNX(W_,35) AND DYNX(W_,31);
DYNX(W_,27) =  NOT DYNX(W_,35);
DYNX(W_,82) = DYNX(W_,27) AND DYNX(W_,31);
beginwhenBlock
if (NewParameters_) {
DYNX(DYNhelp,36) = divinvGuarded(DYNX(W_,687),"signalPWM[1].sawtooth.period");
}
DYNX(DYNhelp,37) = real2integer(DYNX(DYNhelp,36)*(DYNTime-DYNX(W_,690)));
whenModelica(real2integerEventMinor(divGuarded(DYNTime-DYNX(W_,690),
  "time-signalPWM[1].sawtooth.startTime",DYNX(W_,687),"signalPWM[1].sawtooth.period"),
  "(time-signalPWM[1].sawtooth.startTime)/signalPWM[1].sawtooth.period", 3) > 
  PRE(DYNX(W_,692), 32), 3) 
  DYNX(W_,691) = DYNTime;
endwhenModelica()
endwhenBlock


DYNX(W_,679) = IF LessTime(DYNX(W_,690), 9) THEN 0 ELSE divGuarded(DYNTime-
  DYNX(W_,691),"time-signalPWM[1].sawtooth.T_start",DYNX(W_,687),
  "signalPWM[1].sawtooth.period");
DYNX(W_,680) = PRE(DYNX(W_,685), 33);
DYNX(W_,33) = Less(DYNX(W_,679),"signalPWM[1].greaterEqual.u1", DYNX(W_,680),
  "signalPWM[1].greaterEqual.u2", 41);
DYNX(W_,194) = DYNX(W_,33) AND DYNX(W_,31);
DYNX(W_,26) =  NOT DYNX(W_,34);
DYNX(W_,81) = DYNX(W_,26) AND DYNX(W_,31);
DYNX(W_,25) =  NOT DYNX(W_,33);
DYNX(W_,80) = DYNX(W_,25) AND DYNX(W_,31);

MixedSystemOfEquations(46, DYNX(DYNhelp,38))

   /* Linear system of equations to solve. */
  /* Tag: simulation.linear[2] */
  /* Introducing 75 common subexpressions used in 89 expressions */
  /* Of the common subexpressions 75 are reals, 0 are integers, and 0
     are booleans. */
  DYNX(DYNhelp,84) = DYNX(W_,105)*DYNX(W_,106);
  DYNX(DYNhelp,85) = DYNX(W_,219)*DYNX(W_,220);
  DYNX(DYNhelp,86) = DYNX(W_,158)*DYNX(W_,159);
  DYNX(DYNhelp,87) = DYNX(W_,272)*DYNX(W_,273);
  DYNX(DYNhelp,88) = DYNX(W_,1)+DYNX(W_,11);
  DYNX(DYNhelp,89) = DYNX(W_,20)+DYNX(W_,8);
  DYNX(DYNhelp,90) = DYNX(W_,306)*DYNX(W_,307);
  DYNX(DYNhelp,91) = DYNX(DYNhelp,89)*DYNX(DYNhelp,90);
  DYNX(DYNhelp,92) = DYNX(W_,316)*DYNX(W_,317);
  DYNX(DYNhelp,93) = DYNX(DYNhelp,89)*DYNX(DYNhelp,92);
  DYNX(DYNhelp,94) = DYNX(W_,44)+DYNX(W_,46)+DYNX(W_,48);
  DYNX(DYNhelp,95) = DYNX(W_,8)*DYNX(DYNhelp,94);
  DYNX(DYNhelp,96) = (-1.0)*DYNX(DYNhelp,89)-DYNX(W_,2674);
  DYNX(DYNhelp,97) = DYNX(DYNhelp,96)-DYNX(W_,2669);
  DYNX(DYNhelp,98) = DYNX(W_,220)+DYNX(DYNhelp,91)-DYNX(DYNhelp,97)*
    DYNX(DYNhelp,92);
  DYNX(DYNhelp,99) = DYNX(DYNhelp,96)*DYNX(DYNhelp,94);
  DYNX(DYNhelp,100) = DYNX(W_,199)*DYNX(W_,200);
  DYNX(DYNhelp,101) = DYNX(W_,85)*DYNX(W_,86);
  DYNX(DYNhelp,102) = DYNX(DYNhelp,100)-DYNX(DYNhelp,101);
  DYNX(DYNhelp,103) = DYNX(W_,138)*DYNX(W_,139);
  DYNX(DYNhelp,104) = DYNX(W_,252)*DYNX(W_,253);
  DYNX(DYNhelp,105) = DYNX(W_,44)+DYNX(W_,48);
  DYNX(DYNhelp,106) = (-1.0)*DYNX(DYNhelp,101)-DYNX(DYNhelp,84)+DYNX(DYNhelp,86)
    +DYNX(DYNhelp,92)+DYNX(DYNhelp,94);
  DYNX(DYNhelp,107) = DYNX(DYNhelp,106)+DYNX(DYNhelp,103)-DYNX(DYNhelp,105);
  DYNX(DYNhelp,108) = DYNX(W_,95)*DYNX(W_,96);
  DYNX(DYNhelp,109) = DYNX(W_,148)*DYNX(W_,149);
  DYNX(DYNhelp,110) = DYNX(W_,220)-DYNX(W_,96);
  DYNX(DYNhelp,111) = DYNX(W_,209)*DYNX(W_,210);
  DYNX(DYNhelp,112) = DYNX(W_,262)*DYNX(W_,263);
  /* Automatic tearing of linear system of 46 simultaneous equations
  gave a linear system of 14 equations for numerical solution.*/
  {
    const char*const varnames_[]={"inverter2.transistor_n.idealGTOThyristor[1].s",
       "inverter2.transistor_p.idealGTOThyristor[1].s", "inverter2.transistor_p.idealGTOThyristor[3].s",
       "inverter2.transistor_n.idealGTOThyristor[3].s", "inverter2.diode_p.idealDiode[3].s",
       "inverter2.diode_n.idealDiode[3].s", "dcdc.transistor.s", "dcdc.diode.s",
       "inverter2.diode_p.idealDiode[1].s", "inverter2.diode_n.idealDiode[1].s",
       "inverter2.transistor_p.idealGTOThyristor[2].s", "inverter2.diode_p.idealDiode[2].s",
       "inverter2.diode_n.idealDiode[2].s", "inverter2.transistor_n.idealGTOThyristor[2].s"};
    const double nominal_[]={1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
    DidLinearSystemOfEquations(J, b, y, 14, DYNX(DYNhelp,113), 504, 
      DYNX(did_->helpvari_vec,0), 32);
    /* Jacobian depending on discrete variables */
    /* Special case for simplified event handling */
    #if defined(EventIterate_) && (EventIterate_==0)
    SetNeedFactor(J);
    #else
    if (NewParametersJac||DYNEvent|| dymolaEventsNr_!=*(factoredForEventsP_))
       SetNeedFactor(J);
    #endif
    if (NeedFactor(J)) {
      *(factoredForEventsP_)=dymolaEventsNr_;
      MatrixZeros(J);
      DYNX(DYNhelp,617) = IF DYNX(W_,109) THEN 1 ELSE DYNX(W_,104);
      DYNX(DYNhelp,618) = IF DYNX(W_,109) THEN DYNX(W_,105) ELSE 1;
      DYNX(DYNhelp,619) = IF DYNX(W_,223) THEN DYNX(W_,219) ELSE 1;
      DYNX(DYNhelp,620) = IF DYNX(W_,162) THEN DYNX(W_,158) ELSE 1;
      DYNX(DYNhelp,621) = IF DYNX(W_,276) THEN DYNX(W_,272) ELSE 1;
      DYNX(DYNhelp,622) = IF DYNX(W_,223) THEN 1 ELSE DYNX(W_,218);
      DYNX(DYNhelp,623) = IF DYNX(W_,310) THEN DYNX(W_,306) ELSE 1;
      DYNX(DYNhelp,624) = DYNX(DYNhelp,89)*DYNX(DYNhelp,623);
      DYNX(DYNhelp,625) = IF DYNX(W_,310) THEN 1 ELSE DYNX(W_,305);
      DYNX(DYNhelp,626) = IF DYNX(W_,320) THEN DYNX(W_,316) ELSE 1;
      DYNX(DYNhelp,627) = IF DYNX(W_,320) THEN 1 ELSE DYNX(W_,315);
      DYNX(DYNhelp,628) = IF DYNX(W_,203) THEN 1 ELSE DYNX(W_,198);
      DYNX(DYNhelp,629) = IF DYNX(W_,142) THEN 1 ELSE DYNX(W_,137);
      DYNX(DYNhelp,630) = IF DYNX(W_,203) THEN DYNX(W_,199) ELSE 1;
      DYNX(DYNhelp,631) = IF DYNX(W_,89) THEN DYNX(W_,85) ELSE 1;
      DYNX(DYNhelp,632) = IF DYNX(W_,142) THEN DYNX(W_,138) ELSE 1;
      DYNX(DYNhelp,633) = IF DYNX(W_,256) THEN DYNX(W_,252) ELSE 1;
      DYNX(DYNhelp,634) = (-1.0)*DYNX(DYNhelp,631);
      DYNX(DYNhelp,635) = (-1.0)*DYNX(DYNhelp,618);
      DYNX(DYNhelp,636) = IF DYNX(W_,99) THEN DYNX(W_,95) ELSE 1;
      DYNX(DYNhelp,637) = IF DYNX(W_,152) THEN DYNX(W_,148) ELSE 1;
      DYNX(DYNhelp,638) = IF DYNX(W_,99) THEN 1 ELSE DYNX(W_,94);
      DYNX(DYNhelp,639) = IF DYNX(W_,266) THEN 1 ELSE DYNX(W_,261);
      DYNX(DYNhelp,640) = IF DYNX(W_,266) THEN DYNX(W_,262) ELSE 1;
      DYNX(DYNhelp,641) = IF DYNX(W_,213) THEN DYNX(W_,209) ELSE 1;
      DYNX(DYNhelp,642) = (-1.0)*DYNX(DYNhelp,617);
      DYNX(DYNhelp,643) = (-1.0)*DYNX(DYNhelp,622);
      DYNX(DYNhelp,644) = IF DYNX(W_,213) THEN 1 ELSE DYNX(W_,208);
      DYNX(DYNhelp,645) = IF DYNX(W_,89) THEN 1 ELSE DYNX(W_,84);
      SetMatrixLeading(J, 1, 3, 14, DYNX(DYNhelp,617));
      SetMatrixLeading(J, 1, 5, 14, IF DYNX(W_,162) THEN 1 ELSE DYNX(W_,157));
      SetMatrixLeading(J, 2, 3, 14, DYNX(DYNhelp,618));
      SetMatrixLeading(J, 2, 4, 14, (-1.0)*DYNX(DYNhelp,619));
      SetMatrixLeading(J, 2, 5, 14, (-1.0)*DYNX(DYNhelp,620));
      SetMatrixLeading(J, 2, 6, 14, DYNX(DYNhelp,621));
      SetMatrixLeading(J, 3, 4, 14, DYNX(DYNhelp,622));
      SetMatrixLeading(J, 3, 6, 14, IF DYNX(W_,276) THEN 1 ELSE DYNX(W_,271));
      SetMatrixLeading(J, 4, 7, 14, DYNX(DYNhelp,624)+DYNX(DYNhelp,625));
      SetMatrixLeading(J, 4, 8, 14, DYNX(DYNhelp,89)*DYNX(DYNhelp,626));
      SetMatrixLeading(J, 5, 3, 14, DYNX(DYNhelp,617));
      SetMatrixLeading(J, 5, 4, 14, DYNX(DYNhelp,622));
      SetMatrixLeading(J, 5, 7, 14, DYNX(DYNhelp,624));
      SetMatrixLeading(J, 5, 8, 14, (-1.0)*(DYNX(DYNhelp,97)*DYNX(DYNhelp,626)-
        DYNX(DYNhelp,627)));
      SetMatrixLeading(J, 6, 1, 14, (-1.0)*DYNX(DYNhelp,628));
      SetMatrixLeading(J, 6, 3, 14, DYNX(DYNhelp,617));
      SetMatrixLeading(J, 6, 4, 14, DYNX(DYNhelp,622));
      SetMatrixLeading(J, 6, 9, 14, DYNX(DYNhelp,629));
      SetMatrixLeading(J, 7, 1, 14, DYNX(DYNhelp,628));
      SetMatrixLeading(J, 7, 10, 14, IF DYNX(W_,256) THEN 1 ELSE DYNX(W_,251));
      SetMatrixLeading(J, 8, 1, 14, (-1.0)*DYNX(DYNhelp,630));
      SetMatrixLeading(J, 8, 2, 14, DYNX(DYNhelp,631));
      SetMatrixLeading(J, 8, 9, 14, (-1.0)*DYNX(DYNhelp,632));
      SetMatrixLeading(J, 8, 10, 14, DYNX(DYNhelp,633));
      SetMatrixLeading(J, 9, 2, 14, DYNX(DYNhelp,634));
      SetMatrixLeading(J, 9, 3, 14, DYNX(DYNhelp,635));
      SetMatrixLeading(J, 9, 5, 14, DYNX(DYNhelp,620));
      SetMatrixLeading(J, 9, 8, 14, DYNX(DYNhelp,626));
      SetMatrixLeading(J, 9, 9, 14, DYNX(DYNhelp,632));
      SetMatrixLeading(J, 9, 11, 14, (-1.0)*DYNX(DYNhelp,636));
      SetMatrixLeading(J, 9, 12, 14, DYNX(DYNhelp,637));
      SetMatrixLeading(J, 10, 11, 14, DYNX(DYNhelp,638));
      SetMatrixLeading(J, 10, 12, 14, IF DYNX(W_,152) THEN 1 ELSE DYNX(W_,147));
      SetMatrixLeading(J, 11, 3, 14, DYNX(DYNhelp,617));
      SetMatrixLeading(J, 11, 4, 14, DYNX(DYNhelp,622));
      SetMatrixLeading(J, 11, 11, 14, (-1.0)*DYNX(DYNhelp,638));
      SetMatrixLeading(J, 11, 13, 14, DYNX(DYNhelp,639));
      SetMatrixLeading(J, 12, 2, 14, DYNX(DYNhelp,634));
      SetMatrixLeading(J, 12, 3, 14, DYNX(DYNhelp,635));
      SetMatrixLeading(J, 12, 5, 14, DYNX(DYNhelp,620));
      SetMatrixLeading(J, 12, 8, 14, DYNX(DYNhelp,626));
      SetMatrixLeading(J, 12, 9, 14, DYNX(DYNhelp,632));
      SetMatrixLeading(J, 12, 13, 14, DYNX(DYNhelp,640));
      SetMatrixLeading(J, 12, 14, 14, (-1.0)*DYNX(DYNhelp,641));
      SetMatrixLeading(J, 13, 3, 14, DYNX(DYNhelp,642));
      SetMatrixLeading(J, 13, 4, 14, DYNX(DYNhelp,643));
      SetMatrixLeading(J, 13, 11, 14, DYNX(DYNhelp,638));
      SetMatrixLeading(J, 13, 14, 14, DYNX(DYNhelp,644));
      SetMatrixLeading(J, 14, 1, 14, DYNX(DYNhelp,628));
      SetMatrixLeading(J, 14, 2, 14, DYNX(DYNhelp,645));
      SetMatrixLeading(J, 14, 3, 14, DYNX(DYNhelp,642));
      SetMatrixLeading(J, 14, 4, 14, DYNX(DYNhelp,643));
    }
    SetVector(b, 1,  -(DYNX(W_,159)+DYNX(W_,106)));
    SetVector(b, 2,  -(DYNX(W_,48)+DYNX(DYNhelp,84)-DYNX(DYNhelp,85)-
      DYNX(DYNhelp,86)+DYNX(DYNhelp,87)));
    SetVector(b, 3,  -(DYNX(W_,273)+DYNX(W_,220)));
    SetVector(b, 4, DYNX(DYNhelp,88)-(DYNX(DYNhelp,91)+DYNX(DYNhelp,93)+
      DYNX(DYNhelp,89)*DYNX(DYNhelp,94)+DYNX(W_,307))+DYNX(DYNhelp,95));
    SetVector(b, 5, DYNX(DYNhelp,88)-(DYNX(DYNhelp,98)-DYNX(DYNhelp,99)-
      DYNX(DYNhelp,95)+DYNX(W_,317)+DYNX(W_,106)));
    SetVector(b, 6,  -(DYNX(W_,220)+DYNX(W_,139)-DYNX(W_,200)+DYNX(W_,106)));
    SetVector(b, 7,  -(DYNX(W_,253)+DYNX(W_,200)));
    SetVector(b, 8, DYNX(W_,48)-((-1.0)*DYNX(DYNhelp,102)-DYNX(DYNhelp,103)+
      DYNX(DYNhelp,104)+DYNX(DYNhelp,105)));
    SetVector(b, 9, DYNX(W_,46)-(DYNX(DYNhelp,107)-DYNX(DYNhelp,108)+
      DYNX(DYNhelp,109)));
    SetVector(b, 10,  -(DYNX(W_,149)+DYNX(W_,96)));
    SetVector(b, 11,  -(DYNX(DYNhelp,110)+DYNX(W_,263)+DYNX(W_,106)));
    SetVector(b, 12, DYNX(DYNhelp,111)-(DYNX(DYNhelp,107)+DYNX(DYNhelp,112)));
    SetVector(b, 13, DYNX(W_,106)+DYNX(DYNhelp,110)-DYNX(W_,210));
    SetVector(b, 14,  -((-1.0)*(DYNX(W_,220)-DYNX(W_,200))-DYNX(W_,106)+
      DYNX(W_,86)));
    SetVector(y, 1, RememberSimple_(DYNX(W_,204), 2));
    SetVector(y, 2, RememberSimple_(DYNX(W_,90), 3));
    SetVector(y, 3, RememberSimple_(DYNX(W_,110), 4));
    SetVector(y, 4, RememberSimple_(DYNX(W_,224), 5));
    SetVector(y, 5, RememberSimple_(DYNX(W_,163), 6));
    SetVector(y, 6, RememberSimple_(DYNX(W_,277), 7));
    SetVector(y, 7, RememberSimple_(DYNX(W_,311), 8));
    SetVector(y, 8, RememberSimple_(DYNX(W_,321), 9));
    SetVector(y, 9, RememberSimple_(DYNX(W_,143), 10));
    SetVector(y, 10, RememberSimple_(DYNX(W_,257), 11));
    SetVector(y, 11, RememberSimple_(DYNX(W_,100), 12));
    SetVector(y, 12, RememberSimple_(DYNX(W_,153), 13));
    SetVector(y, 13, RememberSimple_(DYNX(W_,267), 14));
    SetVector(y, 14, RememberSimple_(DYNX(W_,214), 15));
    SolveLinearSystemOfEquationsMixed(J, b, y, 2);
    DYNX(W_,204) = GetVector(y, 1);
    DYNX(W_,90) = GetVector(y, 2);
    DYNX(W_,110) = GetVector(y, 3);
    DYNX(W_,224) = GetVector(y, 4);
    DYNX(W_,163) = GetVector(y, 5);
    DYNX(W_,277) = GetVector(y, 6);
    DYNX(W_,311) = GetVector(y, 7);
    DYNX(W_,321) = GetVector(y, 8);
    DYNX(W_,143) = GetVector(y, 9);
    DYNX(W_,257) = GetVector(y, 10);
    DYNX(W_,100) = GetVector(y, 11);
    DYNX(W_,153) = GetVector(y, 12);
    DYNX(W_,267) = GetVector(y, 13);
    DYNX(W_,214) = GetVector(y, 14);
    EndStaticLinearSystemOfEquations(J);
  }
  DYNX(W_,175) = DYNX(W_,204)*DYNX(DYNhelp,630)+DYNX(DYNhelp,100);
  DYNX(W_,61) = DYNX(W_,90)*DYNX(DYNhelp,631)+DYNX(DYNhelp,101);
  DYNX(W_,63) = DYNX(W_,110)*DYNX(DYNhelp,618)+DYNX(DYNhelp,84);
  DYNX(W_,177) = DYNX(W_,224)*DYNX(DYNhelp,619)+DYNX(DYNhelp,85);
  DYNX(W_,119) = DYNX(W_,163)*DYNX(DYNhelp,620)+DYNX(DYNhelp,86);
  DYNX(W_,233) = DYNX(W_,277)*DYNX(DYNhelp,621)+DYNX(DYNhelp,87);
  DYNX(W_,217) = DYNX(W_,224)*DYNX(DYNhelp,622)+DYNX(W_,220);
  DYNX(W_,304) = DYNX(W_,311)*DYNX(DYNhelp,623)+DYNX(DYNhelp,90);
  DYNX(W_,37) = DYNX(W_,321)*DYNX(DYNhelp,626)+DYNX(DYNhelp,92);
  DYNX(W_,39) =  -(DYNX(W_,37)+DYNX(DYNhelp,94));
  DYNX(W_,22) = DYNX(W_,304)-DYNX(W_,39);
  DYNX(W_,16) =  -DYNX(W_,20)*DYNX(W_,22);
  DYNX(W_,303) = DYNX(W_,311)*DYNX(DYNhelp,625)+DYNX(W_,307);
  DYNX(W_,10) = DYNX(DYNhelp,94)-DYNX(W_,22);
  DYNX(W_,4) =  -DYNX(W_,8)*DYNX(W_,10);
  DYNX(W_,314) = DYNX(W_,321)*DYNX(DYNhelp,627)+DYNX(W_,317);
  DYNX(W_,2665) = DYNX(W_,2669)*DYNX(W_,37);
  DYNX(W_,2670) = DYNX(W_,2674)*DYNX(W_,39);
  DYNX(W_,117) = DYNX(W_,143)*DYNX(DYNhelp,632)+DYNX(DYNhelp,103);
  DYNX(W_,136) = DYNX(W_,143)*DYNX(DYNhelp,629)+DYNX(W_,139);
  DYNX(W_,197) = DYNX(W_,204)*DYNX(DYNhelp,628)+DYNX(W_,200);
  DYNX(W_,231) = DYNX(W_,257)*DYNX(DYNhelp,633)+DYNX(DYNhelp,104);
  DYNX(W_,283) = DYNX(W_,117)-(DYNX(DYNhelp,105)+DYNX(W_,39)+DYNX(W_,63)-
    DYNX(W_,119)+DYNX(W_,61));
  DYNX(W_,62) = DYNX(W_,100)*DYNX(DYNhelp,636)+DYNX(DYNhelp,108);
  DYNX(W_,118) = DYNX(W_,153)*DYNX(DYNhelp,637)+DYNX(DYNhelp,109);
  DYNX(W_,93) = DYNX(W_,100)*DYNX(DYNhelp,638)+DYNX(W_,96);
  DYNX(W_,260) = DYNX(W_,267)*DYNX(DYNhelp,639)+DYNX(W_,263);
  DYNX(W_,232) = DYNX(W_,267)*DYNX(DYNhelp,640)+DYNX(DYNhelp,112);
  DYNX(W_,176) = DYNX(W_,214)*DYNX(DYNhelp,641)+DYNX(DYNhelp,111);
  DYNX(W_,207) = DYNX(W_,214)*DYNX(DYNhelp,644)+DYNX(W_,210);
  DYNX(W_,103) = DYNX(W_,110)*DYNX(DYNhelp,617)+DYNX(W_,106);
  DYNX(W_,83) = DYNX(W_,90)*DYNX(DYNhelp,645)+DYNX(W_,86);
   /* End of Equation Block */ 


  MixedModeStartBoolean
  UpdateVariableNamed(DYNX(W_,89),"inverter2.transistor_p.idealGTOThyristor[1].off",
     Less(DYNX(W_,90),"inverter2.transistor_p.idealGTOThyristor[1].s", 0,"0", 42)
     OR  NOT DYNX(W_,80));
  UpdateVariableNamed(DYNX(W_,162),"inverter2.diode_p.idealDiode[3].off", Less(
    DYNX(W_,163),"inverter2.diode_p.idealDiode[3].s", 0,"0", 43));
  UpdateVariableNamed(DYNX(W_,223),"inverter2.transistor_n.idealGTOThyristor[3].off",
     Less(DYNX(W_,224),"inverter2.transistor_n.idealGTOThyristor[3].s", 0,"0", 44)
     OR  NOT DYNX(W_,196));
  UpdateVariableNamed(DYNX(W_,276),"inverter2.diode_n.idealDiode[3].off", Less(
    DYNX(W_,277),"inverter2.diode_n.idealDiode[3].s", 0,"0", 45));
  UpdateVariableNamed(DYNX(W_,266),"inverter2.diode_n.idealDiode[2].off", Less(
    DYNX(W_,267),"inverter2.diode_n.idealDiode[2].s", 0,"0", 46));
  UpdateVariableNamed(DYNX(W_,213),"inverter2.transistor_n.idealGTOThyristor[2].off",
     Less(DYNX(W_,214),"inverter2.transistor_n.idealGTOThyristor[2].s", 0,"0", 47)
     OR  NOT DYNX(W_,195));
  UpdateVariableNamed(DYNX(W_,152),"inverter2.diode_p.idealDiode[2].off", Less(
    DYNX(W_,153),"inverter2.diode_p.idealDiode[2].s", 0,"0", 48));
  UpdateVariableNamed(DYNX(W_,109),"inverter2.transistor_p.idealGTOThyristor[3].off",
     Less(DYNX(W_,110),"inverter2.transistor_p.idealGTOThyristor[3].s", 0,"0", 49)
     OR  NOT DYNX(W_,82));
  UpdateVariableNamed(DYNX(W_,203),"inverter2.transistor_n.idealGTOThyristor[1].off",
     Less(DYNX(W_,204),"inverter2.transistor_n.idealGTOThyristor[1].s", 0,"0", 50)
     OR  NOT DYNX(W_,194));
  UpdateVariableNamed(DYNX(W_,256),"inverter2.diode_n.idealDiode[1].off", Less(
    DYNX(W_,257),"inverter2.diode_n.idealDiode[1].s", 0,"0", 51));
  UpdateVariableNamed(DYNX(W_,99),"inverter2.transistor_p.idealGTOThyristor[2].off",
     Less(DYNX(W_,100),"inverter2.transistor_p.idealGTOThyristor[2].s", 0,"0", 52)
     OR  NOT DYNX(W_,81));
  UpdateVariableNamed(DYNX(W_,310),"dcdc.transistor.off", Less(DYNX(W_,311),
    "dcdc.transistor.s", 0,"0", 53) OR  NOT DYNX(W_,301));
  UpdateVariableNamed(DYNX(W_,320),"dcdc.diode.off", Less(DYNX(W_,321),
    "dcdc.diode.s", 0,"0", 54));
  UpdateVariableNamed(DYNX(W_,142),"inverter2.diode_p.idealDiode[1].off", Less(
    DYNX(W_,143),"inverter2.diode_p.idealDiode[1].s", 0,"0", 55));
  MixedModeInit(14, DYNX(DYNhelp,646))
  ThetaMixedCross(0,42)
  ThetaMixedCross(1,43)
  ThetaMixedCross(2,44)
  ThetaMixedCross(3,45)
  ThetaMixedCross(4,46)
  ThetaMixedCross(5,47)
  ThetaMixedCross(6,48)
  ThetaMixedCross(7,49)
  ThetaMixedCross(8,50)
  ThetaMixedCross(9,51)
  ThetaMixedCross(10,52)
  ThetaMixedCross(11,53)
  ThetaMixedCross(12,54)
  ThetaMixedCross(13,55)
  MixedModeEndBoolean
  UpdateReal(DYNX(W_,83), 1)
  UpdateReal(DYNX(W_,90), 2)
  UpdateReal(DYNX(W_,61), 3)
  UpdateReal(DYNX(W_,2670), 4)
  UpdateReal(DYNX(W_,217), 5)
  UpdateReal(DYNX(W_,224), 6)
  UpdateReal(DYNX(W_,177), 7)
  UpdateReal(DYNX(W_,110), 8)
  UpdateReal(DYNX(W_,63), 9)
  UpdateReal(DYNX(W_,204), 10)
  UpdateReal(DYNX(W_,175), 11)
  UpdateReal(DYNX(W_,136), 12)
  UpdateReal(DYNX(W_,197), 13)
  UpdateReal(DYNX(W_,257), 14)
  UpdateReal(DYNX(W_,231), 15)
  UpdateReal(DYNX(W_,283), 16)
  UpdateReal(DYNX(W_,100), 17)
  UpdateReal(DYNX(W_,62), 18)
  UpdateReal(DYNX(W_,118), 19)
  UpdateReal(DYNX(W_,153), 20)
  UpdateReal(DYNX(W_,93), 21)
  UpdateReal(DYNX(W_,207), 22)
  UpdateReal(DYNX(W_,214), 23)
  UpdateReal(DYNX(W_,176), 24)
  UpdateReal(DYNX(W_,232), 25)
  UpdateReal(DYNX(W_,267), 26)
  UpdateReal(DYNX(W_,260), 27)
  UpdateReal(DYNX(W_,277), 28)
  UpdateReal(DYNX(W_,233), 29)
  UpdateReal(DYNX(W_,119), 30)
  UpdateReal(DYNX(W_,163), 31)
  UpdateReal(DYNX(W_,103), 32)
  UpdateReal(DYNX(W_,16), 33)
  UpdateReal(DYNX(W_,303), 34)
  UpdateReal(DYNX(W_,311), 35)
  UpdateReal(DYNX(W_,304), 36)
  UpdateReal(DYNX(W_,22), 37)
  UpdateReal(DYNX(W_,10), 38)
  UpdateReal(DYNX(W_,4), 39)
  UpdateReal(DYNX(W_,321), 40)
  UpdateReal(DYNX(W_,314), 41)
  UpdateReal(DYNX(W_,2665), 42)
  UpdateReal(DYNX(W_,37), 43)
  UpdateReal(DYNX(W_,39), 44)
  UpdateReal(DYNX(W_,117), 45)
  UpdateReal(DYNX(W_,143), 46)
EndMixedSystemOfEquations

DYNX(W_,146) =  -DYNX(W_,93);
DYNX(W_,156) =  -DYNX(W_,103);
DYNX(W_,270) =  -DYNX(W_,217);
DYNX(W_,250) =  -DYNX(W_,197);
DYNX(W_,170) = DYNX(W_,119)-DYNX(W_,63);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(12);
DYNX(W_,47) =  -(DYNX(W_,2670)+DYNX(W_,16)+DYNX(W_,11)+DYNX(W_,270));
DYNX(W_,284) = DYNX(W_,48)+DYNX(W_,63)-DYNX(W_,119);
DYNX(W_,287) =  -(DYNX(W_,314)-DYNX(W_,1)+DYNX(W_,4));
DYNX(W_,9) = DYNX(W_,1)-DYNX(W_,4);
DYNX(W_,21) =  -(DYNX(W_,16)+DYNX(W_,11));
DYNX(W_,36) = DYNX(W_,103)-(DYNX(W_,2670)+DYNX(W_,16)+DYNX(W_,11)+DYNX(W_,270));
DYNX(W_,45) = DYNX(W_,103)-(DYNX(W_,2670)+DYNX(W_,16)+DYNX(W_,11)+DYNX(W_,270))-
  DYNX(W_,93);
DYNX(W_,282) =  -(DYNX(W_,283)+DYNX(W_,48)+DYNX(W_,63)-DYNX(W_,119)+DYNX(W_,39));
DYNX(W_,38) =  -(DYNX(W_,2670)+DYNX(W_,16)+DYNX(W_,11));
DYNX(W_,169) = DYNX(W_,46)-DYNX(W_,283);
DYNX(W_,168) = DYNX(W_,44)+DYNX(W_,48)+DYNX(W_,39)+DYNX(W_,283)+DYNX(W_,63)-
  DYNX(W_,119);
DYNX(W_,43) = DYNX(W_,197)-(DYNX(W_,2670)+DYNX(W_,16)+DYNX(W_,11));
DYNX(W_,433) = DYNX(W_,43)-DYNX(W_,453);
DYNX(W_,461) =  -DYNX(W_,465)*DYNX(W_,46);
DYNX(W_,434) = DYNX(W_,45)-DYNX(W_,461);
DYNX(W_,469) =  -DYNX(W_,473)*DYNX(W_,48);
DYNX(W_,435) = DYNX(W_,47)-DYNX(W_,469);
DYNX(W_,512) = (-0.3333333333333333)*(DYNX(W_,435)-2*DYNX(W_,434)+DYNX(W_,433));
DYNX(W_,426) = DYNX(W_,434)-DYNX(W_,512);
DYNX(W_,511) = DYNX(W_,433)-DYNX(W_,426);
DYNX(W_,513) = DYNX(W_,435)-DYNX(W_,426);
DYNX(W_,482) = 0.6666666666666666*DYNX(W_,511)-0.33333333333333315*DYNX(W_,512)-
  0.3333333333333336*DYNX(W_,513);
DYNX(W_,618) =  -DYNX(W_,605)*DYNX(DYNhelp,25);
DYNX(W_,620) = DYNX(W_,605)*DYNX(DYNhelp,24);
DYNX(W_,421) = DYNX(W_,616)*DYNX(X_,2)+DYNX(W_,617)*DYNX(X_,3);
DYNX(W_,623) = DYNX(W_,479)+DYNX(W_,421);
DYNX(W_,607) = DYNX(W_,629)*DYNX(W_,623);
DYNX(W_,483) = 0.5773502691896257*DYNX(W_,512)-0.5773502691896255*DYNX(W_,513);
DYNX(W_,621) =  -DYNX(W_,605)*DYNX(DYNhelp,25);

 /* Linear system of equations to solve. */
/* Tag: simulation.linear[3] */
/* Introducing 14 common subexpressions used in 24 expressions */
/* Of the common subexpressions 14 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,660) = DYNX(W_,618)*DYNX(X_,2);
DYNX(DYNhelp,661) = DYNX(W_,619)*DYNX(X_,3);
DYNX(DYNhelp,662) = DYNX(DYNhelp,660)+DYNX(DYNhelp,661);
DYNX(DYNhelp,663) = DYNX(W_,620)*DYNX(X_,2);
DYNX(DYNhelp,664) = DYNX(W_,621)*DYNX(X_,3);
DYNX(DYNhelp,665) = DYNX(DYNhelp,663)+DYNX(DYNhelp,664);
DYNX(DYNhelp,666) = DYNX(W_,629)*DYNX(W_,616);
DYNX(DYNhelp,667) = DYNX(W_,626)*DYNX(W_,614);
DYNX(DYNhelp,668) = DYNX(W_,618)*DYNX(W_,606);
DYNX(DYNhelp,669) = DYNX(W_,620)*DYNX(W_,607);
DYNX(DYNhelp,670) = DYNX(W_,629)*DYNX(W_,617);
DYNX(DYNhelp,671) = DYNX(W_,626)*DYNX(W_,615);
DYNX(DYNhelp,672) = DYNX(W_,619)*DYNX(W_,606);
DYNX(DYNhelp,673) = DYNX(W_,621)*DYNX(W_,607);
/* Automatic tearing of linear system of 14 simultaneous equations
gave a linear system of 4 equations for numerical solution.*/
{
  const char*const varnames_[]={"threePhaseMotor.aimc.lssigma.der(i_[2])", 
    "threePhaseMotor.aimc.der(idq_rr[1])", "threePhaseMotor.aimc.lssigma.der(i_[1])",
     "threePhaseMotor.aimc.der(idq_rr[2])"};
  const double nominal_[]={1, 1, 1, 1};
  DidLinearSystemOfEquations(J, b, y, 4, DYNX(DYNhelp,674), 64, DYNX(did_->helpvari_vec,32), 12);
  /* Jacobian depending on continuous variables */
  SetNeedFactor(J);
  if (NeedFactor(J)) {
    MatrixZeros(J);
    SetMatrixLeading(J, 1, 2, 4, (-1.0)*DYNX(DYNhelp,667));
    SetMatrixLeading(J, 1, 3, 4, (-1.0)*DYNX(W_,626)-DYNX(W_,474));
    SetMatrixLeading(J, 1, 4, 4, (-1.0)*DYNX(DYNhelp,671));
    SetMatrixLeading(J, 2, 1, 4, (-1.0)*DYNX(W_,629)-DYNX(W_,475));
    SetMatrixLeading(J, 2, 2, 4, (-1.0)*DYNX(DYNhelp,666));
    SetMatrixLeading(J, 2, 4, 4, (-1.0)*DYNX(DYNhelp,670));
    SetMatrixLeading(J, 3, 1, 4, DYNX(DYNhelp,666));
    SetMatrixLeading(J, 3, 2, 4, DYNX(W_,635)+DYNX(W_,629)+(DYNX(W_,626)-
      DYNX(W_,629))*sqr(DYNX(W_,614)));
    SetMatrixLeading(J, 3, 3, 4, DYNX(DYNhelp,667));
    SetMatrixLeading(J, 3, 4, 4, DYNX(DYNhelp,666)*DYNX(W_,617)+DYNX(DYNhelp,667)
      *DYNX(W_,615));
    SetMatrixLeading(J, 4, 1, 4, DYNX(DYNhelp,670));
    SetMatrixLeading(J, 4, 2, 4, DYNX(DYNhelp,670)*DYNX(W_,616)+DYNX(DYNhelp,671)
      *DYNX(W_,614));
    SetMatrixLeading(J, 4, 3, 4, DYNX(DYNhelp,671));
    SetMatrixLeading(J, 4, 4, 4, DYNX(W_,635)+DYNX(W_,626)+(DYNX(W_,629)-
      DYNX(W_,626))*sqr(DYNX(W_,617)));
  }
  SetVector(b, 1, DYNX(W_,626)*DYNX(DYNhelp,662)-DYNX(W_,482));
  SetVector(b, 2, DYNX(W_,629)*DYNX(DYNhelp,665)-DYNX(W_,483));
  SetVector(b, 3,  -(DYNX(W_,641)*DYNX(X_,2)+DYNX(DYNhelp,666)*DYNX(DYNhelp,665)
    +DYNX(DYNhelp,667)*DYNX(DYNhelp,662)+DYNX(DYNhelp,668)+DYNX(DYNhelp,669)));
  SetVector(b, 4,  -(DYNX(W_,641)*DYNX(X_,3)+DYNX(DYNhelp,670)*DYNX(DYNhelp,665)
    +DYNX(DYNhelp,671)*DYNX(DYNhelp,662)+DYNX(DYNhelp,672)+DYNX(DYNhelp,673)));
  SetVector(y, 1, RememberSimple_(DYNX(W_,481), 16));
  SetVector(y, 2, RememberSimple_(DYNX(F_,2), 17));
  SetVector(y, 3, RememberSimple_(DYNX(W_,480), 18));
  SetVector(y, 4, RememberSimple_(DYNX(F_,3), 19));
  SolveLinearSystemOfEquations(J, b, y, 3);
  DYNX(W_,481) = GetVector(y, 1);
  DYNX(F_,2) = GetVector(y, 2);
  DYNX(W_,480) = GetVector(y, 3);
  DYNX(F_,3) = GetVector(y, 4);
  EndStaticLinearSystemOfEquations(J);
}
DYNX(W_,423) = DYNX(DYNhelp,663)+DYNX(W_,616)*DYNX(F_,2)+DYNX(DYNhelp,664)+
  DYNX(W_,617)*DYNX(F_,3);
DYNX(W_,625) = DYNX(W_,481)+DYNX(W_,423);
DYNX(W_,609) = DYNX(W_,629)*DYNX(W_,625);
DYNX(W_,477) = DYNX(W_,483)-DYNX(W_,609);
DYNX(W_,422) = DYNX(DYNhelp,660)+DYNX(W_,614)*DYNX(F_,2)+DYNX(DYNhelp,661)+
  DYNX(W_,615)*DYNX(F_,3);
DYNX(W_,624) = DYNX(W_,480)+DYNX(W_,422);
DYNX(W_,608) = DYNX(W_,626)*DYNX(W_,624);
DYNX(W_,612) = DYNX(DYNhelp,668)+DYNX(W_,614)*DYNX(W_,608)+DYNX(DYNhelp,669)+
  DYNX(W_,616)*DYNX(W_,609);
DYNX(W_,476) = DYNX(W_,482)-DYNX(W_,608);
DYNX(W_,613) = DYNX(DYNhelp,672)+DYNX(W_,615)*DYNX(W_,608)+DYNX(DYNhelp,673)+
  DYNX(W_,617)*DYNX(W_,609);
 /* End of Equation Block */ 

DYNX(W_,365) = 1.5*DYNX(W_,603)*(DYNX(W_,479)*DYNX(W_,606)-DYNX(W_,478)*
  DYNX(W_,607));

 /* Linear system of equations to solve. */
/* Tag: simulation.linear[4] */
DYNX(F_,6) = RememberSimple_(DYNX(F_,6), 20);
SolveScalarLinearParametric(DYNX(W_,740)+DYNX(W_,366),"fan.inertia.J+threePhaseMotor.aimc.inertiaRotor.J",
   DYNX(W_,365),"threePhaseMotor.aimc.tauElectrical", DYNX(F_,6),
  "der(fan.inertia.w)");
DYNX(W_,650) = DYNX(W_,366)*DYNX(F_,6)-DYNX(W_,365);
 /* End of Equation Block */ 


 /* Linear system of equations to solve. */
/* Tag: simulation.linear[5] */
{
  const char*const varnames_[]={"threePhaseMotor.aimc.der(idq_sr[2])", 
    "threePhaseMotor.aimc.der(idq_sr[1])"};
  const double nominal_[]={1, 1};
  DidLinearSystemOfEquations(J, b, y, 2, DYNX(DYNhelp,738), 24, DYNX(did_->helpvari_vec,44), 8);
  /* Jacobian depending on continuous variables */
  SetNeedFactor(J);
  if (NeedFactor(J)) {
    MatrixZeros(J);
    SetMatrixLeading(J, 1, 1, 2,  -DYNX(W_,615));
    SetMatrixLeading(J, 1, 2, 2,  -DYNX(W_,614));
    SetMatrixLeading(J, 2, 1, 2,  -DYNX(W_,617));
    SetMatrixLeading(J, 2, 2, 2,  -DYNX(W_,616));
  }
  SetVector(b, 1, DYNX(W_,618)*DYNX(X_,0)+DYNX(W_,619)*DYNX(X_,1)-DYNX(W_,480));
  SetVector(b, 2, DYNX(W_,620)*DYNX(X_,0)+DYNX(W_,621)*DYNX(X_,1)-DYNX(W_,481));
  SetVector(y, 1, RememberSimple_(DYNX(F_,1), 21));
  SetVector(y, 2, RememberSimple_(DYNX(F_,0), 22));
  SolveLinearSystemOfEquations(J, b, y, 4);
  DYNX(F_,1) = GetVector(y, 1);
  DYNX(F_,0) = GetVector(y, 2);
  EndStaticLinearSystemOfEquations(J);
}
 /* End of Equation Block */ 

DYNX(W_,735) = DYNX(X_,6)-DYNX(W_,738);
if (NewParameters_) {
DYNX(DYNhelp,762) = divinvGuarded(DYNX(W_,733),"variableSpeedDrive_ThreePhase.currentController.T");
}
DYNX(F_,5) = DYNX(DYNhelp,762)*DYNX(W_,735);
DYNX(W_,1891) = Greater( -DYNX(X_,16)," -simpleLine2.inductor.i", DYNX(W_,1899),
  "circuitBreaker5.cB_Trigger.const.k", 56);
 /* Linear system of equations to solve. */
DYNX(W_,1892) = RememberSimple_(DYNX(W_,1892), 23);
SolveScalarLinear(IF DYNX(W_,1891) THEN DYNX(DP_,257) ELSE 1,"(if circuitBreaker5.switch.off then circuitBreaker5.switch.Goff else 1)",
    -DYNX(X_,16)," -simpleLine2.inductor.i", DYNX(W_,1892),"circuitBreaker5.switch.s");
 /* End of Equation Block */ 

DYNX(W_,1867) =  -DYNX(W_,1892)*(IF DYNX(W_,1891) THEN 1 ELSE DYNX(DP_,256));
DYNX(W_,1869) =  -DYNX(W_,1873)*DYNX(X_,16);
DYNX(W_,1918) = Greater( -DYNX(X_,16)," -simpleLine2.inductor.i", DYNX(W_,1922),
  "circuitBreaker7.cB_Trigger.const.k", 57);
 /* Linear system of equations to solve. */
DYNX(W_,1919) = RememberSimple_(DYNX(W_,1919), 24);
SolveScalarLinear(IF DYNX(W_,1918) THEN DYNX(DP_,269) ELSE 1,"(if circuitBreaker7.switch.off then circuitBreaker7.switch.Goff else 1)",
    -DYNX(X_,16)," -simpleLine2.inductor.i", DYNX(W_,1919),"circuitBreaker7.switch.s");
 /* End of Equation Block */ 

DYNX(W_,1913) = DYNX(W_,1919)*(IF DYNX(W_,1918) THEN 1 ELSE DYNX(DP_,268));
DYNX(W_,1324) = DYNX(W_,1323)*(DYNX(X_,11)-DYNX(DP_,118));
DYNX(W_,1334) = cos(DYNX(W_,1324));
DYNX(DYNhelp,763) = sin(DYNX(W_,1324));
DYNX(W_,1335) =  -DYNX(DYNhelp,763);
DYNX(W_,1198) = DYNX(W_,1334)*DYNX(X_,7)+DYNX(W_,1335)*DYNX(X_,8);
DYNX(W_,1336) = DYNX(DYNhelp,763);
DYNX(W_,1337) = DYNX(W_,1334);
DYNX(W_,1199) = DYNX(W_,1336)*DYNX(X_,7)+DYNX(W_,1337)*DYNX(X_,8);

 /* Linear system of equations to solve. */
/* Tag: simulation.linear[6] */
/* Automatic tearing of linear system of 3 simultaneous equations
gave a linear system of 2 equations for numerical solution.*/
{
  const char*const varnames_[]={"inverter1.ac.pin[3].i", "inverter1.ac.pin[1].i"};
  const double nominal_[]={1, 1};
  static double J__internal[4]={-1.154700538379252, -1.3322676295501878E-15, 
    1.154700538379252, 3.000000000000001};
  static SizeType J__dims[2]={2,2};
  static RealArray J={2,J__dims,J__internal};
  static int J__m=2;
  static int factoredForParametersV_=0;
  int*factoredForParametersP_=&factoredForParametersV_;
  static double J__DWork[16]={-1.154700538379252, 1.153777611830138E-15, 
    1.154700538379252, 2.9999999999999996, -1.5326920704511053, -0.6666666666666672,
     -0.8660254037844387, -3.845925372767127E-16, 1.153777611830138E-15, 0.0, 
    0.0, 1.154700538379252, 0.8660254037844384, 0.33333333333333326, 1.0, 1.0};
  static int J__IWork[5]={1, 2, 0, -1, -1};
  static int J__FactoredV=1;
  int* J__FactoredP=&(J__FactoredV);
  DeclareDidRealVector1(b, 2, DYNX(DYNhelp,764));
  DeclareDidRealVector1(y, 2, DYNX(DYNhelp,766));
  DeclareDidRealVector2(b, 2, DYNX(DYNhelp,764));
  DeclareDidRealVector2(y, 2, DYNX(DYNhelp,766));
  RealFillAssign(b,0.0);
  SetVector(b, 1,  -(DYNX(W_,1199)+1.7320508075688783*DYNX(W_,1198)));
  SetVector(b, 2, (-3.0000000000000018)*DYNX(W_,1198));
  SetVector(y, 1, RememberSimple_(DYNX(W_,765), 25));
  SetVector(y, 2, RememberSimple_(DYNX(W_,761), 26));
  SolveLinearSystemOfEquations(J, b, y, 5);
  DYNX(W_,765) = GetVector(y, 1);
  DYNX(W_,761) = GetVector(y, 2);
  EndStaticLinearSystemOfEquations(J);
}
DYNX(W_,763) = 3.0000000000000018*(DYNX(W_,1198)-0.3333333333333336*DYNX(W_,765)
  +0.6666666666666666*DYNX(W_,761));
 /* End of Equation Block */ 

DYNX(W_,1907) = Greater(DYNX(X_,16),"simpleLine2.inductor.i", DYNX(W_,1911),
  "circuitBreaker6.cB_Trigger.const.k", 58);
 /* Linear system of equations to solve. */
DYNX(W_,1908) = RememberSimple_(DYNX(W_,1908), 27);
SolveScalarLinear( -(IF DYNX(W_,1907) THEN DYNX(DP_,263) ELSE 1),
  " -(if circuitBreaker6.switch.off then circuitBreaker6.switch.Goff else 1)", 
   -DYNX(X_,16)," -simpleLine2.inductor.i", DYNX(W_,1908),"circuitBreaker6.switch.s");
 /* End of Equation Block */ 

DYNX(W_,1902) = DYNX(W_,1908)*(IF DYNX(W_,1907) THEN 1 ELSE DYNX(DP_,262));
DYNX(W_,1858) = DYNX(W_,1862)*DYNX(X_,16);
DYNX(W_,1880) = Greater(DYNX(X_,16),"simpleLine2.inductor.i", DYNX(W_,1884),
  "circuitBreaker4.cB_Trigger.const.k", 59);
 /* Linear system of equations to solve. */
DYNX(W_,1881) = RememberSimple_(DYNX(W_,1881), 28);
SolveScalarLinear( -(IF DYNX(W_,1880) THEN DYNX(DP_,251) ELSE 1),
  " -(if circuitBreaker4.switch.off then circuitBreaker4.switch.Goff else 1)", 
   -DYNX(X_,16)," -simpleLine2.inductor.i", DYNX(W_,1881),"circuitBreaker4.switch.s");
 /* End of Equation Block */ 

DYNX(W_,1875) = DYNX(W_,1881)*(IF DYNX(W_,1880) THEN 1 ELSE DYNX(DP_,250));

MixedSystemOfEquations(1, DYNX(DYNhelp,768))
   /* Linear system of equations to solve. */
  DYNX(W_,1041) = RememberSimple_(DYNX(W_,1041), 29);
  SolveScalarLinearMixed( -(IF DYNX(W_,1040) THEN DYNX(W_,1036) ELSE 1),
    " -(if dcdc1.diode.off then dcdc1.diode.Goff else 1)", DYNX(W_,1036)*
    DYNX(W_,1037)-DYNX(X_,16),"dcdc1.diode.Goff*dcdc1.diode.Vknee-simpleLine2.inductor.i",
     DYNX(W_,1041),"dcdc1.diode.s");
   /* End of Equation Block */ 


  MixedModeStartBoolean
  UpdateVariableNamed(DYNX(W_,1040),"dcdc1.diode.off", Less(DYNX(W_,1041),
    "dcdc1.diode.s", 0,"0", 60));
  MixedModeInit(1, DYNX(DYNhelp,769))
  ThetaMixedCross(0,60)
  MixedModeEndBoolean
  UpdateReal(DYNX(W_,1041), 1)
EndMixedSystemOfEquations

DYNX(W_,1034) = DYNX(W_,1041)*(IF DYNX(W_,1040) THEN 1 ELSE DYNX(W_,1035))+
  DYNX(W_,1037);
beginwhenBlock
if (NewParameters_) {
DYNX(DYNhelp,770) = divinvGuarded(DYNX(W_,1059),"signalPWM1.sawtooth.period");
}
DYNX(DYNhelp,771) = real2integer(DYNX(DYNhelp,770)*(DYNTime-DYNX(W_,1062)));
whenModelica(real2integerEventMinor(divGuarded(DYNTime-DYNX(W_,1062),
  "time-signalPWM1.sawtooth.startTime",DYNX(W_,1059),"signalPWM1.sawtooth.period"),
  "(time-signalPWM1.sawtooth.startTime)/signalPWM1.sawtooth.period", 4) > PRE(
  DYNX(W_,1064), 34), 4) 
  DYNX(W_,1063) = DYNTime;
endwhenModelica()
endwhenBlock


DYNX(W_,1051) = IF LessTime(DYNX(W_,1062), 10) THEN 0 ELSE divGuarded(DYNTime-
  DYNX(W_,1063),"time-signalPWM1.sawtooth.T_start",DYNX(W_,1059),
  "signalPWM1.sawtooth.period");
DYNX(W_,1052) = PRE(DYNX(W_,1057), 35);
DYNX(W_,1023) = Less(DYNX(W_,1051),"signalPWM1.greaterEqual.u1", DYNX(W_,1052),
  "signalPWM1.greaterEqual.u2", 61);
DYNX(W_,1022) = DYNX(W_,1023) AND DYNX(W_,1020);

MixedSystemOfEquations(1, DYNX(DYNhelp,772))
   /* Linear system of equations to solve. */
  DYNX(W_,1031) = RememberSimple_(DYNX(W_,1031), 30);
  SolveScalarLinearMixed(IF DYNX(W_,1030) THEN DYNX(W_,1026) ELSE 1,
    "(if dcdc1.transistor.off then dcdc1.transistor.Goff else 1)",  -(
    DYNX(X_,16)+DYNX(W_,1026)*DYNX(W_,1027))," -(simpleLine2.inductor.i+dcdc1.transistor.Goff*dcdc1.transistor.Vknee)",
     DYNX(W_,1031),"dcdc1.transistor.s");
   /* End of Equation Block */ 


  MixedModeStartBoolean
  UpdateVariableNamed(DYNX(W_,1030),"dcdc1.transistor.off", Less(DYNX(W_,1031),
    "dcdc1.transistor.s", 0,"0", 62) OR  NOT DYNX(W_,1022));
  MixedModeInit(1, DYNX(DYNhelp,773))
  ThetaMixedCross(0,62)
  MixedModeEndBoolean
  UpdateReal(DYNX(W_,1031), 1)
EndMixedSystemOfEquations

DYNX(W_,1002) = DYNX(W_,1031)*(IF DYNX(W_,1030) THEN 1 ELSE DYNX(W_,1025))+
  DYNX(W_,1027);
DYNX(W_,1008) = DYNX(W_,1002)-DYNX(W_,1034);
DYNX(W_,1856) = DYNX(W_,1008)-DYNX(W_,1875);
beginwhenBlock
if (NewParameters_) {
DYNX(DYNhelp,774) = divinvGuarded(DYNX(W_,1426),"signalPWM3[2].sawtooth.period");
}
DYNX(DYNhelp,775) = real2integer(DYNX(DYNhelp,774)*(DYNTime-DYNX(W_,1429)));
whenModelica(real2integerEventMinor(divGuarded(DYNTime-DYNX(W_,1429),
  "time-signalPWM3[2].sawtooth.startTime",DYNX(W_,1426),"signalPWM3[2].sawtooth.period"),
  "(time-signalPWM3[2].sawtooth.startTime)/signalPWM3[2].sawtooth.period", 5) > 
  PRE(DYNX(W_,1431), 36), 5) 
  DYNX(W_,1430) = DYNTime;
endwhenModelica()
endwhenBlock


DYNX(W_,1418) = IF LessTime(DYNX(W_,1429), 11) THEN 0 ELSE divGuarded(DYNTime-
  DYNX(W_,1430),"time-signalPWM3[2].sawtooth.T_start",DYNX(W_,1426),
  "signalPWM3[2].sawtooth.period");
DYNX(W_,1419) = PRE(DYNX(W_,1424), 37);
DYNX(W_,753) = Less(DYNX(W_,1418),"signalPWM3[2].greaterEqual.u1", DYNX(W_,1419),
  "signalPWM3[2].greaterEqual.u2", 63);
DYNX(W_,912) = DYNX(W_,753) AND DYNX(W_,750);
DYNX(W_,745) =  NOT DYNX(W_,753);
DYNX(W_,798) = DYNX(W_,745) AND DYNX(W_,750);
beginwhenBlock
if (NewParameters_) {
DYNX(DYNhelp,776) = divinvGuarded(DYNX(W_,1445),"signalPWM3[3].sawtooth.period");
}
DYNX(DYNhelp,777) = real2integer(DYNX(DYNhelp,776)*(DYNTime-DYNX(W_,1448)));
whenModelica(real2integerEventMinor(divGuarded(DYNTime-DYNX(W_,1448),
  "time-signalPWM3[3].sawtooth.startTime",DYNX(W_,1445),"signalPWM3[3].sawtooth.period"),
  "(time-signalPWM3[3].sawtooth.startTime)/signalPWM3[3].sawtooth.period", 6) > 
  PRE(DYNX(W_,1450), 38), 6) 
  DYNX(W_,1449) = DYNTime;
endwhenModelica()
endwhenBlock


DYNX(W_,1437) = IF LessTime(DYNX(W_,1448), 12) THEN 0 ELSE divGuarded(DYNTime-
  DYNX(W_,1449),"time-signalPWM3[3].sawtooth.T_start",DYNX(W_,1445),
  "signalPWM3[3].sawtooth.period");
DYNX(W_,1438) = PRE(DYNX(W_,1443), 39);
DYNX(W_,754) = Less(DYNX(W_,1437),"signalPWM3[3].greaterEqual.u1", DYNX(W_,1438),
  "signalPWM3[3].greaterEqual.u2", 64);
DYNX(W_,913) = DYNX(W_,754) AND DYNX(W_,750);
DYNX(W_,746) =  NOT DYNX(W_,754);
DYNX(W_,799) = DYNX(W_,746) AND DYNX(W_,750);
beginwhenBlock
if (NewParameters_) {
DYNX(DYNhelp,778) = divinvGuarded(DYNX(W_,1407),"signalPWM3[1].sawtooth.period");
}
DYNX(DYNhelp,779) = real2integer(DYNX(DYNhelp,778)*(DYNTime-DYNX(W_,1410)));
whenModelica(real2integerEventMinor(divGuarded(DYNTime-DYNX(W_,1410),
  "time-signalPWM3[1].sawtooth.startTime",DYNX(W_,1407),"signalPWM3[1].sawtooth.period"),
  "(time-signalPWM3[1].sawtooth.startTime)/signalPWM3[1].sawtooth.period", 7) > 
  PRE(DYNX(W_,1412), 40), 7) 
  DYNX(W_,1411) = DYNTime;
endwhenModelica()
endwhenBlock


DYNX(W_,1399) = IF LessTime(DYNX(W_,1410), 13) THEN 0 ELSE divGuarded(DYNTime-
  DYNX(W_,1411),"time-signalPWM3[1].sawtooth.T_start",DYNX(W_,1407),
  "signalPWM3[1].sawtooth.period");
DYNX(W_,1400) = PRE(DYNX(W_,1405), 41);
DYNX(W_,752) = Less(DYNX(W_,1399),"signalPWM3[1].greaterEqual.u1", DYNX(W_,1400),
  "signalPWM3[1].greaterEqual.u2", 65);
DYNX(W_,744) =  NOT DYNX(W_,752);
DYNX(W_,797) = DYNX(W_,744) AND DYNX(W_,750);
DYNX(W_,911) = DYNX(W_,752) AND DYNX(W_,750);

MixedSystemOfEquations(37, DYNX(DYNhelp,780))

   /* Linear system of equations to solve. */
  /* Tag: simulation.linear[7] */
  /* Introducing 59 common subexpressions used in 78 expressions */
  /* Of the common subexpressions 59 are reals, 0 are integers, and 0
     are booleans. */
  DYNX(DYNhelp,817) = DYNX(W_,1913)+DYNX(W_,1869)-DYNX(W_,1867);
  DYNX(DYNhelp,818) = DYNX(W_,1858)-DYNX(W_,1856);
  DYNX(DYNhelp,819) = DYNX(W_,1902)+DYNX(DYNhelp,818);
  DYNX(DYNhelp,820) = DYNX(DYNhelp,817)-DYNX(DYNhelp,819);
  DYNX(DYNhelp,821) = DYNX(DYNhelp,819)-DYNX(DYNhelp,817);
  DYNX(DYNhelp,822) = DYNX(W_,822)*DYNX(W_,823);
  DYNX(DYNhelp,823) = DYNX(W_,936)*DYNX(W_,937);
  DYNX(DYNhelp,824) = DYNX(W_,989)*DYNX(W_,990);
  DYNX(DYNhelp,825) = DYNX(W_,875)*DYNX(W_,876);
  DYNX(DYNhelp,826) = (-1.0)*DYNX(W_,823)-DYNX(W_,937);
  DYNX(DYNhelp,827) = (-1.0)*(DYNX(DYNhelp,823)-DYNX(DYNhelp,824));
  DYNX(DYNhelp,828) = DYNX(W_,812)*DYNX(W_,813);
  DYNX(DYNhelp,829) = DYNX(DYNhelp,827)-DYNX(DYNhelp,828);
  DYNX(DYNhelp,830) = DYNX(W_,916)*DYNX(W_,917);
  DYNX(DYNhelp,831) = DYNX(W_,969)*DYNX(W_,970);
  DYNX(DYNhelp,832) = DYNX(W_,865)*DYNX(W_,866);
  DYNX(DYNhelp,833) = DYNX(W_,823)+DYNX(W_,937);
  DYNX(DYNhelp,834) = DYNX(DYNhelp,833)+DYNX(DYNhelp,821);
  DYNX(DYNhelp,835) = DYNX(W_,802)*DYNX(W_,803);
  DYNX(DYNhelp,836) = DYNX(W_,855)*DYNX(W_,856);
  DYNX(DYNhelp,837) = DYNX(W_,926)*DYNX(W_,927);
  DYNX(DYNhelp,838) = DYNX(W_,979)*DYNX(W_,980);
  /* Automatic tearing of linear system of 37 simultaneous equations
  gave a linear system of 13 equations for numerical solution.*/
  {
    const char*const varnames_[]={"inverter1.transistor_n.idealGTOThyristor[2].s",
       "inverter1.transistor_p.idealGTOThyristor[3].s", "inverter1.transistor_n.idealGTOThyristor[3].s",
       "inverter1.diode_n.idealDiode[3].s", "inverter1.diode_p.idealDiode[3].s",
       "inverter1.transistor_p.idealGTOThyristor[2].s", "inverter1.transistor_n.idealGTOThyristor[1].s",
       "inverter1.diode_n.idealDiode[1].s", "simpleLine2.inductor.der(i)", 
      "inverter1.transistor_p.idealGTOThyristor[1].s", "inverter1.diode_p.idealDiode[1].s",
       "inverter1.diode_p.idealDiode[2].s", "inverter1.diode_n.idealDiode[2].s"};
    const double nominal_[]={1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
    DidLinearSystemOfEquations(J, b, y, 13, DYNX(DYNhelp,839), 442, 
      DYNX(did_->helpvari_vec,52), 30);
    /* Jacobian depending on discrete variables */
    /* Special case for simplified event handling */
    #if defined(EventIterate_) && (EventIterate_==0)
    SetNeedFactor(J);
    #else
    if (NewParametersJac||DYNEvent|| dymolaEventsNr_!=*(factoredForEventsP_))
       SetNeedFactor(J);
    #endif
    if (NeedFactor(J)) {
      *(factoredForEventsP_)=dymolaEventsNr_;
      MatrixZeros(J);
      DYNX(DYNhelp,1281) = IF DYNX(W_,940) THEN 1 ELSE DYNX(W_,935);
      DYNX(DYNhelp,1282) = IF DYNX(W_,826) THEN 1 ELSE DYNX(W_,821);
      DYNX(DYNhelp,1283) = IF DYNX(W_,879) THEN 1 ELSE DYNX(W_,874);
      DYNX(DYNhelp,1284) = IF DYNX(W_,826) THEN DYNX(W_,822) ELSE 1;
      DYNX(DYNhelp,1285) = IF DYNX(W_,940) THEN DYNX(W_,936) ELSE 1;
      DYNX(DYNhelp,1286) = IF DYNX(W_,993) THEN DYNX(W_,989) ELSE 1;
      DYNX(DYNhelp,1287) = IF DYNX(W_,879) THEN DYNX(W_,875) ELSE 1;
      DYNX(DYNhelp,1288) = IF DYNX(W_,930) THEN 1 ELSE DYNX(W_,925);
      DYNX(DYNhelp,1289) = (-1.0)*DYNX(DYNhelp,1282);
      DYNX(DYNhelp,1290) = (-1.0)*DYNX(DYNhelp,1281);
      DYNX(DYNhelp,1291) = IF DYNX(W_,816) THEN 1 ELSE DYNX(W_,811);
      DYNX(DYNhelp,1292) = (-1.0)*DYNX(DYNhelp,1285);
      DYNX(DYNhelp,1293) = IF DYNX(W_,816) THEN DYNX(W_,812) ELSE 1;
      DYNX(DYNhelp,1294) = (-1.0)*DYNX(DYNhelp,1293);
      DYNX(DYNhelp,1295) = IF DYNX(W_,920) THEN DYNX(W_,916) ELSE 1;
      DYNX(DYNhelp,1296) = IF DYNX(W_,973) THEN DYNX(W_,969) ELSE 1;
      DYNX(DYNhelp,1297) = IF DYNX(W_,869) THEN DYNX(W_,865) ELSE 1;
      DYNX(DYNhelp,1298) = IF DYNX(W_,920) THEN 1 ELSE DYNX(W_,915);
      DYNX(DYNhelp,1299) = IF DYNX(W_,806) THEN 1 ELSE DYNX(W_,801);
      DYNX(DYNhelp,1300) = IF DYNX(W_,806) THEN DYNX(W_,802) ELSE 1;
      DYNX(DYNhelp,1301) = IF DYNX(W_,859) THEN DYNX(W_,855) ELSE 1;
      DYNX(DYNhelp,1302) = IF DYNX(W_,859) THEN 1 ELSE DYNX(W_,854);
      DYNX(DYNhelp,1303) = IF DYNX(W_,869) THEN 1 ELSE DYNX(W_,864);
      DYNX(DYNhelp,1304) = IF DYNX(W_,930) THEN DYNX(W_,926) ELSE 1;
      DYNX(DYNhelp,1305) = IF DYNX(W_,983) THEN DYNX(W_,979) ELSE 1;
      SetMatrixLeading(J, 1, 3, 13, DYNX(DYNhelp,1281));
      SetMatrixLeading(J, 1, 4, 13, IF DYNX(W_,993) THEN 1 ELSE DYNX(W_,988));
      SetMatrixLeading(J, 2, 2, 13, DYNX(DYNhelp,1282));
      SetMatrixLeading(J, 2, 5, 13, DYNX(DYNhelp,1283));
      SetMatrixLeading(J, 3, 2, 13, (-1.0)*DYNX(DYNhelp,1284));
      SetMatrixLeading(J, 3, 3, 13, DYNX(DYNhelp,1285));
      SetMatrixLeading(J, 3, 4, 13, (-1.0)*DYNX(DYNhelp,1286));
      SetMatrixLeading(J, 3, 5, 13, DYNX(DYNhelp,1287));
      SetMatrixLeading(J, 4, 1, 13, DYNX(DYNhelp,1288));
      SetMatrixLeading(J, 4, 2, 13, DYNX(DYNhelp,1289));
      SetMatrixLeading(J, 4, 3, 13, DYNX(DYNhelp,1290));
      SetMatrixLeading(J, 4, 6, 13, DYNX(DYNhelp,1291));
      SetMatrixLeading(J, 5, 3, 13, DYNX(DYNhelp,1292));
      SetMatrixLeading(J, 5, 4, 13, DYNX(DYNhelp,1286));
      SetMatrixLeading(J, 5, 6, 13, DYNX(DYNhelp,1294));
      SetMatrixLeading(J, 5, 7, 13, (-1.0)*DYNX(DYNhelp,1295));
      SetMatrixLeading(J, 5, 8, 13, DYNX(DYNhelp,1296));
      SetMatrixLeading(J, 5, 12, 13, DYNX(DYNhelp,1297));
      SetMatrixLeading(J, 6, 7, 13, DYNX(DYNhelp,1298));
      SetMatrixLeading(J, 6, 8, 13, IF DYNX(W_,973) THEN 1 ELSE DYNX(W_,968));
      SetMatrixLeading(J, 7, 2, 13, DYNX(DYNhelp,1282));
      SetMatrixLeading(J, 7, 3, 13, DYNX(DYNhelp,1281));
      SetMatrixLeading(J, 7, 9, 13, DYNX(W_,1866)+DYNX(W_,1855));
      SetMatrixLeading(J, 8, 2, 13, DYNX(DYNhelp,1289));
      SetMatrixLeading(J, 8, 3, 13, DYNX(DYNhelp,1290));
      SetMatrixLeading(J, 8, 7, 13, DYNX(DYNhelp,1298));
      SetMatrixLeading(J, 8, 10, 13, DYNX(DYNhelp,1299));
      SetMatrixLeading(J, 9, 3, 13, DYNX(DYNhelp,1292));
      SetMatrixLeading(J, 9, 4, 13, DYNX(DYNhelp,1286));
      SetMatrixLeading(J, 9, 6, 13, DYNX(DYNhelp,1294));
      SetMatrixLeading(J, 9, 10, 13, (-1.0)*DYNX(DYNhelp,1300));
      SetMatrixLeading(J, 9, 11, 13, DYNX(DYNhelp,1301));
      SetMatrixLeading(J, 9, 12, 13, DYNX(DYNhelp,1297));
      SetMatrixLeading(J, 10, 2, 13, DYNX(DYNhelp,1282));
      SetMatrixLeading(J, 10, 3, 13, DYNX(DYNhelp,1281));
      SetMatrixLeading(J, 10, 7, 13, (-1.0)*DYNX(DYNhelp,1298));
      SetMatrixLeading(J, 10, 11, 13, DYNX(DYNhelp,1302));
      SetMatrixLeading(J, 11, 1, 13, (-1.0)*DYNX(DYNhelp,1288));
      SetMatrixLeading(J, 11, 2, 13, DYNX(DYNhelp,1282));
      SetMatrixLeading(J, 11, 3, 13, DYNX(DYNhelp,1281));
      SetMatrixLeading(J, 11, 12, 13, DYNX(DYNhelp,1303));
      SetMatrixLeading(J, 12, 1, 13, (-1.0)*DYNX(DYNhelp,1304));
      SetMatrixLeading(J, 12, 6, 13, DYNX(DYNhelp,1293));
      SetMatrixLeading(J, 12, 12, 13, (-1.0)*DYNX(DYNhelp,1297));
      SetMatrixLeading(J, 12, 13, 13, DYNX(DYNhelp,1305));
      SetMatrixLeading(J, 13, 1, 13, DYNX(DYNhelp,1288));
      SetMatrixLeading(J, 13, 13, 13, IF DYNX(W_,983) THEN 1 ELSE DYNX(W_,978));
    }
    SetVector(b, 1,  -(DYNX(W_,990)+DYNX(W_,937)));
    SetVector(b, 2,  -(DYNX(DYNhelp,820)+DYNX(W_,823)+DYNX(W_,876)+
      DYNX(DYNhelp,821)));
    SetVector(b, 3, DYNX(W_,765)-((-1.0)*(DYNX(DYNhelp,822)-DYNX(DYNhelp,823))-
      DYNX(DYNhelp,824)+DYNX(DYNhelp,825)));
    SetVector(b, 4,  -(DYNX(DYNhelp,821)+DYNX(DYNhelp,826)+DYNX(W_,813)-
      DYNX(DYNhelp,819)+DYNX(DYNhelp,817)+DYNX(W_,927)));
    SetVector(b, 5,  -(DYNX(X_,16)-DYNX(W_,763)+DYNX(DYNhelp,829)-
      DYNX(DYNhelp,830)+DYNX(DYNhelp,831)+DYNX(DYNhelp,832)));
    SetVector(b, 6,  -(DYNX(W_,970)+DYNX(W_,917)));
    SetVector(b, 7,  -DYNX(DYNhelp,834));
    SetVector(b, 8,  -(DYNX(DYNhelp,821)+DYNX(DYNhelp,826)+DYNX(W_,917)-
      DYNX(DYNhelp,819)+DYNX(DYNhelp,817)+DYNX(W_,803)));
    SetVector(b, 9,  -(DYNX(W_,765)+DYNX(X_,16)+DYNX(DYNhelp,829)-
      DYNX(DYNhelp,835)+DYNX(DYNhelp,836)+DYNX(DYNhelp,832)));
    SetVector(b, 10,  -(DYNX(DYNhelp,820)+DYNX(DYNhelp,833)-DYNX(W_,917)+
      DYNX(DYNhelp,821)+DYNX(W_,856)));
    SetVector(b, 11,  -(DYNX(DYNhelp,820)+DYNX(DYNhelp,834)+DYNX(W_,866)-
      DYNX(W_,927)));
    SetVector(b, 12,  -(DYNX(W_,763)+(-1.0)*(DYNX(DYNhelp,837)-DYNX(DYNhelp,828))
      -DYNX(DYNhelp,832)+DYNX(DYNhelp,838)));
    SetVector(b, 13,  -(DYNX(W_,980)+DYNX(W_,927)));
    SetVector(y, 1, RememberSimple_(DYNX(W_,931), 31));
    SetVector(y, 2, RememberSimple_(DYNX(W_,827), 32));
    SetVector(y, 3, RememberSimple_(DYNX(W_,941), 33));
    SetVector(y, 4, RememberSimple_(DYNX(W_,994), 34));
    SetVector(y, 5, RememberSimple_(DYNX(W_,880), 35));
    SetVector(y, 6, RememberSimple_(DYNX(W_,817), 36));
    SetVector(y, 7, RememberSimple_(DYNX(W_,921), 37));
    SetVector(y, 8, RememberSimple_(DYNX(W_,974), 38));
    SetVector(y, 9, RememberSimple_(DYNX(F_,16), 39));
    SetVector(y, 10, RememberSimple_(DYNX(W_,807), 40));
    SetVector(y, 11, RememberSimple_(DYNX(W_,860), 41));
    SetVector(y, 12, RememberSimple_(DYNX(W_,870), 42));
    SetVector(y, 13, RememberSimple_(DYNX(W_,984), 43));
    SolveLinearSystemOfEquationsMixed(J, b, y, 6);
    DYNX(W_,931) = GetVector(y, 1);
    DYNX(W_,827) = GetVector(y, 2);
    DYNX(W_,941) = GetVector(y, 3);
    DYNX(W_,994) = GetVector(y, 4);
    DYNX(W_,880) = GetVector(y, 5);
    DYNX(W_,817) = GetVector(y, 6);
    DYNX(W_,921) = GetVector(y, 7);
    DYNX(W_,974) = GetVector(y, 8);
    DYNX(F_,16) = GetVector(y, 9);
    DYNX(W_,807) = GetVector(y, 10);
    DYNX(W_,860) = GetVector(y, 11);
    DYNX(W_,870) = GetVector(y, 12);
    DYNX(W_,984) = GetVector(y, 13);
    EndStaticLinearSystemOfEquations(J);
  }
  DYNX(W_,893) = DYNX(W_,931)*DYNX(DYNhelp,1304)+DYNX(DYNhelp,837);
  DYNX(W_,820) = DYNX(W_,827)*DYNX(DYNhelp,1282)+DYNX(W_,823);
  DYNX(W_,780) = DYNX(W_,827)*DYNX(DYNhelp,1284)+DYNX(DYNhelp,822);
  DYNX(W_,894) = DYNX(W_,941)*DYNX(DYNhelp,1285)+DYNX(DYNhelp,823);
  DYNX(W_,950) = DYNX(W_,994)*DYNX(DYNhelp,1286)+DYNX(DYNhelp,824);
  DYNX(W_,934) = DYNX(W_,941)*DYNX(DYNhelp,1281)+DYNX(W_,937);
  DYNX(W_,873) = DYNX(W_,880)*DYNX(DYNhelp,1283)+DYNX(W_,876);
  DYNX(W_,836) = DYNX(W_,880)*DYNX(DYNhelp,1287)+DYNX(DYNhelp,825);
  DYNX(W_,1001) = DYNX(W_,894)-DYNX(W_,950);
  DYNX(W_,810) = DYNX(W_,817)*DYNX(DYNhelp,1291)+DYNX(W_,813);
  DYNX(W_,779) = DYNX(W_,817)*DYNX(DYNhelp,1293)+DYNX(DYNhelp,828);
  DYNX(W_,892) = DYNX(W_,921)*DYNX(DYNhelp,1295)+DYNX(DYNhelp,830);
  DYNX(W_,948) = DYNX(W_,974)*DYNX(DYNhelp,1296)+DYNX(DYNhelp,831);
  DYNX(W_,914) = DYNX(W_,921)*DYNX(DYNhelp,1298)+DYNX(W_,917);
  DYNX(W_,1853) = DYNX(W_,1855)*DYNX(F_,16);
  DYNX(W_,1864) = DYNX(W_,820)-DYNX(DYNhelp,817)+DYNX(W_,934)+DYNX(W_,1902)+
    DYNX(DYNhelp,818)+DYNX(W_,1853);
  DYNX(W_,800) = DYNX(W_,807)*DYNX(DYNhelp,1299)+DYNX(W_,803);
  DYNX(W_,778) = DYNX(W_,807)*DYNX(DYNhelp,1300)+DYNX(DYNhelp,835);
  DYNX(W_,834) = DYNX(W_,860)*DYNX(DYNhelp,1301)+DYNX(DYNhelp,836);
  DYNX(W_,853) = DYNX(W_,860)*DYNX(DYNhelp,1302)+DYNX(W_,856);
  DYNX(W_,863) = DYNX(W_,870)*DYNX(DYNhelp,1303)+DYNX(W_,866);
  DYNX(W_,835) = DYNX(W_,870)*DYNX(DYNhelp,1297)+DYNX(DYNhelp,832);
  DYNX(W_,949) = DYNX(W_,984)*DYNX(DYNhelp,1305)+DYNX(DYNhelp,838);
  DYNX(W_,924) = DYNX(W_,931)*DYNX(DYNhelp,1288)+DYNX(W_,927);
   /* End of Equation Block */ 


  MixedModeStartBoolean
  UpdateVariableNamed(DYNX(W_,930),"inverter1.transistor_n.idealGTOThyristor[2].off",
     Less(DYNX(W_,931),"inverter1.transistor_n.idealGTOThyristor[2].s", 0,"0", 66)
     OR  NOT DYNX(W_,912));
  UpdateVariableNamed(DYNX(W_,869),"inverter1.diode_p.idealDiode[2].off", Less(
    DYNX(W_,870),"inverter1.diode_p.idealDiode[2].s", 0,"0", 67));
  UpdateVariableNamed(DYNX(W_,859),"inverter1.diode_p.idealDiode[1].off", Less(
    DYNX(W_,860),"inverter1.diode_p.idealDiode[1].s", 0,"0", 68));
  UpdateVariableNamed(DYNX(W_,806),"inverter1.transistor_p.idealGTOThyristor[1].off",
     Less(DYNX(W_,807),"inverter1.transistor_p.idealGTOThyristor[1].s", 0,"0", 69)
     OR  NOT DYNX(W_,797));
  UpdateVariableNamed(DYNX(W_,973),"inverter1.diode_n.idealDiode[1].off", Less(
    DYNX(W_,974),"inverter1.diode_n.idealDiode[1].s", 0,"0", 70));
  UpdateVariableNamed(DYNX(W_,940),"inverter1.transistor_n.idealGTOThyristor[3].off",
     Less(DYNX(W_,941),"inverter1.transistor_n.idealGTOThyristor[3].s", 0,"0", 71)
     OR  NOT DYNX(W_,913));
  UpdateVariableNamed(DYNX(W_,993),"inverter1.diode_n.idealDiode[3].off", Less(
    DYNX(W_,994),"inverter1.diode_n.idealDiode[3].s", 0,"0", 72));
  UpdateVariableNamed(DYNX(W_,826),"inverter1.transistor_p.idealGTOThyristor[3].off",
     Less(DYNX(W_,827),"inverter1.transistor_p.idealGTOThyristor[3].s", 0,"0", 73)
     OR  NOT DYNX(W_,799));
  UpdateVariableNamed(DYNX(W_,879),"inverter1.diode_p.idealDiode[3].off", Less(
    DYNX(W_,880),"inverter1.diode_p.idealDiode[3].s", 0,"0", 74));
  UpdateVariableNamed(DYNX(W_,816),"inverter1.transistor_p.idealGTOThyristor[2].off",
     Less(DYNX(W_,817),"inverter1.transistor_p.idealGTOThyristor[2].s", 0,"0", 75)
     OR  NOT DYNX(W_,798));
  UpdateVariableNamed(DYNX(W_,920),"inverter1.transistor_n.idealGTOThyristor[1].off",
     Less(DYNX(W_,921),"inverter1.transistor_n.idealGTOThyristor[1].s", 0,"0", 76)
     OR  NOT DYNX(W_,911));
  UpdateVariableNamed(DYNX(W_,983),"inverter1.diode_n.idealDiode[2].off", Less(
    DYNX(W_,984),"inverter1.diode_n.idealDiode[2].s", 0,"0", 77));
  MixedModeInit(12, DYNX(DYNhelp,1306))
  ThetaMixedCross(0,66)
  ThetaMixedCross(1,67)
  ThetaMixedCross(2,68)
  ThetaMixedCross(3,69)
  ThetaMixedCross(4,70)
  ThetaMixedCross(5,71)
  ThetaMixedCross(6,72)
  ThetaMixedCross(7,73)
  ThetaMixedCross(8,74)
  ThetaMixedCross(9,75)
  ThetaMixedCross(10,76)
  ThetaMixedCross(11,77)
  MixedModeEndBoolean
  UpdateReal(DYNX(W_,924), 1)
  UpdateReal(DYNX(W_,931), 2)
  UpdateReal(DYNX(W_,893), 3)
  UpdateReal(DYNX(W_,934), 4)
  UpdateReal(DYNX(W_,941), 5)
  UpdateReal(DYNX(W_,894), 6)
  UpdateReal(DYNX(W_,873), 7)
  UpdateReal(DYNX(W_,880), 8)
  UpdateReal(DYNX(W_,836), 9)
  UpdateReal(DYNX(W_,780), 10)
  UpdateReal(DYNX(W_,827), 11)
  UpdateReal(DYNX(W_,820), 12)
  UpdateReal(DYNX(W_,994), 13)
  UpdateReal(DYNX(W_,950), 14)
  UpdateReal(DYNX(W_,1001), 15)
  UpdateReal(DYNX(F_,16), 16)
  UpdateReal(DYNX(W_,1864), 17)
  UpdateReal(DYNX(W_,810), 18)
  UpdateReal(DYNX(W_,817), 19)
  UpdateReal(DYNX(W_,779), 20)
  UpdateReal(DYNX(W_,914), 21)
  UpdateReal(DYNX(W_,921), 22)
  UpdateReal(DYNX(W_,892), 23)
  UpdateReal(DYNX(W_,948), 24)
  UpdateReal(DYNX(W_,974), 25)
  UpdateReal(DYNX(W_,800), 26)
  UpdateReal(DYNX(W_,807), 27)
  UpdateReal(DYNX(W_,778), 28)
  UpdateReal(DYNX(W_,834), 29)
  UpdateReal(DYNX(W_,860), 30)
  UpdateReal(DYNX(W_,853), 31)
  UpdateReal(DYNX(W_,1853), 32)
  UpdateReal(DYNX(W_,863), 33)
  UpdateReal(DYNX(W_,870), 34)
  UpdateReal(DYNX(W_,835), 35)
  UpdateReal(DYNX(W_,949), 36)
  UpdateReal(DYNX(W_,984), 37)
EndMixedSystemOfEquations

DYNX(W_,967) =  -DYNX(W_,914);
DYNX(W_,977) =  -DYNX(W_,924);
DYNX(W_,987) =  -DYNX(W_,934);
DYNX(W_,764) =  -(DYNX(W_,987)+DYNX(W_,1913)+DYNX(W_,1869)-DYNX(W_,1867)+
  DYNX(W_,1864));
BreakSectionFunctionEnd()
BreakSectionFunctionStart(13);
DYNX(W_,887) = DYNX(W_,765)-DYNX(W_,1001);
DYNX(W_,1854) = DYNX(W_,1856)-DYNX(W_,1853);
DYNX(W_,1863) =  -(DYNX(W_,1858)-DYNX(W_,1856)+DYNX(W_,1853));
DYNX(W_,755) =  -(DYNX(W_,1902)+DYNX(W_,1858)-DYNX(W_,1856)+DYNX(W_,1853));
DYNX(W_,762) =  -(DYNX(W_,977)+DYNX(W_,1913)+DYNX(W_,1869)-DYNX(W_,1867)+
  DYNX(W_,1864));
DYNX(W_,886) = DYNX(W_,835)-DYNX(W_,779);
DYNX(W_,885) =  -(DYNX(W_,835)-DYNX(W_,779)+DYNX(W_,765)-DYNX(W_,1001)+
  DYNX(X_,16));
DYNX(W_,760) =  -(DYNX(W_,967)+DYNX(W_,1913)+DYNX(W_,1869)-DYNX(W_,1867)+
  DYNX(W_,1864));
DYNX(W_,999) = DYNX(X_,16)-(DYNX(W_,763)+DYNX(W_,779)-DYNX(W_,835)+DYNX(W_,1001));
DYNX(W_,1000) = DYNX(W_,763)+DYNX(W_,779)-DYNX(W_,835);
DYNX(W_,756) =  -(DYNX(W_,1913)+DYNX(W_,1869)-DYNX(W_,1867)+DYNX(W_,1864));
DYNX(W_,1874) =  -(DYNX(W_,1869)-DYNX(W_,1867)+DYNX(W_,1864));
DYNX(W_,1865) = DYNX(W_,1867)-DYNX(W_,1864);
DYNX(W_,1325) = DYNX(W_,1323)*DYNX(X_,13);
DYNX(W_,1339) =  -DYNX(W_,1325)*DYNX(W_,1334);
DYNX(W_,1140) = DYNX(W_,1334)*DYNX(X_,9)+DYNX(W_,1335)*DYNX(X_,10);
DYNX(W_,1342) = DYNX(W_,1198)+DYNX(W_,1140);
DYNX(W_,1326) = DYNX(W_,1346)*DYNX(W_,1342);
DYNX(W_,1173) =  -DYNX(W_,1177)*DYNX(W_,761);
DYNX(W_,1153) = DYNX(W_,760)-DYNX(W_,1173);
DYNX(W_,1181) =  -DYNX(W_,1185)*DYNX(W_,763);
DYNX(W_,1154) = DYNX(W_,762)-DYNX(W_,1181);
DYNX(W_,1189) =  -DYNX(W_,1193)*DYNX(W_,765);
DYNX(W_,1155) = DYNX(W_,764)-DYNX(W_,1189);
DYNX(W_,1232) = (-0.3333333333333333)*(DYNX(W_,1155)-2*DYNX(W_,1154)+
  DYNX(W_,1153));
DYNX(W_,1146) = DYNX(W_,1154)-DYNX(W_,1232);
DYNX(W_,1231) = DYNX(W_,1153)-DYNX(W_,1146);
DYNX(W_,1233) = DYNX(W_,1155)-DYNX(W_,1146);
DYNX(W_,1202) = 0.6666666666666666*DYNX(W_,1231)-0.33333333333333315*
  DYNX(W_,1232)-0.3333333333333336*DYNX(W_,1233);
DYNX(W_,1338) =  -DYNX(W_,1325)*DYNX(DYNhelp,763);
DYNX(W_,1340) = DYNX(W_,1325)*DYNX(W_,1334);
DYNX(W_,1141) = DYNX(W_,1336)*DYNX(X_,9)+DYNX(W_,1337)*DYNX(X_,10);
DYNX(W_,1343) = DYNX(W_,1199)+DYNX(W_,1141);
DYNX(W_,1327) = DYNX(W_,1349)*DYNX(W_,1343);
DYNX(W_,1203) = 0.5773502691896257*DYNX(W_,1232)-0.5773502691896255*
  DYNX(W_,1233);
DYNX(W_,1341) =  -DYNX(W_,1325)*DYNX(DYNhelp,763);

 /* Linear system of equations to solve. */
/* Tag: simulation.linear[8] */
/* Introducing 14 common subexpressions used in 24 expressions */
/* Of the common subexpressions 14 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,1318) = DYNX(W_,1338)*DYNX(X_,9);
DYNX(DYNhelp,1319) = DYNX(W_,1339)*DYNX(X_,10);
DYNX(DYNhelp,1320) = DYNX(DYNhelp,1318)+DYNX(DYNhelp,1319);
DYNX(DYNhelp,1321) = DYNX(W_,1340)*DYNX(X_,9);
DYNX(DYNhelp,1322) = DYNX(W_,1341)*DYNX(X_,10);
DYNX(DYNhelp,1323) = DYNX(DYNhelp,1321)+DYNX(DYNhelp,1322);
DYNX(DYNhelp,1324) = DYNX(W_,1349)*DYNX(W_,1336);
DYNX(DYNhelp,1325) = DYNX(W_,1346)*DYNX(W_,1334);
DYNX(DYNhelp,1326) = DYNX(W_,1338)*DYNX(W_,1326);
DYNX(DYNhelp,1327) = DYNX(W_,1340)*DYNX(W_,1327);
DYNX(DYNhelp,1328) = DYNX(W_,1349)*DYNX(W_,1337);
DYNX(DYNhelp,1329) = DYNX(W_,1346)*DYNX(W_,1335);
DYNX(DYNhelp,1330) = DYNX(W_,1339)*DYNX(W_,1326);
DYNX(DYNhelp,1331) = DYNX(W_,1341)*DYNX(W_,1327);
/* Automatic tearing of linear system of 14 simultaneous equations
gave a linear system of 4 equations for numerical solution.*/
{
  const char*const varnames_[]={"threePhaseMotor1.aimc.lssigma.der(i_[2])", 
    "threePhaseMotor1.aimc.der(idq_rr[1])", "threePhaseMotor1.aimc.lssigma.der(i_[1])",
     "threePhaseMotor1.aimc.der(idq_rr[2])"};
  const double nominal_[]={1, 1, 1, 1};
  DidLinearSystemOfEquations(J, b, y, 4, DYNX(DYNhelp,1332), 64, 
    DYNX(did_->helpvari_vec,82), 12);
  /* Jacobian depending on continuous variables */
  SetNeedFactor(J);
  if (NeedFactor(J)) {
    MatrixZeros(J);
    SetMatrixLeading(J, 1, 2, 4, (-1.0)*DYNX(DYNhelp,1325));
    SetMatrixLeading(J, 1, 3, 4, (-1.0)*DYNX(W_,1346)-DYNX(W_,1194));
    SetMatrixLeading(J, 1, 4, 4, (-1.0)*DYNX(DYNhelp,1329));
    SetMatrixLeading(J, 2, 1, 4, (-1.0)*DYNX(W_,1349)-DYNX(W_,1195));
    SetMatrixLeading(J, 2, 2, 4, (-1.0)*DYNX(DYNhelp,1324));
    SetMatrixLeading(J, 2, 4, 4, (-1.0)*DYNX(DYNhelp,1328));
    SetMatrixLeading(J, 3, 1, 4, DYNX(DYNhelp,1324));
    SetMatrixLeading(J, 3, 2, 4, DYNX(W_,1355)+DYNX(W_,1349)+(DYNX(W_,1346)-
      DYNX(W_,1349))*sqr(DYNX(W_,1334)));
    SetMatrixLeading(J, 3, 3, 4, DYNX(DYNhelp,1325));
    SetMatrixLeading(J, 3, 4, 4, DYNX(DYNhelp,1324)*DYNX(W_,1337)+
      DYNX(DYNhelp,1325)*DYNX(W_,1335));
    SetMatrixLeading(J, 4, 1, 4, DYNX(DYNhelp,1328));
    SetMatrixLeading(J, 4, 2, 4, DYNX(DYNhelp,1328)*DYNX(W_,1336)+
      DYNX(DYNhelp,1329)*DYNX(W_,1334));
    SetMatrixLeading(J, 4, 3, 4, DYNX(DYNhelp,1329));
    SetMatrixLeading(J, 4, 4, 4, DYNX(W_,1355)+DYNX(W_,1346)+(DYNX(W_,1349)-
      DYNX(W_,1346))*sqr(DYNX(W_,1337)));
  }
  SetVector(b, 1, DYNX(W_,1346)*DYNX(DYNhelp,1320)-DYNX(W_,1202));
  SetVector(b, 2, DYNX(W_,1349)*DYNX(DYNhelp,1323)-DYNX(W_,1203));
  SetVector(b, 3,  -(DYNX(W_,1361)*DYNX(X_,9)+DYNX(DYNhelp,1324)*
    DYNX(DYNhelp,1323)+DYNX(DYNhelp,1325)*DYNX(DYNhelp,1320)+DYNX(DYNhelp,1326)+
    DYNX(DYNhelp,1327)));
  SetVector(b, 4,  -(DYNX(W_,1361)*DYNX(X_,10)+DYNX(DYNhelp,1328)*
    DYNX(DYNhelp,1323)+DYNX(DYNhelp,1329)*DYNX(DYNhelp,1320)+DYNX(DYNhelp,1330)+
    DYNX(DYNhelp,1331)));
  SetVector(y, 1, RememberSimple_(DYNX(W_,1201), 44));
  SetVector(y, 2, RememberSimple_(DYNX(F_,9), 45));
  SetVector(y, 3, RememberSimple_(DYNX(W_,1200), 46));
  SetVector(y, 4, RememberSimple_(DYNX(F_,10), 47));
  SolveLinearSystemOfEquations(J, b, y, 7);
  DYNX(W_,1201) = GetVector(y, 1);
  DYNX(F_,9) = GetVector(y, 2);
  DYNX(W_,1200) = GetVector(y, 3);
  DYNX(F_,10) = GetVector(y, 4);
  EndStaticLinearSystemOfEquations(J);
}
DYNX(W_,1143) = DYNX(DYNhelp,1321)+DYNX(W_,1336)*DYNX(F_,9)+DYNX(DYNhelp,1322)+
  DYNX(W_,1337)*DYNX(F_,10);
DYNX(W_,1345) = DYNX(W_,1201)+DYNX(W_,1143);
DYNX(W_,1329) = DYNX(W_,1349)*DYNX(W_,1345);
DYNX(W_,1197) = DYNX(W_,1203)-DYNX(W_,1329);
DYNX(W_,1142) = DYNX(DYNhelp,1318)+DYNX(W_,1334)*DYNX(F_,9)+DYNX(DYNhelp,1319)+
  DYNX(W_,1335)*DYNX(F_,10);
DYNX(W_,1344) = DYNX(W_,1200)+DYNX(W_,1142);
DYNX(W_,1328) = DYNX(W_,1346)*DYNX(W_,1344);
DYNX(W_,1332) = DYNX(DYNhelp,1326)+DYNX(W_,1334)*DYNX(W_,1328)+DYNX(DYNhelp,1327)
  +DYNX(W_,1336)*DYNX(W_,1329);
DYNX(W_,1196) = DYNX(W_,1202)-DYNX(W_,1328);
DYNX(W_,1333) = DYNX(DYNhelp,1330)+DYNX(W_,1335)*DYNX(W_,1328)+DYNX(DYNhelp,1331)
  +DYNX(W_,1337)*DYNX(W_,1329);
 /* End of Equation Block */ 

DYNX(W_,1085) = 1.5*DYNX(W_,1323)*(DYNX(W_,1199)*DYNX(W_,1326)-DYNX(W_,1198)*
  DYNX(W_,1327));

 /* Linear system of equations to solve. */
/* Tag: simulation.linear[9] */
DYNX(F_,13) = RememberSimple_(DYNX(F_,13), 48);
SolveScalarLinearParametric(DYNX(W_,1460)+DYNX(W_,1086),"fan1.inertia.J+threePhaseMotor1.aimc.inertiaRotor.J",
   DYNX(W_,1085),"threePhaseMotor1.aimc.tauElectrical", DYNX(F_,13),
  "der(fan1.inertia.w)");
DYNX(W_,1370) = DYNX(W_,1086)*DYNX(F_,13)-DYNX(W_,1085);
 /* End of Equation Block */ 


 /* Linear system of equations to solve. */
/* Tag: simulation.linear[10] */
{
  const char*const varnames_[]={"threePhaseMotor1.aimc.der(idq_sr[2])", 
    "threePhaseMotor1.aimc.der(idq_sr[1])"};
  const double nominal_[]={1, 1};
  DidLinearSystemOfEquations(J, b, y, 2, DYNX(DYNhelp,1396), 24, 
    DYNX(did_->helpvari_vec,94), 8);
  /* Jacobian depending on continuous variables */
  SetNeedFactor(J);
  if (NeedFactor(J)) {
    MatrixZeros(J);
    SetMatrixLeading(J, 1, 1, 2,  -DYNX(W_,1335));
    SetMatrixLeading(J, 1, 2, 2,  -DYNX(W_,1334));
    SetMatrixLeading(J, 2, 1, 2,  -DYNX(W_,1337));
    SetMatrixLeading(J, 2, 2, 2,  -DYNX(W_,1336));
  }
  SetVector(b, 1, DYNX(W_,1338)*DYNX(X_,7)+DYNX(W_,1339)*DYNX(X_,8)-
    DYNX(W_,1200));
  SetVector(b, 2, DYNX(W_,1340)*DYNX(X_,7)+DYNX(W_,1341)*DYNX(X_,8)-
    DYNX(W_,1201));
  SetVector(y, 1, RememberSimple_(DYNX(F_,8), 49));
  SetVector(y, 2, RememberSimple_(DYNX(F_,7), 50));
  SolveLinearSystemOfEquations(J, b, y, 8);
  DYNX(F_,8) = GetVector(y, 1);
  DYNX(F_,7) = GetVector(y, 2);
  EndStaticLinearSystemOfEquations(J);
}
 /* End of Equation Block */ 

DYNX(W_,1455) = DYNX(X_,13)-DYNX(W_,1458);
if (NewParameters_) {
DYNX(DYNhelp,1420) = divinvGuarded(DYNX(W_,1453),"variableSpeedDrive_ThreePhase1.currentController.T");
}
DYNX(F_,12) = DYNX(DYNhelp,1420)*DYNX(W_,1455);
DYNX(W_,1506) = DYNX(DP_,201)*(1+DYNX(DP_,203)*(DYNX(X_,15)-DYNX(DP_,202)));
 /* Linear system of equations to solve. */
DYNX(F_,15) = RememberSimple_(DYNX(F_,15), 51);
SolveScalarLinearParametric(DYNX(W_,1828),"batteryPack.thermal.internalMass.C", 
  DYNX(W_,1506),"batteryPack.summary.pack_heat_flow", DYNX(F_,15),
  "der(batteryPack.thermal.internalMass.T)");
 /* End of Equation Block */ 

DYNX(F_,14) = 0.0;
DYNX(W_,2528) = DYNX(W_,2526)*DYNX(X_,23);
DYNX(W_,2527) = DYNX(W_,2526)*(DYNX(X_,21)-DYNX(DP_,317));
DYNX(DYNhelp,1421) = cos(DYNX(W_,2527));
DYNX(W_,2542) =  -DYNX(W_,2528)*DYNX(DYNhelp,1421);
DYNX(W_,2537) = DYNX(DYNhelp,1421);
DYNX(DYNhelp,1422) = sin(DYNX(W_,2527));
DYNX(W_,2538) =  -DYNX(DYNhelp,1422);
DYNX(W_,2401) = DYNX(W_,2537)*DYNX(X_,17)+DYNX(W_,2538)*DYNX(X_,18);
DYNX(W_,2343) = DYNX(W_,2537)*DYNX(X_,19)+DYNX(W_,2538)*DYNX(X_,20);
DYNX(W_,2545) = DYNX(W_,2401)+DYNX(W_,2343);
DYNX(W_,2529) = DYNX(W_,2549)*DYNX(W_,2545);
DYNX(W_,2539) = DYNX(DYNhelp,1422);
DYNX(W_,2540) = DYNX(DYNhelp,1421);
DYNX(W_,2402) = DYNX(W_,2539)*DYNX(X_,17)+DYNX(W_,2540)*DYNX(X_,18);

 /* Linear system of equations to solve. */
/* Tag: simulation.linear[11] */
/* Automatic tearing of linear system of 3 simultaneous equations
gave a linear system of 2 equations for numerical solution.*/
{
  const char*const varnames_[]={"inverter3.ac.pin[3].i", "inverter3.ac.pin[1].i"};
  const double nominal_[]={1, 1};
  static double J__internal[4]={-1.154700538379252, -1.3322676295501878E-15, 
    1.154700538379252, 3.000000000000001};
  static SizeType J__dims[2]={2,2};
  static RealArray J={2,J__dims,J__internal};
  static int J__m=2;
  static int factoredForParametersV_=0;
  int*factoredForParametersP_=&factoredForParametersV_;
  static double J__DWork[16]={-1.154700538379252, 1.153777611830138E-15, 
    1.154700538379252, 2.9999999999999996, -1.5326920704511053, -0.6666666666666672,
     -0.8660254037844387, -3.845925372767127E-16, 1.153777611830138E-15, 0.0, 
    0.0, 1.154700538379252, 0.8660254037844384, 0.33333333333333326, 1.0, 1.0};
  static int J__IWork[5]={1, 2, 0, -1, -1};
  static int J__FactoredV=1;
  int* J__FactoredP=&(J__FactoredV);
  DeclareDidRealVector1(b, 2, DYNX(DYNhelp,1423));
  DeclareDidRealVector1(y, 2, DYNX(DYNhelp,1425));
  DeclareDidRealVector2(b, 2, DYNX(DYNhelp,1423));
  DeclareDidRealVector2(y, 2, DYNX(DYNhelp,1425));
  RealFillAssign(b,0.0);
  SetVector(b, 1,  -(DYNX(W_,2402)+1.7320508075688783*DYNX(W_,2401)));
  SetVector(b, 2, (-3.0000000000000018)*DYNX(W_,2401));
  SetVector(y, 1, RememberSimple_(DYNX(W_,1971), 52));
  SetVector(y, 2, RememberSimple_(DYNX(W_,1967), 53));
  SolveLinearSystemOfEquations(J, b, y, 9);
  DYNX(W_,1971) = GetVector(y, 1);
  DYNX(W_,1967) = GetVector(y, 2);
  EndStaticLinearSystemOfEquations(J);
}
DYNX(W_,1969) = 3.0000000000000018*(DYNX(W_,2401)-0.3333333333333336*
  DYNX(W_,1971)+0.6666666666666666*DYNX(W_,1967));
 /* End of Equation Block */ 

DYNX(W_,2376) =  -DYNX(W_,2380)*DYNX(W_,1967);
beginwhenBlock
if (NewParameters_) {
DYNX(DYNhelp,1427) = divinvGuarded(DYNX(W_,2610),"signalPWM5[1].sawtooth.period");
}
DYNX(DYNhelp,1428) = real2integer(DYNX(DYNhelp,1427)*(DYNTime-DYNX(W_,2613)));
whenModelica(real2integerEventMinor(divGuarded(DYNTime-DYNX(W_,2613),
  "time-signalPWM5[1].sawtooth.startTime",DYNX(W_,2610),"signalPWM5[1].sawtooth.period"),
  "(time-signalPWM5[1].sawtooth.startTime)/signalPWM5[1].sawtooth.period", 8) > 
  PRE(DYNX(W_,2615), 42), 8) 
  DYNX(W_,2614) = DYNTime;
endwhenModelica()
endwhenBlock


DYNX(W_,2602) = IF LessTime(DYNX(W_,2613), 14) THEN 0 ELSE divGuarded(DYNTime-
  DYNX(W_,2614),"time-signalPWM5[1].sawtooth.T_start",DYNX(W_,2610),
  "signalPWM5[1].sawtooth.period");
DYNX(W_,2603) = PRE(DYNX(W_,2608), 43);
DYNX(W_,1956) = Less(DYNX(W_,2602),"signalPWM5[1].greaterEqual.u1", 
  DYNX(W_,2603),"signalPWM5[1].greaterEqual.u2", 78);
DYNX(W_,2117) = DYNX(W_,1956) AND DYNX(W_,1954);
DYNX(W_,1948) =  NOT DYNX(W_,1956);
DYNX(W_,2003) = DYNX(W_,1948) AND DYNX(W_,1954);
beginwhenBlock
if (NewParameters_) {
DYNX(DYNhelp,1429) = divinvGuarded(DYNX(W_,2648),"signalPWM5[3].sawtooth.period");
}
DYNX(DYNhelp,1430) = real2integer(DYNX(DYNhelp,1429)*(DYNTime-DYNX(W_,2651)));
whenModelica(real2integerEventMinor(divGuarded(DYNTime-DYNX(W_,2651),
  "time-signalPWM5[3].sawtooth.startTime",DYNX(W_,2648),"signalPWM5[3].sawtooth.period"),
  "(time-signalPWM5[3].sawtooth.startTime)/signalPWM5[3].sawtooth.period", 9) > 
  PRE(DYNX(W_,2653), 44), 9) 
  DYNX(W_,2652) = DYNTime;
endwhenModelica()
endwhenBlock


DYNX(W_,2640) = IF LessTime(DYNX(W_,2651), 15) THEN 0 ELSE divGuarded(DYNTime-
  DYNX(W_,2652),"time-signalPWM5[3].sawtooth.T_start",DYNX(W_,2648),
  "signalPWM5[3].sawtooth.period");
DYNX(W_,2641) = PRE(DYNX(W_,2646), 45);
DYNX(W_,1958) = Less(DYNX(W_,2640),"signalPWM5[3].greaterEqual.u1", 
  DYNX(W_,2641),"signalPWM5[3].greaterEqual.u2", 79);
DYNX(W_,2119) = DYNX(W_,1958) AND DYNX(W_,1954);
DYNX(W_,1950) =  NOT DYNX(W_,1958);
DYNX(W_,2005) = DYNX(W_,1950) AND DYNX(W_,1954);
beginwhenBlock
if (NewParameters_) {
DYNX(DYNhelp,1431) = divinvGuarded(DYNX(W_,2629),"signalPWM5[2].sawtooth.period");
}
DYNX(DYNhelp,1432) = real2integer(DYNX(DYNhelp,1431)*(DYNTime-DYNX(W_,2632)));
whenModelica(real2integerEventMinor(divGuarded(DYNTime-DYNX(W_,2632),
  "time-signalPWM5[2].sawtooth.startTime",DYNX(W_,2629),"signalPWM5[2].sawtooth.period"),
  "(time-signalPWM5[2].sawtooth.startTime)/signalPWM5[2].sawtooth.period", 10)
   > PRE(DYNX(W_,2634), 46), 10) 
  DYNX(W_,2633) = DYNTime;
endwhenModelica()
endwhenBlock


DYNX(W_,2621) = IF LessTime(DYNX(W_,2632), 16) THEN 0 ELSE divGuarded(DYNTime-
  DYNX(W_,2633),"time-signalPWM5[2].sawtooth.T_start",DYNX(W_,2629),
  "signalPWM5[2].sawtooth.period");
DYNX(W_,2622) = PRE(DYNX(W_,2627), 47);
DYNX(W_,1957) = Less(DYNX(W_,2621),"signalPWM5[2].greaterEqual.u1", 
  DYNX(W_,2622),"signalPWM5[2].greaterEqual.u2", 80);
DYNX(W_,1949) =  NOT DYNX(W_,1957);
DYNX(W_,2004) = DYNX(W_,1949) AND DYNX(W_,1954);
DYNX(W_,2118) = DYNX(W_,1957) AND DYNX(W_,1954);

MixedSystemOfEquations(39, DYNX(DYNhelp,1433))

  { /* Non-linear system of equations to solve. */
  /* Tag: simulation.nonlinear[1] */
  /* Introducing 66 common subexpressions used in 54 expressions */
  /* Of the common subexpressions 66 are reals, 0 are integers, and 0
     are booleans. */
  const char*const varnames_[]={"inverter3.transistor_n.idealGTOThyristor[1].s",
     "inverter3.transistor_p.idealGTOThyristor[3].s", "inverter3.transistor_n.idealGTOThyristor[3].s",
     "inverter3.diode_p.idealDiode[3].s", "inverter3.diode_n.idealDiode[3].s", 
    "inverter3.diode_n.idealDiode[1].s", "inverter3.transistor_p.idealGTOThyristor[2].s",
     "inverter3.transistor_n.idealGTOThyristor[2].s", "inverter3.diode_n.idealDiode[2].s",
     "inverter3.diode_p.idealDiode[2].s", "inverter3.transistor_p.idealGTOThyristor[1].s",
     "inverter3.diode_p.idealDiode[1].s"};
  const double nominal_[]={1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
  NonLinearSystemOfEquations(Jacobian__, residue__, x__, 12, 0, 0, 1, 23, 
    DYNX(DYNhelp,1472), 398, DYNX(did_->helpvari_vec,102), 34);
  SetInitVector(x__, 1, DYNX(W_,2127), Remember_(DYNX(W_,2127), 54));
  SetInitVector(x__, 2, DYNX(W_,2033), Remember_(DYNX(W_,2033), 55));
  SetInitVector(x__, 3, DYNX(W_,2147), Remember_(DYNX(W_,2147), 56));
  SetInitVector(x__, 4, DYNX(W_,2086), Remember_(DYNX(W_,2086), 57));
  SetInitVector(x__, 5, DYNX(W_,2200), Remember_(DYNX(W_,2200), 58));
  SetInitVector(x__, 6, DYNX(W_,2180), Remember_(DYNX(W_,2180), 59));
  SetInitVector(x__, 7, DYNX(W_,2023), Remember_(DYNX(W_,2023), 60));
  SetInitVector(x__, 8, DYNX(W_,2137), Remember_(DYNX(W_,2137), 61));
  SetInitVector(x__, 9, DYNX(W_,2190), Remember_(DYNX(W_,2190), 62));
  SetInitVector(x__, 10, DYNX(W_,2076), Remember_(DYNX(W_,2076), 63));
  SetInitVector(x__, 11, DYNX(W_,2013), Remember_(DYNX(W_,2013), 64));
  SetInitVector(x__, 12, DYNX(W_,2066), Remember_(DYNX(W_,2066), 65));
  Residues;
    DYNX(DYNhelp,1870) = IF DYNX(W_,2179) THEN DYNX(W_,2175) ELSE 1;
    DYNX(W_,2154) = DYNX(W_,2180)*DYNX(DYNhelp,1870)+DYNX(W_,2175)*DYNX(W_,2176);
    DYNX(DYNhelp,1871) = IF DYNX(W_,2126) THEN DYNX(W_,2122) ELSE 1;
    DYNX(W_,2098) = DYNX(W_,2127)*DYNX(DYNhelp,1871)+DYNX(W_,2122)*DYNX(W_,2123);
    DYNX(DYNhelp,1872) = IF DYNX(W_,2032) THEN DYNX(W_,2028) ELSE 1;
    DYNX(W_,1986) = DYNX(W_,2033)*DYNX(DYNhelp,1872)+DYNX(W_,2028)*DYNX(W_,2029);
    DYNX(DYNhelp,1873) = IF DYNX(W_,2022) THEN DYNX(W_,2018) ELSE 1;
    DYNX(W_,1985) = DYNX(W_,2023)*DYNX(DYNhelp,1873)+DYNX(W_,2018)*DYNX(W_,2019);
    DYNX(DYNhelp,1874) = IF DYNX(W_,2075) THEN DYNX(W_,2071) ELSE 1;
    DYNX(W_,2041) = DYNX(W_,2076)*DYNX(DYNhelp,1874)+DYNX(W_,2071)*DYNX(W_,2072);
    DYNX(DYNhelp,1875) = IF DYNX(W_,2085) THEN DYNX(W_,2081) ELSE 1;
    DYNX(W_,2042) = DYNX(W_,2086)*DYNX(DYNhelp,1875)+DYNX(W_,2081)*DYNX(W_,2082);
    DYNX(DYNhelp,1876) = DYNX(W_,2098)+DYNX(W_,1971)+DYNX(W_,1986);
    DYNX(W_,1962) = DYNX(W_,2154)-(DYNX(DYNhelp,1876)+DYNX(W_,1969)+
      DYNX(W_,1985))+DYNX(W_,2041)+DYNX(W_,2042);
    if (NewParameters_) {
    DYNX(DYNhelp,1877) = divinvGuarded(DYNX(DP_,371),"hTS_exploss1.I_c");
    }
    DYNX(DYNhelp,1878) =  -DYNX(DYNhelp,1877)*DYNX(W_,1962);
    DYNX(W_,2676) = DYNX(DP_,369)*powGuarded(DYNX(DYNhelp,1878)," -inverter3.dc_n.i/hTS_exploss1.I_c",
      DYNX(DP_,370),"hTS_exploss1.n");
    DYNX(W_,1961) = DYNX(W_,2676)*DYNX(DP_,368);
    DYNX(DYNhelp,1879) = IF DYNX(W_,2136) THEN 1 ELSE DYNX(W_,2131);
    DYNX(W_,2130) = DYNX(W_,2137)*DYNX(DYNhelp,1879)+DYNX(W_,2133);
    DYNX(W_,1968) = DYNX(W_,1961)+DYNX(W_,2130);
    DYNX(DYNhelp,1880) = IF DYNX(W_,2126) THEN 1 ELSE DYNX(W_,2121);
    DYNX(W_,2120) = DYNX(W_,2127)*DYNX(DYNhelp,1880)+DYNX(W_,2123);
    DYNX(DYNhelp,1881) = IF DYNX(W_,2146) THEN DYNX(W_,2142) ELSE 1;
    DYNX(W_,2100) = DYNX(W_,2147)*DYNX(DYNhelp,1881)+DYNX(W_,2142)*DYNX(W_,2143);
    DYNX(DYNhelp,1882) = IF DYNX(W_,2199) THEN DYNX(W_,2195) ELSE 1;
    DYNX(W_,2156) = DYNX(W_,2200)*DYNX(DYNhelp,1882)+DYNX(W_,2195)*DYNX(W_,2196);
    DYNX(DYNhelp,1883) = IF DYNX(W_,2146) THEN 1 ELSE DYNX(W_,2141);
    DYNX(W_,2140) = DYNX(W_,2147)*DYNX(DYNhelp,1883)+DYNX(W_,2143);
    DYNX(DYNhelp,1884) = IF DYNX(W_,2179) THEN 1 ELSE DYNX(W_,2174);
    DYNX(W_,2173) = DYNX(W_,2180)*DYNX(DYNhelp,1884)+DYNX(W_,2176);
    DYNX(DYNhelp,1885) = DYNX(W_,1967)+DYNX(W_,1971);
    DYNX(W_,1960) =  -(DYNX(DYNhelp,1885)+DYNX(W_,1962)+DYNX(W_,1969));
    if (NewParameters_) {
    DYNX(DYNhelp,1886) = divinvGuarded(DYNX(DP_,365),"hTS_exploss.I_c");
    }
    DYNX(DYNhelp,1887) =  -DYNX(DYNhelp,1886)*DYNX(W_,1960);
    DYNX(W_,2675) = DYNX(DP_,363)*powGuarded(DYNX(DYNhelp,1887)," -inverter3.dc_p.i/hTS_exploss.I_c",
      DYNX(DP_,364),"hTS_exploss.n");
    DYNX(W_,1959) = DYNX(W_,2675)*DYNX(DP_,362);
    DYNX(DYNhelp,1888) = IF DYNX(W_,2032) THEN 1 ELSE DYNX(W_,2027);
    DYNX(W_,2026) = DYNX(W_,2033)*DYNX(DYNhelp,1888)+DYNX(W_,2029);
    DYNX(DYNhelp,1889) = IF DYNX(W_,2022) THEN 1 ELSE DYNX(W_,2017);
    DYNX(W_,2016) = DYNX(W_,2023)*DYNX(DYNhelp,1889)+DYNX(W_,2019);
    DYNX(DYNhelp,1890) = IF DYNX(W_,2136) THEN DYNX(W_,2132) ELSE 1;
    DYNX(W_,2099) = DYNX(W_,2137)*DYNX(DYNhelp,1890)+DYNX(W_,2132)*DYNX(W_,2133);
    DYNX(DYNhelp,1891) = IF DYNX(W_,2189) THEN DYNX(W_,2185) ELSE 1;
    DYNX(W_,2155) = DYNX(W_,2190)*DYNX(DYNhelp,1891)+DYNX(W_,2185)*DYNX(W_,2186);
    DYNX(DYNhelp,1892) = IF DYNX(W_,2075) THEN 1 ELSE DYNX(W_,2070);
    DYNX(W_,2069) = DYNX(W_,2076)*DYNX(DYNhelp,1892)+DYNX(W_,2072);
    DYNX(DYNhelp,1893) = IF DYNX(W_,2012) THEN DYNX(W_,2008) ELSE 1;
    DYNX(W_,1984) = DYNX(W_,2013)*DYNX(DYNhelp,1893)+DYNX(W_,2008)*DYNX(W_,2009);
    DYNX(DYNhelp,1894) = IF DYNX(W_,2012) THEN 1 ELSE DYNX(W_,2007);
    DYNX(W_,2006) = DYNX(W_,2013)*DYNX(DYNhelp,1894)+DYNX(W_,2009);
    DYNX(DYNhelp,1895) = IF DYNX(W_,2065) THEN DYNX(W_,2061) ELSE 1;
    DYNX(W_,2040) = DYNX(W_,2066)*DYNX(DYNhelp,1895)+DYNX(W_,2061)*DYNX(W_,2062);
  DYNX(DYNhelp,1896) = IF DYNX(W_,2085) THEN 1 ELSE DYNX(W_,2080);
  DYNX(DYNhelp,1897) = IF DYNX(W_,2199) THEN 1 ELSE DYNX(W_,2194);
  DYNX(DYNhelp,1898) = IF DYNX(W_,2189) THEN 1 ELSE DYNX(W_,2184);
  DYNX(DYNhelp,1899) = DYNX(DYNhelp,1885)+DYNX(W_,1986)+DYNX(W_,1962)+
    DYNX(W_,1969);
  DYNX(DYNhelp,1900) = IF DYNX(W_,2065) THEN 1 ELSE DYNX(W_,2060);
  SetVector(residue__, 1, DYNX(W_,2120)-(DYNX(W_,2026)-DYNX(W_,2006)+
    DYNX(W_,2140)));
  SetVector(residue__, 2, DYNX(W_,2026)+DYNX(W_,2086)*DYNX(DYNhelp,1896)+
    DYNX(W_,2082));
  SetVector(residue__, 3, DYNX(W_,2156)+DYNX(W_,1971)-DYNX(W_,2042)-
    DYNX(W_,2100)+DYNX(W_,1986));
  SetVector(residue__, 4, DYNX(W_,2140)+DYNX(W_,2200)*DYNX(DYNhelp,1897)+
    DYNX(W_,2196));
  SetVector(residue__, 5, DYNX(W_,2173)-DYNX(W_,2006)+DYNX(W_,2140)+
    DYNX(W_,2026));
  SetVector(residue__, 6, DYNX(W_,1959)-(DYNX(W_,2026)+DYNX(W_,1968)-
    DYNX(W_,2130)+DYNX(W_,2140)));
  SetVector(residue__, 7, DYNX(W_,2016)-(DYNX(W_,2026)-DYNX(W_,2130)+
    DYNX(W_,2140)));
  SetVector(residue__, 8, DYNX(W_,2155)+DYNX(W_,1969)-DYNX(W_,2041)-
    DYNX(W_,2099)+DYNX(W_,1985));
  SetVector(residue__, 9, DYNX(W_,2130)+DYNX(W_,2190)*DYNX(DYNhelp,1898)+
    DYNX(W_,2186));
  SetVector(residue__, 10, DYNX(W_,2069)-DYNX(W_,2130)+DYNX(W_,2140)+
    DYNX(W_,2026));
  SetVector(residue__, 11, DYNX(W_,1984)-(DYNX(W_,2041)-(DYNX(DYNhelp,1899)+
    DYNX(W_,1985))+DYNX(W_,2040)+DYNX(W_,2042)));
  SetVector(residue__, 12, DYNX(W_,2006)+DYNX(W_,2066)*DYNX(DYNhelp,1900)+
    DYNX(W_,2062));

  Jacobian(Jacobian__)
  MatrixZeros(Jacobian__);
  DYNX(DYNhelp,1901) = (-1.0)*DYNX(DYNhelp,1888);
  DYNX(DYNhelp,1902) = (-1.0)*DYNX(DYNhelp,1883);
  DYNX(DYNhelp,1903) = DYNX(DP_,369)*powGuarded(DYNX(DYNhelp,1878),
    " -inverter3.dc_n.i/hTS_exploss1.I_c",DYNX(DP_,370)-1.0,"hTS_exploss1.n-1.0")
    *DYNX(DP_,370);
  DYNX(DYNhelp,1904) = DYNX(DP_,363)*powGuarded(DYNX(DYNhelp,1887),
    " -inverter3.dc_p.i/hTS_exploss.I_c",DYNX(DP_,364)-1.0,"hTS_exploss.n-1.0")*
    DYNX(DP_,364);
  DYNX(DYNhelp,1905) = DYNX(DYNhelp,1877)*(-1.0)*DYNX(DYNhelp,1903)*
    DYNX(DP_,368)+DYNX(DYNhelp,1886)*(-1.0)*DYNX(DYNhelp,1904)*DYNX(DP_,362);
  SetMatrixLeading(Jacobian__, 1, 1, 12, DYNX(DYNhelp,1880));
  SetMatrixLeading(Jacobian__, 1, 2, 12, DYNX(DYNhelp,1901));
  SetMatrixLeading(Jacobian__, 1, 3, 12, DYNX(DYNhelp,1902));
  SetMatrixLeading(Jacobian__, 1, 11, 12, DYNX(DYNhelp,1894));
  SetMatrixLeading(Jacobian__, 2, 2, 12, DYNX(DYNhelp,1888));
  SetMatrixLeading(Jacobian__, 2, 4, 12, DYNX(DYNhelp,1896));
  SetMatrixLeading(Jacobian__, 3, 2, 12, DYNX(DYNhelp,1872));
  SetMatrixLeading(Jacobian__, 3, 3, 12, (-1.0)*DYNX(DYNhelp,1881));
  SetMatrixLeading(Jacobian__, 3, 4, 12, (-1.0)*DYNX(DYNhelp,1875));
  SetMatrixLeading(Jacobian__, 3, 5, 12, DYNX(DYNhelp,1882));
  SetMatrixLeading(Jacobian__, 4, 3, 12, DYNX(DYNhelp,1883));
  SetMatrixLeading(Jacobian__, 4, 5, 12, DYNX(DYNhelp,1897));
  SetMatrixLeading(Jacobian__, 5, 2, 12, DYNX(DYNhelp,1888));
  SetMatrixLeading(Jacobian__, 5, 3, 12, DYNX(DYNhelp,1883));
  SetMatrixLeading(Jacobian__, 5, 6, 12, DYNX(DYNhelp,1884));
  SetMatrixLeading(Jacobian__, 5, 11, 12, (-1.0)*DYNX(DYNhelp,1894));
  SetMatrixLeading(Jacobian__, 6, 1, 12, DYNX(DYNhelp,1905)*DYNX(DYNhelp,1871));
  SetMatrixLeading(Jacobian__, 6, 2, 12, DYNX(DYNhelp,1905)*DYNX(DYNhelp,1872)-
    DYNX(DYNhelp,1888));
  SetMatrixLeading(Jacobian__, 6, 3, 12, DYNX(DYNhelp,1902));
  SetMatrixLeading(Jacobian__, 6, 4, 12,  -DYNX(DYNhelp,1905)*DYNX(DYNhelp,1875));
  SetMatrixLeading(Jacobian__, 6, 6, 12,  -DYNX(DYNhelp,1905)*DYNX(DYNhelp,1870));
  SetMatrixLeading(Jacobian__, 6, 7, 12, DYNX(DYNhelp,1905)*DYNX(DYNhelp,1873));
  SetMatrixLeading(Jacobian__, 6, 10, 12,  -DYNX(DYNhelp,1905)*DYNX(DYNhelp,1874));
  SetMatrixLeading(Jacobian__, 7, 2, 12, DYNX(DYNhelp,1901));
  SetMatrixLeading(Jacobian__, 7, 3, 12, DYNX(DYNhelp,1902));
  SetMatrixLeading(Jacobian__, 7, 7, 12, DYNX(DYNhelp,1889));
  SetMatrixLeading(Jacobian__, 7, 8, 12, DYNX(DYNhelp,1879));
  SetMatrixLeading(Jacobian__, 8, 7, 12, DYNX(DYNhelp,1873));
  SetMatrixLeading(Jacobian__, 8, 8, 12, (-1.0)*DYNX(DYNhelp,1890));
  SetMatrixLeading(Jacobian__, 8, 9, 12, DYNX(DYNhelp,1891));
  SetMatrixLeading(Jacobian__, 8, 10, 12, (-1.0)*DYNX(DYNhelp,1874));
  SetMatrixLeading(Jacobian__, 9, 8, 12, DYNX(DYNhelp,1879));
  SetMatrixLeading(Jacobian__, 9, 9, 12, DYNX(DYNhelp,1898));
  SetMatrixLeading(Jacobian__, 10, 2, 12, DYNX(DYNhelp,1888));
  SetMatrixLeading(Jacobian__, 10, 3, 12, DYNX(DYNhelp,1883));
  SetMatrixLeading(Jacobian__, 10, 8, 12, (-1.0)*DYNX(DYNhelp,1879));
  SetMatrixLeading(Jacobian__, 10, 10, 12, DYNX(DYNhelp,1892));
  SetMatrixLeading(Jacobian__, 11, 1, 12, (-1.0)*DYNX(DYNhelp,1871));
  SetMatrixLeading(Jacobian__, 11, 6, 12, DYNX(DYNhelp,1870));
  SetMatrixLeading(Jacobian__, 11, 11, 12, DYNX(DYNhelp,1893));
  SetMatrixLeading(Jacobian__, 11, 12, 12, (-1.0)*DYNX(DYNhelp,1895));
  SetMatrixLeading(Jacobian__, 12, 11, 12, DYNX(DYNhelp,1894));
  SetMatrixLeading(Jacobian__, 12, 12, 12, DYNX(DYNhelp,1900));

  SolveNonLinearSystemOfEquationsMixed(Jacobian__, 0, 0, 0, residue__, x__,"Tag: simulation.nonlinear[1]");
  DYNX(W_,2127) = GetVector(x__, 1);
  DYNX(W_,2033) = GetVector(x__, 2);
  DYNX(W_,2147) = GetVector(x__, 3);
  DYNX(W_,2086) = GetVector(x__, 4);
  DYNX(W_,2200) = GetVector(x__, 5);
  DYNX(W_,2180) = GetVector(x__, 6);
  DYNX(W_,2023) = GetVector(x__, 7);
  DYNX(W_,2137) = GetVector(x__, 8);
  DYNX(W_,2190) = GetVector(x__, 9);
  DYNX(W_,2076) = GetVector(x__, 10);
  DYNX(W_,2013) = GetVector(x__, 11);
  DYNX(W_,2066) = GetVector(x__, 12);
  EndNonLinearSystemOfEquations(residue__, x__);
   /* End of Non-Linear Equation Block */ }




  MixedModeStartBoolean
  UpdateVariableNamed(DYNX(W_,2012),"inverter3.transistor_p.idealGTOThyristor[1].off",
     Less(DYNX(W_,2013),"inverter3.transistor_p.idealGTOThyristor[1].s", 0,"0", 81)
     OR  NOT DYNX(W_,2003));
  UpdateVariableNamed(DYNX(W_,2075),"inverter3.diode_p.idealDiode[2].off", Less(
    DYNX(W_,2076),"inverter3.diode_p.idealDiode[2].s", 0,"0", 82));
  UpdateVariableNamed(DYNX(W_,2179),"inverter3.diode_n.idealDiode[1].off", Less(
    DYNX(W_,2180),"inverter3.diode_n.idealDiode[1].s", 0,"0", 83));
  UpdateVariableNamed(DYNX(W_,2189),"inverter3.diode_n.idealDiode[2].off", Less(
    DYNX(W_,2190),"inverter3.diode_n.idealDiode[2].s", 0,"0", 84));
  UpdateVariableNamed(DYNX(W_,2022),"inverter3.transistor_p.idealGTOThyristor[2].off",
     Less(DYNX(W_,2023),"inverter3.transistor_p.idealGTOThyristor[2].s", 0,"0", 85)
     OR  NOT DYNX(W_,2004));
  UpdateVariableNamed(DYNX(W_,2136),"inverter3.transistor_n.idealGTOThyristor[2].off",
     Less(DYNX(W_,2137),"inverter3.transistor_n.idealGTOThyristor[2].s", 0,"0", 86)
     OR  NOT DYNX(W_,2118));
  UpdateVariableNamed(DYNX(W_,2126),"inverter3.transistor_n.idealGTOThyristor[1].off",
     Less(DYNX(W_,2127),"inverter3.transistor_n.idealGTOThyristor[1].s", 0,"0", 87)
     OR  NOT DYNX(W_,2117));
  UpdateVariableNamed(DYNX(W_,2085),"inverter3.diode_p.idealDiode[3].off", Less(
    DYNX(W_,2086),"inverter3.diode_p.idealDiode[3].s", 0,"0", 88));
  UpdateVariableNamed(DYNX(W_,2032),"inverter3.transistor_p.idealGTOThyristor[3].off",
     Less(DYNX(W_,2033),"inverter3.transistor_p.idealGTOThyristor[3].s", 0,"0", 89)
     OR  NOT DYNX(W_,2005));
  UpdateVariableNamed(DYNX(W_,2146),"inverter3.transistor_n.idealGTOThyristor[3].off",
     Less(DYNX(W_,2147),"inverter3.transistor_n.idealGTOThyristor[3].s", 0,"0", 90)
     OR  NOT DYNX(W_,2119));
  UpdateVariableNamed(DYNX(W_,2199),"inverter3.diode_n.idealDiode[3].off", Less(
    DYNX(W_,2200),"inverter3.diode_n.idealDiode[3].s", 0,"0", 91));
  UpdateVariableNamed(DYNX(W_,2065),"inverter3.diode_p.idealDiode[1].off", Less(
    DYNX(W_,2066),"inverter3.diode_p.idealDiode[1].s", 0,"0", 92));
  MixedModeInit(12, DYNX(DYNhelp,1906))
  ThetaMixedCross(0,81)
  ThetaMixedCross(1,82)
  ThetaMixedCross(2,83)
  ThetaMixedCross(3,84)
  ThetaMixedCross(4,85)
  ThetaMixedCross(5,86)
  ThetaMixedCross(6,87)
  ThetaMixedCross(7,88)
  ThetaMixedCross(8,89)
  ThetaMixedCross(9,90)
  ThetaMixedCross(10,91)
  ThetaMixedCross(11,92)
  MixedModeEndBoolean
  UpdateReal(DYNX(W_,2040), 1)
  UpdateReal(DYNX(W_,2676), 2)
  UpdateReal(DYNX(W_,1961), 3)
  UpdateReal(DYNX(W_,1968), 4)
  UpdateReal(DYNX(W_,2016), 5)
  UpdateReal(DYNX(W_,2023), 6)
  UpdateReal(DYNX(W_,1985), 7)
  UpdateReal(DYNX(W_,2130), 8)
  UpdateReal(DYNX(W_,2137), 9)
  UpdateReal(DYNX(W_,2099), 10)
  UpdateReal(DYNX(W_,2155), 11)
  UpdateReal(DYNX(W_,2190), 12)
  UpdateReal(DYNX(W_,1959), 13)
  UpdateReal(DYNX(W_,2675), 14)
  UpdateReal(DYNX(W_,1960), 15)
  UpdateReal(DYNX(W_,1962), 16)
  UpdateReal(DYNX(W_,2033), 17)
  UpdateReal(DYNX(W_,1986), 18)
  UpdateReal(DYNX(W_,2140), 19)
  UpdateReal(DYNX(W_,2147), 20)
  UpdateReal(DYNX(W_,2100), 21)
  UpdateReal(DYNX(W_,2200), 22)
  UpdateReal(DYNX(W_,2156), 23)
  UpdateReal(DYNX(W_,2042), 24)
  UpdateReal(DYNX(W_,2086), 25)
  UpdateReal(DYNX(W_,2026), 26)
  UpdateReal(DYNX(W_,2120), 27)
  UpdateReal(DYNX(W_,2127), 28)
  UpdateReal(DYNX(W_,2098), 29)
  UpdateReal(DYNX(W_,2154), 30)
  UpdateReal(DYNX(W_,2180), 31)
  UpdateReal(DYNX(W_,2173), 32)
  UpdateReal(DYNX(W_,2069), 33)
  UpdateReal(DYNX(W_,2076), 34)
  UpdateReal(DYNX(W_,2041), 35)
  UpdateReal(DYNX(W_,1984), 36)
  UpdateReal(DYNX(W_,2013), 37)
  UpdateReal(DYNX(W_,2006), 38)
  UpdateReal(DYNX(W_,2066), 39)
EndMixedSystemOfEquations

DYNX(W_,2059) =  -DYNX(W_,2006);
DYNX(W_,2079) =  -DYNX(W_,2026);
DYNX(W_,2183) =  -DYNX(W_,2130);
DYNX(W_,2193) =  -DYNX(W_,2140);
DYNX(W_,2093) = DYNX(W_,2042)-DYNX(W_,1986);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(14);
DYNX(W_,1970) = DYNX(W_,2183)+DYNX(W_,1968)-DYNX(W_,2193);
DYNX(W_,2092) = DYNX(W_,2041)-DYNX(W_,1985);
DYNX(W_,2091) =  -(DYNX(W_,2041)-DYNX(W_,1985)+DYNX(W_,2042)-DYNX(W_,1986)+
  DYNX(W_,1960));
DYNX(W_,1966) = DYNX(W_,2059)+DYNX(W_,2026)+DYNX(W_,2183)+DYNX(W_,1968)-
  DYNX(W_,2193);
DYNX(W_,2356) = DYNX(W_,1966)-DYNX(W_,2376);
DYNX(W_,2384) =  -DYNX(W_,2388)*DYNX(W_,1969);
DYNX(W_,2357) = DYNX(W_,1968)-DYNX(W_,2384);
DYNX(W_,2392) =  -DYNX(W_,2396)*DYNX(W_,1971);
DYNX(W_,2358) = DYNX(W_,1970)-DYNX(W_,2392);
DYNX(W_,2435) = (-0.3333333333333333)*(DYNX(W_,2358)-2*DYNX(W_,2357)+
  DYNX(W_,2356));
DYNX(W_,2349) = DYNX(W_,2357)-DYNX(W_,2435);
DYNX(W_,2434) = DYNX(W_,2356)-DYNX(W_,2349);
DYNX(W_,2436) = DYNX(W_,2358)-DYNX(W_,2349);
DYNX(W_,2405) = 0.6666666666666666*DYNX(W_,2434)-0.33333333333333315*
  DYNX(W_,2435)-0.3333333333333336*DYNX(W_,2436);
DYNX(W_,2541) =  -DYNX(W_,2528)*DYNX(DYNhelp,1422);
DYNX(W_,2543) = DYNX(W_,2528)*DYNX(DYNhelp,1421);
DYNX(W_,2344) = DYNX(W_,2539)*DYNX(X_,19)+DYNX(W_,2540)*DYNX(X_,20);
DYNX(W_,2546) = DYNX(W_,2402)+DYNX(W_,2344);
DYNX(W_,2530) = DYNX(W_,2552)*DYNX(W_,2546);
DYNX(W_,2406) = 0.5773502691896257*DYNX(W_,2435)-0.5773502691896255*
  DYNX(W_,2436);
DYNX(W_,2544) =  -DYNX(W_,2528)*DYNX(DYNhelp,1422);

 /* Linear system of equations to solve. */
/* Tag: simulation.linear[12] */
/* Introducing 14 common subexpressions used in 24 expressions */
/* Of the common subexpressions 14 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,1918) = DYNX(W_,2541)*DYNX(X_,19);
DYNX(DYNhelp,1919) = DYNX(W_,2542)*DYNX(X_,20);
DYNX(DYNhelp,1920) = DYNX(DYNhelp,1918)+DYNX(DYNhelp,1919);
DYNX(DYNhelp,1921) = DYNX(W_,2543)*DYNX(X_,19);
DYNX(DYNhelp,1922) = DYNX(W_,2544)*DYNX(X_,20);
DYNX(DYNhelp,1923) = DYNX(DYNhelp,1921)+DYNX(DYNhelp,1922);
DYNX(DYNhelp,1924) = DYNX(W_,2552)*DYNX(W_,2539);
DYNX(DYNhelp,1925) = DYNX(W_,2549)*DYNX(W_,2537);
DYNX(DYNhelp,1926) = DYNX(W_,2541)*DYNX(W_,2529);
DYNX(DYNhelp,1927) = DYNX(W_,2543)*DYNX(W_,2530);
DYNX(DYNhelp,1928) = DYNX(W_,2552)*DYNX(W_,2540);
DYNX(DYNhelp,1929) = DYNX(W_,2549)*DYNX(W_,2538);
DYNX(DYNhelp,1930) = DYNX(W_,2542)*DYNX(W_,2529);
DYNX(DYNhelp,1931) = DYNX(W_,2544)*DYNX(W_,2530);
/* Automatic tearing of linear system of 14 simultaneous equations
gave a linear system of 4 equations for numerical solution.*/
{
  const char*const varnames_[]={"threePhaseMotor2.aimc.lssigma.der(i_[2])", 
    "threePhaseMotor2.aimc.der(idq_rr[1])", "threePhaseMotor2.aimc.lssigma.der(i_[1])",
     "threePhaseMotor2.aimc.der(idq_rr[2])"};
  const double nominal_[]={1, 1, 1, 1};
  DidLinearSystemOfEquations(J, b, y, 4, DYNX(DYNhelp,1932), 64, 
    DYNX(did_->helpvari_vec,136), 12);
  /* Jacobian depending on continuous variables */
  SetNeedFactor(J);
  if (NeedFactor(J)) {
    MatrixZeros(J);
    SetMatrixLeading(J, 1, 2, 4, (-1.0)*DYNX(DYNhelp,1925));
    SetMatrixLeading(J, 1, 3, 4, (-1.0)*DYNX(W_,2549)-DYNX(W_,2397));
    SetMatrixLeading(J, 1, 4, 4, (-1.0)*DYNX(DYNhelp,1929));
    SetMatrixLeading(J, 2, 1, 4, (-1.0)*DYNX(W_,2552)-DYNX(W_,2398));
    SetMatrixLeading(J, 2, 2, 4, (-1.0)*DYNX(DYNhelp,1924));
    SetMatrixLeading(J, 2, 4, 4, (-1.0)*DYNX(DYNhelp,1928));
    SetMatrixLeading(J, 3, 1, 4, DYNX(DYNhelp,1924));
    SetMatrixLeading(J, 3, 2, 4, DYNX(W_,2558)+DYNX(W_,2552)+(DYNX(W_,2549)-
      DYNX(W_,2552))*sqr(DYNX(W_,2537)));
    SetMatrixLeading(J, 3, 3, 4, DYNX(DYNhelp,1925));
    SetMatrixLeading(J, 3, 4, 4, DYNX(DYNhelp,1924)*DYNX(W_,2540)+
      DYNX(DYNhelp,1925)*DYNX(W_,2538));
    SetMatrixLeading(J, 4, 1, 4, DYNX(DYNhelp,1928));
    SetMatrixLeading(J, 4, 2, 4, DYNX(DYNhelp,1928)*DYNX(W_,2539)+
      DYNX(DYNhelp,1929)*DYNX(W_,2537));
    SetMatrixLeading(J, 4, 3, 4, DYNX(DYNhelp,1929));
    SetMatrixLeading(J, 4, 4, 4, DYNX(W_,2558)+DYNX(W_,2549)+(DYNX(W_,2552)-
      DYNX(W_,2549))*sqr(DYNX(W_,2540)));
  }
  SetVector(b, 1, DYNX(W_,2549)*DYNX(DYNhelp,1920)-DYNX(W_,2405));
  SetVector(b, 2, DYNX(W_,2552)*DYNX(DYNhelp,1923)-DYNX(W_,2406));
  SetVector(b, 3,  -(DYNX(W_,2564)*DYNX(X_,19)+DYNX(DYNhelp,1924)*
    DYNX(DYNhelp,1923)+DYNX(DYNhelp,1925)*DYNX(DYNhelp,1920)+DYNX(DYNhelp,1926)+
    DYNX(DYNhelp,1927)));
  SetVector(b, 4,  -(DYNX(W_,2564)*DYNX(X_,20)+DYNX(DYNhelp,1928)*
    DYNX(DYNhelp,1923)+DYNX(DYNhelp,1929)*DYNX(DYNhelp,1920)+DYNX(DYNhelp,1930)+
    DYNX(DYNhelp,1931)));
  SetVector(y, 1, RememberSimple_(DYNX(W_,2404), 66));
  SetVector(y, 2, RememberSimple_(DYNX(F_,19), 67));
  SetVector(y, 3, RememberSimple_(DYNX(W_,2403), 68));
  SetVector(y, 4, RememberSimple_(DYNX(F_,20), 69));
  SolveLinearSystemOfEquations(J, b, y, 10);
  DYNX(W_,2404) = GetVector(y, 1);
  DYNX(F_,19) = GetVector(y, 2);
  DYNX(W_,2403) = GetVector(y, 3);
  DYNX(F_,20) = GetVector(y, 4);
  EndStaticLinearSystemOfEquations(J);
}
DYNX(W_,2346) = DYNX(DYNhelp,1921)+DYNX(W_,2539)*DYNX(F_,19)+DYNX(DYNhelp,1922)+
  DYNX(W_,2540)*DYNX(F_,20);
DYNX(W_,2548) = DYNX(W_,2404)+DYNX(W_,2346);
DYNX(W_,2532) = DYNX(W_,2552)*DYNX(W_,2548);
DYNX(W_,2400) = DYNX(W_,2406)-DYNX(W_,2532);
DYNX(W_,2345) = DYNX(DYNhelp,1918)+DYNX(W_,2537)*DYNX(F_,19)+DYNX(DYNhelp,1919)+
  DYNX(W_,2538)*DYNX(F_,20);
DYNX(W_,2547) = DYNX(W_,2403)+DYNX(W_,2345);
DYNX(W_,2531) = DYNX(W_,2549)*DYNX(W_,2547);
DYNX(W_,2535) = DYNX(DYNhelp,1926)+DYNX(W_,2537)*DYNX(W_,2531)+DYNX(DYNhelp,1927)
  +DYNX(W_,2539)*DYNX(W_,2532);
DYNX(W_,2399) = DYNX(W_,2405)-DYNX(W_,2531);
DYNX(W_,2536) = DYNX(DYNhelp,1930)+DYNX(W_,2538)*DYNX(W_,2531)+DYNX(DYNhelp,1931)
  +DYNX(W_,2540)*DYNX(W_,2532);
 /* End of Equation Block */ 

DYNX(W_,2288) = 1.5*DYNX(W_,2526)*(DYNX(W_,2402)*DYNX(W_,2529)-DYNX(W_,2401)*
  DYNX(W_,2530));

 /* Linear system of equations to solve. */
/* Tag: simulation.linear[13] */
DYNX(F_,23) = RememberSimple_(DYNX(F_,23), 70);
SolveScalarLinearParametric(DYNX(W_,2663)+DYNX(W_,2289),"fan2.inertia.J+threePhaseMotor2.aimc.inertiaRotor.J",
   DYNX(W_,2288),"threePhaseMotor2.aimc.tauElectrical", DYNX(F_,23),
  "der(fan2.inertia.w)");
DYNX(W_,2573) = DYNX(W_,2289)*DYNX(F_,23)-DYNX(W_,2288);
 /* End of Equation Block */ 


 /* Linear system of equations to solve. */
/* Tag: simulation.linear[14] */
{
  const char*const varnames_[]={"threePhaseMotor2.aimc.der(idq_sr[2])", 
    "threePhaseMotor2.aimc.der(idq_sr[1])"};
  const double nominal_[]={1, 1};
  DidLinearSystemOfEquations(J, b, y, 2, DYNX(DYNhelp,1996), 24, 
    DYNX(did_->helpvari_vec,148), 8);
  /* Jacobian depending on continuous variables */
  SetNeedFactor(J);
  if (NeedFactor(J)) {
    MatrixZeros(J);
    SetMatrixLeading(J, 1, 1, 2,  -DYNX(W_,2538));
    SetMatrixLeading(J, 1, 2, 2,  -DYNX(W_,2537));
    SetMatrixLeading(J, 2, 1, 2,  -DYNX(W_,2540));
    SetMatrixLeading(J, 2, 2, 2,  -DYNX(W_,2539));
  }
  SetVector(b, 1, DYNX(W_,2541)*DYNX(X_,17)+DYNX(W_,2542)*DYNX(X_,18)-
    DYNX(W_,2403));
  SetVector(b, 2, DYNX(W_,2543)*DYNX(X_,17)+DYNX(W_,2544)*DYNX(X_,18)-
    DYNX(W_,2404));
  SetVector(y, 1, RememberSimple_(DYNX(F_,18), 71));
  SetVector(y, 2, RememberSimple_(DYNX(F_,17), 72));
  SolveLinearSystemOfEquations(J, b, y, 11);
  DYNX(F_,18) = GetVector(y, 1);
  DYNX(F_,17) = GetVector(y, 2);
  EndStaticLinearSystemOfEquations(J);
}
 /* End of Equation Block */ 

DYNX(W_,2658) = DYNX(X_,23)-DYNX(W_,2661);
if (NewParameters_) {
DYNX(DYNhelp,2020) = divinvGuarded(DYNX(W_,2656),"variableSpeedDrive_ThreePhase2.currentController.T");
}
DYNX(F_,22) = DYNX(DYNhelp,2020)*DYNX(W_,2658);

AcceptedSection1
DYNX(W_,335) = sampleNew2(DYNX(W_,334), DYNX(W_,333), 0);
DYNX(W_,702) = sampleNew2(DYNX(W_,701), DYNX(W_,700), 1);
DYNX(W_,737) = DYNX(W_,732)*(DYNX(X_,5)+DYNX(W_,735));
DYNX(W_,697) = IF GreaterS(DYNX(W_,737),"variableSpeedDrive_ThreePhase.y1[1]", 
  DYNX(DP_,68),"signalPWM[2].limiter.uMax", 11) THEN DYNX(DP_,68) ELSE IF LessS(
  DYNX(W_,737),"variableSpeedDrive_ThreePhase.y1[1]", DYNX(DP_,69),
  "signalPWM[2].limiter.uMin", 12) THEN DYNX(DP_,69) ELSE DYNX(W_,737);
DYNX(W_,721) = sampleNew2(DYNX(W_,720), DYNX(W_,719), 2);
DYNX(W_,716) = IF GreaterS(DYNX(W_,737),"variableSpeedDrive_ThreePhase.y1[1]", 
  DYNX(DP_,73),"signalPWM[3].limiter.uMax", 13) THEN DYNX(DP_,73) ELSE IF LessS(
  DYNX(W_,737),"variableSpeedDrive_ThreePhase.y1[1]", DYNX(DP_,74),
  "signalPWM[3].limiter.uMin", 14) THEN DYNX(DP_,74) ELSE DYNX(W_,737);
DYNX(W_,683) = sampleNew2(DYNX(W_,682), DYNX(W_,681), 3);
DYNX(W_,678) = IF GreaterS(DYNX(W_,737),"variableSpeedDrive_ThreePhase.y1[1]", 
  DYNX(DP_,63),"signalPWM[1].limiter.uMax", 15) THEN DYNX(DP_,63) ELSE IF LessS(
  DYNX(W_,737),"variableSpeedDrive_ThreePhase.y1[1]", DYNX(DP_,64),
  "signalPWM[1].limiter.uMin", 16) THEN DYNX(DP_,64) ELSE DYNX(W_,737);
DYNX(W_,1055) = sampleNew2(DYNX(W_,1054), DYNX(W_,1053), 4);
DYNX(W_,1422) = sampleNew2(DYNX(W_,1421), DYNX(W_,1420), 5);
DYNX(W_,1457) = DYNX(W_,1452)*(DYNX(X_,12)+DYNX(W_,1455));
DYNX(W_,1417) = IF GreaterS(DYNX(W_,1457),"variableSpeedDrive_ThreePhase1.y1[1]",
   DYNX(DP_,142),"signalPWM3[2].limiter.uMax", 17) THEN DYNX(DP_,142) ELSE IF 
  LessS(DYNX(W_,1457),"variableSpeedDrive_ThreePhase1.y1[1]", DYNX(DP_,143),
  "signalPWM3[2].limiter.uMin", 18) THEN DYNX(DP_,143) ELSE DYNX(W_,1457);
DYNX(W_,1441) = sampleNew2(DYNX(W_,1440), DYNX(W_,1439), 6);
DYNX(W_,1436) = IF GreaterS(DYNX(W_,1457),"variableSpeedDrive_ThreePhase1.y1[1]",
   DYNX(DP_,147),"signalPWM3[3].limiter.uMax", 19) THEN DYNX(DP_,147) ELSE IF 
  LessS(DYNX(W_,1457),"variableSpeedDrive_ThreePhase1.y1[1]", DYNX(DP_,148),
  "signalPWM3[3].limiter.uMin", 20) THEN DYNX(DP_,148) ELSE DYNX(W_,1457);
DYNX(W_,1403) = sampleNew2(DYNX(W_,1402), DYNX(W_,1401), 7);
DYNX(W_,1398) = IF GreaterS(DYNX(W_,1457),"variableSpeedDrive_ThreePhase1.y1[1]",
   DYNX(DP_,137),"signalPWM3[1].limiter.uMax", 21) THEN DYNX(DP_,137) ELSE IF 
  LessS(DYNX(W_,1457),"variableSpeedDrive_ThreePhase1.y1[1]", DYNX(DP_,138),
  "signalPWM3[1].limiter.uMin", 22) THEN DYNX(DP_,138) ELSE DYNX(W_,1457);
DYNX(W_,2606) = sampleNew2(DYNX(W_,2605), DYNX(W_,2604), 8);
DYNX(W_,2660) = DYNX(W_,2655)*(DYNX(X_,22)+DYNX(W_,2658));
DYNX(W_,2601) = IF GreaterS(DYNX(W_,2660),"variableSpeedDrive_ThreePhase2.y1[1]",
   DYNX(DP_,336),"signalPWM5[1].limiter.uMax", 23) THEN DYNX(DP_,336) ELSE IF 
  LessS(DYNX(W_,2660),"variableSpeedDrive_ThreePhase2.y1[1]", DYNX(DP_,337),
  "signalPWM5[1].limiter.uMin", 24) THEN DYNX(DP_,337) ELSE DYNX(W_,2660);
DYNX(W_,2644) = sampleNew2(DYNX(W_,2643), DYNX(W_,2642), 9);
DYNX(W_,2639) = IF GreaterS(DYNX(W_,2660),"variableSpeedDrive_ThreePhase2.y1[1]",
   DYNX(DP_,346),"signalPWM5[3].limiter.uMax", 25) THEN DYNX(DP_,346) ELSE IF 
  LessS(DYNX(W_,2660),"variableSpeedDrive_ThreePhase2.y1[1]", DYNX(DP_,347),
  "signalPWM5[3].limiter.uMin", 26) THEN DYNX(DP_,347) ELSE DYNX(W_,2660);
DYNX(W_,2625) = sampleNew2(DYNX(W_,2624), DYNX(W_,2623), 10);
DYNX(W_,2620) = IF GreaterS(DYNX(W_,2660),"variableSpeedDrive_ThreePhase2.y1[1]",
   DYNX(DP_,341),"signalPWM5[2].limiter.uMax", 27) THEN DYNX(DP_,341) ELSE IF 
  LessS(DYNX(W_,2660),"variableSpeedDrive_ThreePhase2.y1[1]", DYNX(DP_,342),
  "signalPWM5[2].limiter.uMin", 28) THEN DYNX(DP_,342) ELSE DYNX(W_,2660);
if (NewParameters_) {
DYNX(DYNhelp,2021) = divinvGuarded(DYNX(W_,1512),"batteryPack.summary.core_Q_cap_aged[1, 1]");
}
DYNX(W_,1597) = DYNX(DYNhelp,2021)*DYNX(X_,14);
DYNX(W_,1602) = PRE(DYNX(W_,1602), 48);
  beginwhenBlock
  whenModelica(initial(), 11) 
    DYNX(W_,1602) = IF DYNTime >= DYNX(W_,1601) THEN (IF DYNX(DP_,187) THEN 
      DYNX(W_,1597) < DYNX(W_,1598) ELSE true) ELSE false;
  endwhenModelica()

  whenModelica( NOT PRE(DYNX(W_,1602), 48) AND GreaterEqualTimeMinor(
    DYNX(W_,1601), 0) AND ( NOT DYNX(DP_,187) OR DYNX(DP_,187) AND LessMinor(
    DYNX(W_,1597),"batteryPack.core.capacity.limitSoC.x", DYNX(W_,1598),
    "batteryPack.core.capacity.limitSoC.xMax", 31)), 12) 
    DYNX(W_,1602) = true;
  endwhenModelica()
  endwhenBlock

DYNX(W_,1603) = PRE(DYNX(W_,1603), 49);
  beginwhenBlock
  whenModelica(initial(), 13) 
    DYNX(W_,1603) = IF DYNTime >= DYNX(W_,1601) THEN (IF DYNX(DP_,187) THEN 
      DYNX(W_,1597) > DYNX(W_,1599) ELSE true) ELSE false;
  endwhenModelica()

  whenModelica( NOT PRE(DYNX(W_,1603), 49) AND GreaterEqualTimeMinor(
    DYNX(W_,1601), 0) AND ( NOT DYNX(DP_,187) OR DYNX(DP_,187) AND GreaterMinor(
    DYNX(W_,1597),"batteryPack.core.capacity.limitSoC.x", DYNX(W_,1599),
    "batteryPack.core.capacity.limitSoC.xMin", 32)), 14) 
    DYNX(W_,1603) = true;
  endwhenModelica()
  endwhenBlock

DYNX(W_,1618) = DYNX(DP_,196)+DYNX(W_,1597)*DYNX(W_,1635);
DYNX(W_,1622) = DYNX(W_,1618)*DYNX(W_,1611)*DYNX(DP_,192);
DYNX(W_,1628) = PRE(DYNX(W_,1628), 50);
  beginwhenBlock
  whenModelica(initial(), 15) 
    DYNX(W_,1628) = IF DYNTime >= DYNX(W_,1627) THEN (IF DYNX(DP_,194) THEN 
      DYNX(W_,1622) < DYNX(W_,1623) ELSE true) ELSE false;
  endwhenModelica()

  whenModelica( NOT PRE(DYNX(W_,1628), 50) AND GreaterEqualTimeMinor(
    DYNX(W_,1627), 1) AND ( NOT DYNX(DP_,194) OR DYNX(DP_,194) AND LessMinor(
    DYNX(W_,1622),"batteryPack.core.voltage.limitCellOCV.x", DYNX(W_,1623),
    "batteryPack.core.voltage.limitCellOCV.xMax", 33)), 16) 
    DYNX(W_,1628) = true;
  endwhenModelica()
  endwhenBlock

DYNX(W_,1629) = PRE(DYNX(W_,1629), 51);
  beginwhenBlock
  whenModelica(initial(), 17) 
    DYNX(W_,1629) = IF DYNTime >= DYNX(W_,1627) THEN (IF DYNX(DP_,194) THEN 
      DYNX(W_,1622) > DYNX(W_,1624) ELSE true) ELSE false;
  endwhenModelica()

  whenModelica( NOT PRE(DYNX(W_,1629), 51) AND GreaterEqualTimeMinor(
    DYNX(W_,1627), 1) AND ( NOT DYNX(DP_,194) OR DYNX(DP_,194) AND GreaterMinor(
    DYNX(W_,1622),"batteryPack.core.voltage.limitCellOCV.x", DYNX(W_,1624),
    "batteryPack.core.voltage.limitCellOCV.xMin", 34)), 18) 
    DYNX(W_,1629) = true;
  endwhenModelica()
  endwhenBlock

if (NewParameters_) {
DYNX(DYNhelp,2022) = divinvGuarded(DYNX(W_,1551),"batteryPack.core.summary.ngs");
}
DYNX(W_,1699) = DYNX(DYNhelp,2022)*DYNX(W_,1622);
DYNX(W_,1705) = PRE(DYNX(W_,1705), 52);
  beginwhenBlock
  whenModelica(initial(), 19) 
    DYNX(W_,1705) = IF DYNTime >= DYNX(W_,1704) THEN (IF DYNX(DP_,212) THEN 
      DYNX(W_,1699) < DYNX(W_,1700) ELSE true) ELSE false;
  endwhenModelica()

  whenModelica( NOT PRE(DYNX(W_,1705), 52) AND GreaterEqualTimeMinor(
    DYNX(W_,1704), 2) AND ( NOT DYNX(DP_,212) OR DYNX(DP_,212) AND LessMinor(
    DYNX(W_,1699),"batteryPack.core.limitVoltage.x", DYNX(W_,1700),
    "batteryPack.core.limitVoltage.xMax", 35)), 20) 
    DYNX(W_,1705) = true;
  endwhenModelica()
  endwhenBlock

DYNX(W_,1706) = PRE(DYNX(W_,1706), 53);
  beginwhenBlock
  whenModelica(initial(), 21) 
    DYNX(W_,1706) = IF DYNTime >= DYNX(W_,1704) THEN (IF DYNX(DP_,212) THEN 
      DYNX(W_,1699) > DYNX(W_,1701) ELSE true) ELSE false;
  endwhenModelica()

  whenModelica( NOT PRE(DYNX(W_,1706), 53) AND GreaterEqualTimeMinor(
    DYNX(W_,1704), 2) AND ( NOT DYNX(DP_,212) OR DYNX(DP_,212) AND GreaterMinor(
    DYNX(W_,1699),"batteryPack.core.limitVoltage.x", DYNX(W_,1701),
    "batteryPack.core.limitVoltage.xMin", 36)), 22) 
    DYNX(W_,1706) = true;
  endwhenModelica()
  endwhenBlock

DYNX(W_,1731) = PRE(DYNX(W_,1731), 54);
  beginwhenBlock
  whenModelica(initial(), 23) 
    DYNX(W_,1731) = IF DYNTime >= DYNX(W_,1730) THEN (IF DYNX(DP_,215) THEN 0.0
       < DYNX(W_,1726) ELSE true) ELSE false;
  endwhenModelica()

  whenModelica( NOT PRE(DYNX(W_,1731), 54) AND GreaterEqualTimeMinor(
    DYNX(W_,1730), 3) AND ( NOT DYNX(DP_,215) OR DYNX(DP_,215) AND 0.0 < 
    DYNX(W_,1726)), 24) 
    DYNX(W_,1731) = true;
  endwhenModelica()
  endwhenBlock

DYNX(W_,1732) = PRE(DYNX(W_,1732), 55);
  beginwhenBlock
  whenModelica(initial(), 25) 
    DYNX(W_,1732) = IF DYNTime >= DYNX(W_,1730) THEN (IF DYNX(DP_,215) THEN 0.0
       > DYNX(W_,1727) ELSE true) ELSE false;
  endwhenModelica()

  whenModelica( NOT PRE(DYNX(W_,1732), 55) AND GreaterEqualTimeMinor(
    DYNX(W_,1730), 3) AND ( NOT DYNX(DP_,215) OR DYNX(DP_,215) AND 0.0 > 
    DYNX(W_,1727)), 26) 
    DYNX(W_,1732) = true;
  endwhenModelica()
  endwhenBlock

DYNX(W_,1740) = PRE(DYNX(W_,1740), 56);
  beginwhenBlock
  whenModelica(initial(), 27) 
    DYNX(W_,1740) = IF DYNTime >= DYNX(W_,1739) THEN (IF DYNX(DP_,217) THEN 0.0
       < DYNX(W_,1735) ELSE true) ELSE false;
  endwhenModelica()

  whenModelica( NOT PRE(DYNX(W_,1740), 56) AND GreaterEqualTimeMinor(
    DYNX(W_,1739), 4) AND ( NOT DYNX(DP_,217) OR DYNX(DP_,217) AND 0.0 < 
    DYNX(W_,1735)), 28) 
    DYNX(W_,1740) = true;
  endwhenModelica()
  endwhenBlock

DYNX(W_,1741) = PRE(DYNX(W_,1741), 57);
  beginwhenBlock
  whenModelica(initial(), 29) 
    DYNX(W_,1741) = IF DYNTime >= DYNX(W_,1739) THEN (IF DYNX(DP_,217) THEN 0.0
       > DYNX(W_,1736) ELSE true) ELSE false;
  endwhenModelica()

  whenModelica( NOT PRE(DYNX(W_,1741), 57) AND GreaterEqualTimeMinor(
    DYNX(W_,1739), 4) AND ( NOT DYNX(DP_,217) OR DYNX(DP_,217) AND 0.0 > 
    DYNX(W_,1736)), 30) 
    DYNX(W_,1741) = true;
  endwhenModelica()
  endwhenBlock

DYNX(W_,1508) = DYNX(W_,1622);
DYNX(W_,1510) = DYNX(W_,1661)*(1+DYNX(W_,1652)*(DYNX(X_,15)-DYNX(W_,1651)));
DYNX(W_,1502) = (PushModelContext(1,"Electrification.Batteries.Utilities.Functions.CurrentAtMaximumPower(batteryPack.summary.core_ocv, batteryPack.summary.core_R_max_dch, 1, 1)")
  Electrification_Batteries_Utilities_Functions_CurrentAtMaximumPower(
  RealTemporaryDense( &DYNX(W_,1508), 2, 1, 1), RealTemporaryDense( 
  &DYNX(W_,1510), 2, 1, 1), 1, 1));
PopAllMarks();
DYNX(W_,1844) = DYNX(W_,1502)+DYNX(DP_,169);
DYNX(W_,1849) = PRE(DYNX(W_,1849), 58);
  beginwhenBlock
  whenModelica(initial(), 31) 
    DYNX(W_,1849) = IF DYNTime >= DYNX(W_,1848) THEN (IF DYNX(DP_,241) THEN 0.0
       < DYNX(W_,1844) ELSE true) ELSE false;
  endwhenModelica()

  whenModelica( NOT PRE(DYNX(W_,1849), 58) AND GreaterEqualTimeMinor(
    DYNX(W_,1848), 5) AND ( NOT DYNX(DP_,241) OR DYNX(DP_,241) AND LessMinor(0.0,
    "0.0", DYNX(W_,1844),"batteryPack.limitDischarge.xMax", 37)), 32) 
    DYNX(W_,1849) = true;
  endwhenModelica()
  endwhenBlock

DYNX(W_,1850) = PRE(DYNX(W_,1850), 59);
  beginwhenBlock
  whenModelica(initial(), 33) 
    DYNX(W_,1850) = IF DYNTime >= DYNX(W_,1848) THEN true ELSE false;
  endwhenModelica()

  whenModelica( NOT PRE(DYNX(W_,1850), 59) AND GreaterEqualTimeMinor(
    DYNX(W_,1848), 5) AND ( NOT DYNX(DP_,241) OR DYNX(DP_,241)), 34) 
    DYNX(W_,1850) = true;
  endwhenModelica()
  endwhenBlock

beginwhenBlock
whenModelica(real2integerEventMinor(divGuarded(DYNTime-DYNX(W_,342),
  "time-signalPWM2.sawtooth.startTime",DYNX(W_,339),"signalPWM2.sawtooth.period"),
  "(time-signalPWM2.sawtooth.startTime)/signalPWM2.sawtooth.period", 0) > PRE(
  DYNX(W_,344), 26), 35) 
  DYNX(W_,344) = PRE(DYNX(W_,344), 26)+1;
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelicaS(DYNX(W_,335))
  DYNX(W_,337) = DYNX(W_,330);
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelica(real2integerEventMinor(divGuarded(DYNTime-DYNX(W_,709),
  "time-signalPWM[2].sawtooth.startTime",DYNX(W_,706),"signalPWM[2].sawtooth.period"),
  "(time-signalPWM[2].sawtooth.startTime)/signalPWM[2].sawtooth.period", 1) > 
  PRE(DYNX(W_,711), 28), 36) 
  DYNX(W_,711) = PRE(DYNX(W_,711), 28)+1;
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelicaS(DYNX(W_,702))
  DYNX(W_,704) = DYNX(W_,697);
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelica(real2integerEventMinor(divGuarded(DYNTime-DYNX(W_,728),
  "time-signalPWM[3].sawtooth.startTime",DYNX(W_,725),"signalPWM[3].sawtooth.period"),
  "(time-signalPWM[3].sawtooth.startTime)/signalPWM[3].sawtooth.period", 2) > 
  PRE(DYNX(W_,730), 30), 37) 
  DYNX(W_,730) = PRE(DYNX(W_,730), 30)+1;
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelicaS(DYNX(W_,721))
  DYNX(W_,723) = DYNX(W_,716);
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelica(real2integerEventMinor(divGuarded(DYNTime-DYNX(W_,690),
  "time-signalPWM[1].sawtooth.startTime",DYNX(W_,687),"signalPWM[1].sawtooth.period"),
  "(time-signalPWM[1].sawtooth.startTime)/signalPWM[1].sawtooth.period", 3) > 
  PRE(DYNX(W_,692), 32), 38) 
  DYNX(W_,692) = PRE(DYNX(W_,692), 32)+1;
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelicaS(DYNX(W_,683))
  DYNX(W_,685) = DYNX(W_,678);
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelica(real2integerEventMinor(divGuarded(DYNTime-DYNX(W_,1062),
  "time-signalPWM1.sawtooth.startTime",DYNX(W_,1059),"signalPWM1.sawtooth.period"),
  "(time-signalPWM1.sawtooth.startTime)/signalPWM1.sawtooth.period", 4) > PRE(
  DYNX(W_,1064), 34), 39) 
  DYNX(W_,1064) = PRE(DYNX(W_,1064), 34)+1;
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelicaS(DYNX(W_,1055))
  DYNX(W_,1057) = DYNX(W_,1050);
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelica(real2integerEventMinor(divGuarded(DYNTime-DYNX(W_,1429),
  "time-signalPWM3[2].sawtooth.startTime",DYNX(W_,1426),"signalPWM3[2].sawtooth.period"),
  "(time-signalPWM3[2].sawtooth.startTime)/signalPWM3[2].sawtooth.period", 5) > 
  PRE(DYNX(W_,1431), 36), 40) 
  DYNX(W_,1431) = PRE(DYNX(W_,1431), 36)+1;
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelicaS(DYNX(W_,1422))
  DYNX(W_,1424) = DYNX(W_,1417);
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelica(real2integerEventMinor(divGuarded(DYNTime-DYNX(W_,1448),
  "time-signalPWM3[3].sawtooth.startTime",DYNX(W_,1445),"signalPWM3[3].sawtooth.period"),
  "(time-signalPWM3[3].sawtooth.startTime)/signalPWM3[3].sawtooth.period", 6) > 
  PRE(DYNX(W_,1450), 38), 41) 
  DYNX(W_,1450) = PRE(DYNX(W_,1450), 38)+1;
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelicaS(DYNX(W_,1441))
  DYNX(W_,1443) = DYNX(W_,1436);
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelica(real2integerEventMinor(divGuarded(DYNTime-DYNX(W_,1410),
  "time-signalPWM3[1].sawtooth.startTime",DYNX(W_,1407),"signalPWM3[1].sawtooth.period"),
  "(time-signalPWM3[1].sawtooth.startTime)/signalPWM3[1].sawtooth.period", 7) > 
  PRE(DYNX(W_,1412), 40), 42) 
  DYNX(W_,1412) = PRE(DYNX(W_,1412), 40)+1;
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelicaS(DYNX(W_,1403))
  DYNX(W_,1405) = DYNX(W_,1398);
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelica(real2integerEventMinor(divGuarded(DYNTime-DYNX(W_,2613),
  "time-signalPWM5[1].sawtooth.startTime",DYNX(W_,2610),"signalPWM5[1].sawtooth.period"),
  "(time-signalPWM5[1].sawtooth.startTime)/signalPWM5[1].sawtooth.period", 8) > 
  PRE(DYNX(W_,2615), 42), 43) 
  DYNX(W_,2615) = PRE(DYNX(W_,2615), 42)+1;
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelicaS(DYNX(W_,2606))
  DYNX(W_,2608) = DYNX(W_,2601);
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelica(real2integerEventMinor(divGuarded(DYNTime-DYNX(W_,2651),
  "time-signalPWM5[3].sawtooth.startTime",DYNX(W_,2648),"signalPWM5[3].sawtooth.period"),
  "(time-signalPWM5[3].sawtooth.startTime)/signalPWM5[3].sawtooth.period", 9) > 
  PRE(DYNX(W_,2653), 44), 44) 
  DYNX(W_,2653) = PRE(DYNX(W_,2653), 44)+1;
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelicaS(DYNX(W_,2644))
  DYNX(W_,2646) = DYNX(W_,2639);
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelica(real2integerEventMinor(divGuarded(DYNTime-DYNX(W_,2632),
  "time-signalPWM5[2].sawtooth.startTime",DYNX(W_,2629),"signalPWM5[2].sawtooth.period"),
  "(time-signalPWM5[2].sawtooth.startTime)/signalPWM5[2].sawtooth.period", 10)
   > PRE(DYNX(W_,2634), 46), 45) 
  DYNX(W_,2634) = PRE(DYNX(W_,2634), 46)+1;
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelicaS(DYNX(W_,2625))
  DYNX(W_,2627) = DYNX(W_,2620);
endwhenModelica()
endwhenBlock



if (DYNX(W_,1602)) {
  AssertModelica4(LessEqual(DYNX(W_,1597),"batteryPack.core.capacity.limitSoC.x",
     DYNX(W_,1598),"batteryPack.core.capacity.limitSoC.xMax", 93),
    "batteryPack.core.capacity.limitSoC.x <= batteryPack.core.capacity.limitSoC.xMax",
     StringAdd(StringAdd(StringAdd("State of Charge (SoC) above limit ",
    Real2String2(DYNX(W_,1598), true, 0)),"!\n  "),""), DYNX(W_,1604),
    DYNX(did_->helpvari_vec,156));
  PopAllMarks();
}
if (DYNX(W_,1603)) {
  AssertModelica4(GreaterEqual(DYNX(W_,1597),"batteryPack.core.capacity.limitSoC.x",
     DYNX(W_,1599),"batteryPack.core.capacity.limitSoC.xMin", 94),
    "batteryPack.core.capacity.limitSoC.x >= batteryPack.core.capacity.limitSoC.xMin",
     StringAdd(StringAdd(StringAdd("State of Charge (SoC) below limit ",
    Real2String2(DYNX(W_,1599), true, 0)),"!\n  "),""), DYNX(W_,1604),
    DYNX(did_->helpvari_vec,157));
  PopAllMarks();
}
if (DYNX(W_,1628)) {
  AssertModelica4(LessEqual(DYNX(W_,1622),"batteryPack.core.voltage.limitCellOCV.x",
     DYNX(W_,1623),"batteryPack.core.voltage.limitCellOCV.xMax", 95),
    "batteryPack.core.voltage.limitCellOCV.x <= batteryPack.core.voltage.limitCellOCV.xMax",
     StringAdd(StringAdd(StringAdd("Battery cell OCV above limit ",Real2String2(
    DYNX(W_,1623), true, 0)),"!\n  "),"The OCV model is outside of its' valid range"),
     DYNX(W_,1630),DYNX(did_->helpvari_vec,158));
  PopAllMarks();
}
if (DYNX(W_,1629)) {
  AssertModelica4(GreaterEqual(DYNX(W_,1622),"batteryPack.core.voltage.limitCellOCV.x",
     DYNX(W_,1624),"batteryPack.core.voltage.limitCellOCV.xMin", 96),
    "batteryPack.core.voltage.limitCellOCV.x >= batteryPack.core.voltage.limitCellOCV.xMin",
     StringAdd(StringAdd(StringAdd("Battery cell OCV below limit ",Real2String2(
    DYNX(W_,1624), true, 0)),"!\n  "),"The OCV model is outside of its' valid range"),
     DYNX(W_,1630),DYNX(did_->helpvari_vec,159));
  PopAllMarks();
}
if (DYNX(W_,1705)) {
  AssertModelica4(LessEqual(DYNX(W_,1699),"batteryPack.core.limitVoltage.x", 
    DYNX(W_,1700),"batteryPack.core.limitVoltage.xMax", 97),"batteryPack.core.limitVoltage.x <= batteryPack.core.limitVoltage.xMax",
     StringAdd(StringAdd(StringAdd("Battery cell voltage above limit ",
    Real2String2(DYNX(W_,1700), true, 0)),"!\n  "),"This may be caused by too high current."),
     DYNX(W_,1707),DYNX(did_->helpvari_vec,160));
  PopAllMarks();
}
if (DYNX(W_,1706)) {
  AssertModelica4(GreaterEqual(DYNX(W_,1699),"batteryPack.core.limitVoltage.x", 
    DYNX(W_,1701),"batteryPack.core.limitVoltage.xMin", 98),"batteryPack.core.limitVoltage.x >= batteryPack.core.limitVoltage.xMin",
     StringAdd(StringAdd(StringAdd("Battery cell voltage below limit ",
    Real2String2(DYNX(W_,1701), true, 0)),"!\n  "),"This may be caused by too high current."),
     DYNX(W_,1707),DYNX(did_->helpvari_vec,161));
  PopAllMarks();
}
if (DYNX(W_,1731)) {
  AssertModelica4(0.0 <= DYNX(W_,1726),"0.0 <= batteryPack.core.limitCurrent.xMax",
     StringAdd(StringAdd(StringAdd("Cell current above limit ",Real2String2(
    DYNX(W_,1726), true, 0)),"!\n  "),""), DYNX(W_,1733),DYNX(did_->helpvari_vec,162));
  PopAllMarks();
}
if (DYNX(W_,1732)) {
  AssertModelica4(0.0 >= DYNX(W_,1727),"0.0 >= batteryPack.core.limitCurrent.xMin",
     StringAdd(StringAdd(StringAdd("Cell current below limit ",Real2String2(
    DYNX(W_,1727), true, 0)),"!\n  "),""), DYNX(W_,1733),DYNX(did_->helpvari_vec,163));
  PopAllMarks();
}
if (DYNX(W_,1740)) {
  AssertModelica4(0.0 <= DYNX(W_,1735),"0.0 <= batteryPack.core.limitPower.xMax",
     StringAdd(StringAdd(StringAdd("Cell power above limit ",Real2String2(
    DYNX(W_,1735), true, 0)),"!\n  "),""), DYNX(W_,1742),DYNX(did_->helpvari_vec,164));
  PopAllMarks();
}
if (DYNX(W_,1741)) {
  AssertModelica4(0.0 >= DYNX(W_,1736),"0.0 >= batteryPack.core.limitPower.xMin",
     StringAdd(StringAdd(StringAdd("Cell power below limit ",Real2String2(
    DYNX(W_,1736), true, 0)),"!\n  "),""), DYNX(W_,1742),DYNX(did_->helpvari_vec,165));
  PopAllMarks();
}
if (DYNX(W_,1849)) {
  AssertModelica4(LessEqual(0.0,"0.0", DYNX(W_,1844),"batteryPack.limitDischarge.xMax",
     99),"0.0 <= batteryPack.limitDischarge.xMax", StringAdd(StringAdd(
    StringAdd("Battery discharge current above limit ",Real2String2(
    DYNX(W_,1844), true, 0)),"!\n  "),"The battery current has passed the limit of maximum discharge power. This typically results in a large voltage drop and failure to deliver power."),
     DYNX(W_,1851),DYNX(did_->helpvari_vec,166));
  PopAllMarks();
}
if (DYNX(W_,1850)) {
  AssertModelica4(true,"true", "Battery discharge current below limit -1e+60!\n  The battery current has passed the limit of maximum discharge power. This typically results in a large voltage drop and failure to deliver power.",
     DYNX(W_,1851),DYNX(did_->helpvari_vec,167));
}
AcceptedSection2
DYNX(W_,2685) = DYNX(X_,15);
DYNX(W_,2698) = DYNX(X_,15);
DYNX(W_,2699) = DYNX(X_,15);
DYNX(W_,2258) = sampleNew2(DYNX(W_,2257), DYNX(W_,2256), 11);
DYNX(W_,364) = DYNX(X_,4)-DYNX(DP_,44);
DYNX(W_,378) = DYNX(X_,4)-DYNX(DP_,44);
DYNX(W_,540) = DYNX(X_,4)-DYNX(DP_,44);
DYNX(W_,1084) = DYNX(X_,11)-DYNX(DP_,118);
DYNX(W_,1098) = DYNX(X_,11)-DYNX(DP_,118);
DYNX(W_,1260) = DYNX(X_,11)-DYNX(DP_,118);
DYNX(W_,2287) = DYNX(X_,21)-DYNX(DP_,317);
DYNX(W_,2301) = DYNX(X_,21)-DYNX(DP_,317);
DYNX(W_,2463) = DYNX(X_,21)-DYNX(DP_,317);
DYNX(W_,610) = DYNX(W_,614)*DYNX(W_,606)+DYNX(W_,616)*DYNX(W_,607);
DYNX(W_,611) = DYNX(W_,615)*DYNX(W_,606)+DYNX(W_,617)*DYNX(W_,607);
DYNX(W_,1330) = DYNX(W_,1334)*DYNX(W_,1326)+DYNX(W_,1336)*DYNX(W_,1327);
DYNX(W_,1331) = DYNX(W_,1335)*DYNX(W_,1326)+DYNX(W_,1337)*DYNX(W_,1327);
DYNX(W_,2533) = DYNX(W_,2537)*DYNX(W_,2529)+DYNX(W_,2539)*DYNX(W_,2530);
DYNX(W_,2534) = DYNX(W_,2538)*DYNX(W_,2529)+DYNX(W_,2540)*DYNX(W_,2530);
DYNX(W_,2207) = DYNX(W_,2100)-DYNX(W_,2156);
DYNX(W_,2205) = DYNX(W_,2098)-DYNX(W_,2154);
DYNX(W_,2206) =  -(DYNX(W_,2205)+DYNX(W_,2207)+DYNX(W_,1962));
DYNX(W_,7) =  -DYNX(W_,4)*DYNX(W_,10);
DYNX(W_,14) = DYNX(W_,10)+DYNX(W_,22);
DYNX(W_,19) =  -DYNX(W_,16)*DYNX(W_,22);
DYNX(W_,40) = DYNX(W_,36)-DYNX(W_,38);
DYNX(W_,41) = DYNX(W_,40)*DYNX(W_,37);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(15);
DYNX(W_,49) = DYNX(W_,43)*DYNX(W_,44);
DYNX(W_,50) = DYNX(W_,45)*DYNX(W_,46);
DYNX(W_,51) = DYNX(W_,47)*DYNX(W_,48);
DYNX(W_,52) = DYNX(W_,49)+DYNX(W_,50)+DYNX(W_,51);
DYNX(W_,88) = DYNX(W_,83)*DYNX(W_,61);
DYNX(W_,98) = DYNX(W_,93)*DYNX(W_,62);
DYNX(W_,108) = DYNX(W_,103)*DYNX(W_,63);
DYNX(W_,255) = DYNX(W_,250)*DYNX(W_,231);
DYNX(W_,265) = DYNX(W_,260)*DYNX(W_,232);
DYNX(W_,275) = DYNX(W_,270)*DYNX(W_,233);
DYNX(W_,202) = DYNX(W_,197)*DYNX(W_,175);
DYNX(W_,212) = DYNX(W_,207)*DYNX(W_,176);
DYNX(W_,222) = DYNX(W_,217)*DYNX(W_,177);
DYNX(W_,55) = DYNX(W_,88)+DYNX(W_,98)+DYNX(W_,108)+DYNX(W_,255)+DYNX(W_,265)+
  DYNX(W_,275)+DYNX(W_,202)+DYNX(W_,212)+DYNX(W_,222)+DYNX(W_,255)+DYNX(W_,265)+
  DYNX(W_,275);
DYNX(W_,58) = DYNX(W_,36)-DYNX(W_,43);
DYNX(W_,59) = DYNX(W_,36)-DYNX(W_,45);
DYNX(W_,60) = DYNX(W_,36)-DYNX(W_,47);
DYNX(W_,114) = DYNX(W_,43)-DYNX(W_,36);
DYNX(W_,115) = DYNX(W_,45)-DYNX(W_,36);
DYNX(W_,116) = DYNX(W_,47)-DYNX(W_,36);
DYNX(W_,141) = DYNX(W_,136)*DYNX(W_,117);
DYNX(W_,151) = DYNX(W_,146)*DYNX(W_,118);
DYNX(W_,161) = DYNX(W_,156)*DYNX(W_,119);
DYNX(W_,172) = DYNX(W_,43)-DYNX(W_,38);
DYNX(W_,173) = DYNX(W_,45)-DYNX(W_,38);
DYNX(W_,174) = DYNX(W_,47)-DYNX(W_,38);
DYNX(W_,228) = DYNX(W_,38)-DYNX(W_,43);
DYNX(W_,229) = DYNX(W_,38)-DYNX(W_,45);
DYNX(W_,230) = DYNX(W_,38)-DYNX(W_,47);
DYNX(W_,285) = DYNX(W_,9)-DYNX(W_,21);
DYNX(W_,286) =  -DYNX(W_,285)*DYNX(W_,10);
DYNX(W_,288) = DYNX(W_,287)-DYNX(W_,21);
DYNX(W_,289) =  -DYNX(W_,288)*DYNX(W_,37);
DYNX(W_,319) = DYNX(W_,314)*DYNX(W_,37);
DYNX(W_,309) = DYNX(W_,303)*DYNX(W_,304);
DYNX(W_,292) = DYNX(W_,319)+DYNX(W_,309);
DYNX(W_,415) = DYNX(W_,43)-DYNX(W_,426);
DYNX(W_,416) = DYNX(W_,45)-DYNX(W_,426);
DYNX(W_,417) = DYNX(W_,47)-DYNX(W_,426);
DYNX(W_,404) = (PushModelContext(1,"Modelica.Electrical.Machines.SpacePhasors.Functions.activePower({threePhaseMotor.aimc.vs[1], threePhaseMotor.aimc.vs[2], threePhaseMotor.aimc.vs[3]}, { -inverter2.ac.pin[1].i,  -inverter2.ac.pin[2].i,  -inverter2.ac.pin[3].i})")
  Modelica_Electrical_Machines_SpacePhasors_Functions_activePower(
  RealTemporaryDense( &DYNX(W_,415), 1, 3), RealScalarArray ( 3,  -DYNX(W_,44), 
   -DYNX(W_,46),  -DYNX(W_,48))));
PopAllMarks();
DYNX(W_,405) =  -DYNX(X_,6)*DYNX(W_,650);
DYNX(W_,407) = DYNX(W_,366)*DYNX(F_,6)*DYNX(X_,6);
DYNX(W_,456) =  -DYNX(W_,453)*DYNX(W_,44);
DYNX(W_,464) =  -DYNX(W_,461)*DYNX(W_,46);
DYNX(W_,472) =  -DYNX(W_,469)*DYNX(W_,48);
DYNX(W_,409) = DYNX(W_,456)+DYNX(W_,464)+DYNX(W_,472);
DYNX(W_,414) = 1.5*DYNX(W_,641)*(DYNX(X_,2)*DYNX(X_,2)+DYNX(X_,3)*DYNX(X_,3));
DYNX(W_,408) = DYNX(W_,409)+DYNX(W_,414);
DYNX(W_,428) = DYNX(W_,43)-DYNX(W_,433);
DYNX(W_,429) = DYNX(W_,45)-DYNX(W_,434);
DYNX(W_,430) = DYNX(W_,47)-DYNX(W_,435);
DYNX(W_,551) = sqrtGuarded(0.3333333333333333*(sqr(DYNX(W_,44))+sqr(DYNX(W_,46))
  +sqr(DYNX(W_,48))),"0.3333333333333333*(inverter2.ac.pin[1].i^2+inverter2.ac.pin[2].i^2+inverter2.ac.pin[3].i^2)");
DYNX(W_,556) = DYNX(W_,456)+DYNX(W_,464)+DYNX(W_,472);
DYNX(W_,585) = DYNX(W_,556)+DYNX(W_,414);
DYNX(W_,757) = DYNX(W_,755)-DYNX(W_,756);
DYNX(W_,758) = DYNX(W_,757)*DYNX(X_,16);
DYNX(W_,766) = DYNX(W_,760)*DYNX(W_,761);
DYNX(W_,767) = DYNX(W_,762)*DYNX(W_,763);
DYNX(W_,768) = DYNX(W_,764)*DYNX(W_,765);
DYNX(W_,769) = DYNX(W_,766)+DYNX(W_,767)+DYNX(W_,768);
DYNX(W_,805) = DYNX(W_,800)*DYNX(W_,778);
DYNX(W_,815) = DYNX(W_,810)*DYNX(W_,779);
DYNX(W_,825) = DYNX(W_,820)*DYNX(W_,780);
DYNX(W_,972) = DYNX(W_,967)*DYNX(W_,948);
DYNX(W_,982) = DYNX(W_,977)*DYNX(W_,949);
DYNX(W_,992) = DYNX(W_,987)*DYNX(W_,950);
DYNX(W_,919) = DYNX(W_,914)*DYNX(W_,892);
DYNX(W_,929) = DYNX(W_,924)*DYNX(W_,893);
DYNX(W_,939) = DYNX(W_,934)*DYNX(W_,894);
DYNX(W_,772) = DYNX(W_,805)+DYNX(W_,815)+DYNX(W_,825)+DYNX(W_,972)+DYNX(W_,982)+
  DYNX(W_,992)+DYNX(W_,919)+DYNX(W_,929)+DYNX(W_,939)+DYNX(W_,972)+DYNX(W_,982)+
  DYNX(W_,992);
DYNX(W_,775) = DYNX(W_,755)-DYNX(W_,760);
DYNX(W_,776) = DYNX(W_,755)-DYNX(W_,762);
DYNX(W_,777) = DYNX(W_,755)-DYNX(W_,764);
DYNX(W_,831) = DYNX(W_,760)-DYNX(W_,755);
DYNX(W_,832) = DYNX(W_,762)-DYNX(W_,755);
DYNX(W_,833) = DYNX(W_,764)-DYNX(W_,755);
DYNX(W_,858) = DYNX(W_,853)*DYNX(W_,834);
DYNX(W_,868) = DYNX(W_,863)*DYNX(W_,835);
DYNX(W_,878) = DYNX(W_,873)*DYNX(W_,836);
DYNX(W_,889) = DYNX(W_,760)-DYNX(W_,756);
DYNX(W_,890) = DYNX(W_,762)-DYNX(W_,756);
DYNX(W_,891) = DYNX(W_,764)-DYNX(W_,756);
DYNX(W_,945) = DYNX(W_,756)-DYNX(W_,760);
DYNX(W_,946) = DYNX(W_,756)-DYNX(W_,762);
DYNX(W_,947) = DYNX(W_,756)-DYNX(W_,764);
DYNX(W_,1010) =  -DYNX(W_,1008)*DYNX(X_,16);
DYNX(W_,1039) = DYNX(W_,1034)*DYNX(X_,16);
DYNX(W_,1029) =  -DYNX(W_,1002)*DYNX(X_,16);
DYNX(W_,1013) = DYNX(W_,1039)+DYNX(W_,1029);
DYNX(W_,1135) = DYNX(W_,760)-DYNX(W_,1146);
DYNX(W_,1136) = DYNX(W_,762)-DYNX(W_,1146);
DYNX(W_,1137) = DYNX(W_,764)-DYNX(W_,1146);
DYNX(W_,1124) = (PushModelContext(1,"Modelica.Electrical.Machines.SpacePhasors.Functions.activePower({threePhaseMotor1.aimc.vs[1], threePhaseMotor1.aimc.vs[2], threePhaseMotor1.aimc.vs[3]}, { -inverter1.ac.pin[1].i,  -inverter1.ac.pin[2].i,  -inverter1.ac.pin[3].i})")
  Modelica_Electrical_Machines_SpacePhasors_Functions_activePower(
  RealTemporaryDense( &DYNX(W_,1135), 1, 3), RealScalarArray ( 3,  -DYNX(W_,761),
    -DYNX(W_,763),  -DYNX(W_,765))));
PopAllMarks();
DYNX(W_,1125) =  -DYNX(X_,13)*DYNX(W_,1370);
DYNX(W_,1127) = DYNX(W_,1086)*DYNX(F_,13)*DYNX(X_,13);
DYNX(W_,1176) =  -DYNX(W_,1173)*DYNX(W_,761);
DYNX(W_,1184) =  -DYNX(W_,1181)*DYNX(W_,763);
DYNX(W_,1192) =  -DYNX(W_,1189)*DYNX(W_,765);
DYNX(W_,1129) = DYNX(W_,1176)+DYNX(W_,1184)+DYNX(W_,1192);
DYNX(W_,1134) = 1.5*DYNX(W_,1361)*(DYNX(X_,9)*DYNX(X_,9)+DYNX(X_,10)*DYNX(X_,10));
DYNX(W_,1128) = DYNX(W_,1129)+DYNX(W_,1134);
DYNX(W_,1148) = DYNX(W_,760)-DYNX(W_,1153);
DYNX(W_,1149) = DYNX(W_,762)-DYNX(W_,1154);
DYNX(W_,1150) = DYNX(W_,764)-DYNX(W_,1155);
DYNX(W_,1271) = sqrtGuarded(0.3333333333333333*(sqr(DYNX(W_,761))+sqr(
  DYNX(W_,763))+sqr(DYNX(W_,765))),"0.3333333333333333*(inverter1.ac.pin[1].i^2+inverter1.ac.pin[2].i^2+inverter1.ac.pin[3].i^2)");
DYNX(W_,1276) = DYNX(W_,1176)+DYNX(W_,1184)+DYNX(W_,1192);
DYNX(W_,1305) = DYNX(W_,1276)+DYNX(W_,1134);
DYNX(W_,1499) = (PushModelContext(1,"Electrification.Batteries.Core.OCV.Functions.AverageArrayOCV(batteryPack.summary.core_ocv, 1, 1)")
  Electrification_Batteries_Core_OCV_Functions_AverageArrayOCV(RealTemporaryDense( 
  &DYNX(W_,1508), 2, 1, 1), 1, 1));
PopAllMarks();
DYNX(W_,1503) = 0.5*DYNX(W_,1502)*DYNX(W_,1499);
DYNX(W_,1511) = DYNX(X_,14);
DYNX(W_,1505) = (PushModelContext(1,"Electrification.Batteries.Core.Capacity.Functions.arrayCapacity(batteryPack.summary.core_Q, 1, 1)")
  Electrification_Batteries_Core_Capacity_Functions_arrayCapacity(
  RealTemporaryDense( &DYNX(W_,1511), 2, 1, 1), 1, 1));
PopAllMarks();
DYNX(W_,1514) = DYNX(DYNhelp,2021)*DYNX(X_,14);
if (NewParameters_) {
DYNX(DYNhelp,2023) = divinvGuarded(DYNX(W_,1480),"batteryPack.Q_cap_all_nom");
}
DYNX(W_,1515) = DYNX(DYNhelp,2023)*DYNX(X_,14);
DYNX(W_,1557) = DYNX(DYNhelp,2022)*DYNX(W_,1622);
if (NewParameters_) {
DYNX(DYNhelp,2024) = divinvGuarded(DYNX(W_,1552),"batteryPack.core.summary.ngp");
}
DYNX(W_,1560) = DYNX(DYNhelp,2024)*DYNX(X_,14);
DYNX(W_,1562) = DYNX(DYNhelp,2022)*DYNX(W_,1510)*DYNX(W_,1552);
DYNX(W_,1563) = DYNX(DYNhelp,2022)*DYNX(W_,1510)*DYNX(W_,1552);
DYNX(W_,1633) = DYNX(X_,15)-273.15;
DYNX(W_,1619) = DYNX(W_,1633);
if (NewParameters_) {
DYNX(DYNhelp,2025) = divinvGuarded(DYNX(W_,1712),"batteryPack.core.sensors.ngs");
}
DYNX(W_,1718) = DYNX(DYNhelp,2025)*DYNX(W_,1622);
DYNX(W_,1719) = DYNX(DYNhelp,2025)*DYNX(W_,1622);
DYNX(W_,1721) = DYNX(DYNhelp,2025)*DYNX(W_,1510)*DYNX(W_,1713);
DYNX(W_,1802) = DYNX(X_,15)-DYNX(W_,1824);
DYNX(W_,1861) = DYNX(W_,1858)*DYNX(X_,16);
DYNX(W_,1872) =  -DYNX(W_,1869)*DYNX(X_,16);
DYNX(W_,1878) = DYNX(W_,1875)*DYNX(X_,16);
DYNX(W_,1889) = DYNX(W_,1867)*DYNX(X_,16);
DYNX(W_,1905) = DYNX(W_,1902)*DYNX(X_,16);
DYNX(W_,1916) =  -DYNX(W_,1913)*DYNX(X_,16);
beginwhenBlock
whenModelicaS(DYNX(W_,335))
  DYNX(W_,336) = DYNTime <= DYNX(W_,334)+DYNX(W_,333)/(double)(2);
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelicaS(DYNX(W_,683))
  DYNX(W_,684) = DYNTime <= DYNX(W_,682)+DYNX(W_,681)/(double)(2);
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelicaS(DYNX(W_,702))
  DYNX(W_,703) = DYNTime <= DYNX(W_,701)+DYNX(W_,700)/(double)(2);
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelicaS(DYNX(W_,721))
  DYNX(W_,722) = DYNTime <= DYNX(W_,720)+DYNX(W_,719)/(double)(2);
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelicaS(DYNX(W_,1055))
  DYNX(W_,1056) = DYNTime <= DYNX(W_,1054)+DYNX(W_,1053)/(double)(2);
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelicaS(DYNX(W_,1403))
  DYNX(W_,1404) = DYNTime <= DYNX(W_,1402)+DYNX(W_,1401)/(double)(2);
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelicaS(DYNX(W_,1422))
  DYNX(W_,1423) = DYNTime <= DYNX(W_,1421)+DYNX(W_,1420)/(double)(2);
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelicaS(DYNX(W_,1441))
  DYNX(W_,1442) = DYNTime <= DYNX(W_,1440)+DYNX(W_,1439)/(double)(2);
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelicaS(DYNX(W_,2258))
  DYNX(W_,2259) = DYNTime <= DYNX(W_,2257)+DYNX(W_,2256)/(double)(2);
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelicaS(DYNX(W_,2258))
  DYNX(W_,2260) = DYNX(W_,2253);
endwhenModelica()
endwhenBlock


beginwhenBlock
if (NewParameters_) {
DYNX(DYNhelp,2026) = divinvGuarded(DYNX(W_,2262),"signalPWM4.sawtooth.period");
}
DYNX(DYNhelp,2027) = real2integer(DYNX(DYNhelp,2026)*(DYNTime-DYNX(W_,2265)));
whenModelica(real2integerEventMinor(divGuarded(DYNTime-DYNX(W_,2265),
  "time-signalPWM4.sawtooth.startTime",DYNX(W_,2262),"signalPWM4.sawtooth.period"),
  "(time-signalPWM4.sawtooth.startTime)/signalPWM4.sawtooth.period", 29) > PRE(
  DYNX(W_,2267), 60), 46) 
  DYNX(W_,2266) = DYNTime;
  DYNX(W_,2267) = PRE(DYNX(W_,2267), 60)+1;
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelicaS(DYNX(W_,2606))
  DYNX(W_,2607) = DYNTime <= DYNX(W_,2605)+DYNX(W_,2604)/(double)(2);
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelicaS(DYNX(W_,2625))
  DYNX(W_,2626) = DYNTime <= DYNX(W_,2624)+DYNX(W_,2623)/(double)(2);
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelicaS(DYNX(W_,2644))
  DYNX(W_,2645) = DYNTime <= DYNX(W_,2643)+DYNX(W_,2642)/(double)(2);
endwhenModelica()
endwhenBlock


DYNX(W_,2254) = IF LessTime(DYNX(W_,2265), 17) THEN 0 ELSE divGuarded(DYNTime-
  DYNX(W_,2266),"time-signalPWM4.sawtooth.T_start",DYNX(W_,2262),
  "signalPWM4.sawtooth.period");
DYNX(W_,2255) = PRE(DYNX(W_,2260), 61);
DYNX(W_,2225) = Less(DYNX(W_,2254),"signalPWM4.greaterEqual.u1", DYNX(W_,2255),
  "signalPWM4.greaterEqual.u2", 100);
DYNX(W_,2224) = DYNX(W_,2225) AND DYNX(W_,2222);

MixedSystemOfEquations(7, DYNX(DYNhelp,2028))

   /* Linear system of equations to solve. */
  /* Tag: simulation.linear[15] */
  /* Introducing 4 common subexpressions used in 4 expressions */
  /* Of the common subexpressions 4 are reals, 0 are integers, and 0
     are booleans. */
  DYNX(DYNhelp,2035) = DYNX(W_,1943)+DYNX(W_,1931);
  DYNX(DYNhelp,2036) = IF DYNX(W_,2233) THEN DYNX(W_,2229) ELSE 1;
  DYNX(DYNhelp,2037) = IF DYNX(W_,2233) THEN 1 ELSE DYNX(W_,2228);
  DYNX(DYNhelp,2038) = DYNX(W_,2229)*DYNX(W_,2230);
  DYNX(W_,2234) = RememberSimple_(DYNX(W_,2234), 73);
  SolveScalarLinearMixed(DYNX(DYNhelp,2035)*DYNX(DYNhelp,2036)+DYNX(DYNhelp,2037),
    "(simplifiedFuelCell1.resistor1.R_actual+simplifiedFuelCell1.resistor.R_actual)*(if dcdc2.transistor.off then dcdc2.transistor.Goff else 1)+(if dcdc2.transistor.off then 1 else dcdc2.transistor.Ron)",
     DYNX(W_,1924)+DYNX(W_,1934)-(DYNX(DYNhelp,2035)*DYNX(DYNhelp,2038)+
    DYNX(W_,1943)*DYNX(W_,1962)-DYNX(W_,1931)*DYNX(W_,1960)+DYNX(W_,2230)),
    "simplifiedFuelCell1.constantVoltage.V+simplifiedFuelCell1.constantVoltage1.V-((simplifiedFuelCell1.resistor1.R_actual+simplifiedFuelCell1.resistor.R_actual)*(dcdc2.transistor.Goff*dcdc2.transistor.Vknee)+simplifiedFuelCell1.resistor1.R_actual*inverter3.dc_n.i-simplifiedFuelCell1.resistor.R_actual*inverter3.dc_p.i+dcdc2.transistor.Vknee)",
     DYNX(W_,2234),"dcdc2.transistor.s");
  DYNX(W_,2227) = DYNX(W_,2234)*DYNX(DYNhelp,2036)+DYNX(DYNhelp,2038);
  DYNX(W_,1945) = DYNX(W_,1962)+DYNX(W_,2227);
  DYNX(W_,1939) =  -DYNX(W_,1943)*DYNX(W_,1945);
  DYNX(W_,1933) = DYNX(W_,1960)-DYNX(W_,2227);
  DYNX(W_,1927) =  -DYNX(W_,1931)*DYNX(W_,1933);
  DYNX(W_,2226) = DYNX(W_,2234)*DYNX(DYNhelp,2037)+DYNX(W_,2230);
   /* End of Equation Block */ 


  MixedModeStartBoolean
  UpdateVariableNamed(DYNX(W_,2233),"dcdc2.transistor.off", Less(DYNX(W_,2234),
    "dcdc2.transistor.s", 0,"0", 101) OR  NOT DYNX(W_,2224));
  MixedModeInit(1, DYNX(DYNhelp,2039))
  ThetaMixedCross(0,101)
  MixedModeEndBoolean
  UpdateReal(DYNX(W_,1945), 1)
  UpdateReal(DYNX(W_,1939), 2)
  UpdateReal(DYNX(W_,2227), 3)
  UpdateReal(DYNX(W_,1933), 4)
  UpdateReal(DYNX(W_,1927), 5)
  UpdateReal(DYNX(W_,2226), 6)
  UpdateReal(DYNX(W_,2234), 7)
EndMixedSystemOfEquations

DYNX(W_,1932) = DYNX(W_,1924)-DYNX(W_,1927);
DYNX(W_,1944) =  -(DYNX(W_,1939)+DYNX(W_,1934));
DYNX(W_,1930) =  -DYNX(W_,1927)*DYNX(W_,1933);
DYNX(W_,1937) = DYNX(W_,1933)+DYNX(W_,1945);
DYNX(W_,1942) =  -DYNX(W_,1939)*DYNX(W_,1945);
DYNX(W_,1963) = DYNX(W_,1959)-DYNX(W_,1961);
DYNX(W_,1964) = DYNX(W_,1963)*DYNX(W_,1960);
DYNX(W_,1972) = DYNX(W_,1966)*DYNX(W_,1967);
DYNX(W_,1973) = DYNX(W_,1968)*DYNX(W_,1969);
DYNX(W_,1974) = DYNX(W_,1970)*DYNX(W_,1971);
DYNX(W_,1975) = DYNX(W_,1972)+DYNX(W_,1973)+DYNX(W_,1974);
DYNX(W_,2011) = DYNX(W_,2006)*DYNX(W_,1984);
DYNX(W_,2021) = DYNX(W_,2016)*DYNX(W_,1985);
DYNX(W_,2031) = DYNX(W_,2026)*DYNX(W_,1986);
DYNX(W_,2178) = DYNX(W_,2173)*DYNX(W_,2154);
DYNX(W_,2188) = DYNX(W_,2183)*DYNX(W_,2155);
DYNX(W_,2198) = DYNX(W_,2193)*DYNX(W_,2156);
DYNX(W_,2125) = DYNX(W_,2120)*DYNX(W_,2098);
DYNX(W_,2135) = DYNX(W_,2130)*DYNX(W_,2099);
DYNX(W_,2145) = DYNX(W_,2140)*DYNX(W_,2100);
DYNX(W_,1978) = DYNX(W_,2011)+DYNX(W_,2021)+DYNX(W_,2031)+DYNX(W_,2178)+
  DYNX(W_,2188)+DYNX(W_,2198)+DYNX(W_,2125)+DYNX(W_,2135)+DYNX(W_,2145)+
  DYNX(W_,2178)+DYNX(W_,2188)+DYNX(W_,2198);
DYNX(W_,1981) = DYNX(W_,1959)-DYNX(W_,1966);
DYNX(W_,1982) = DYNX(W_,1959)-DYNX(W_,1968);
DYNX(W_,1983) = DYNX(W_,1959)-DYNX(W_,1970);
DYNX(W_,2037) = DYNX(W_,1966)-DYNX(W_,1959);
DYNX(W_,2038) = DYNX(W_,1968)-DYNX(W_,1959);
DYNX(W_,2039) = DYNX(W_,1970)-DYNX(W_,1959);
DYNX(W_,2064) = DYNX(W_,2059)*DYNX(W_,2040);
DYNX(W_,2074) = DYNX(W_,2069)*DYNX(W_,2041);
DYNX(W_,2084) = DYNX(W_,2079)*DYNX(W_,2042);
DYNX(W_,2095) = DYNX(W_,1966)-DYNX(W_,1961);
DYNX(W_,2096) = DYNX(W_,1968)-DYNX(W_,1961);
DYNX(W_,2097) = DYNX(W_,1970)-DYNX(W_,1961);
DYNX(W_,2151) = DYNX(W_,1961)-DYNX(W_,1966);
DYNX(W_,2152) = DYNX(W_,1961)-DYNX(W_,1968);
DYNX(W_,2153) = DYNX(W_,1961)-DYNX(W_,1970);
DYNX(W_,2208) = DYNX(W_,1932)-DYNX(W_,1944);
DYNX(W_,2209) =  -DYNX(W_,2208)*DYNX(W_,1933);

MixedSystemOfEquations(1, DYNX(DYNhelp,2040))
   /* Linear system of equations to solve. */
  DYNX(W_,2244) = RememberSimple_(DYNX(W_,2244), 74);
  SolveScalarLinearMixed(IF DYNX(W_,2243) THEN DYNX(W_,2239) ELSE 1,
    "(if dcdc2.diode.off then dcdc2.diode.Goff else 1)",  -(DYNX(W_,1960)+
    DYNX(W_,2239)*DYNX(W_,2240))," -(inverter3.dc_p.i+dcdc2.diode.Goff*dcdc2.diode.Vknee)",
     DYNX(W_,2244),"dcdc2.diode.s");
   /* End of Equation Block */ 


  MixedModeStartBoolean
  UpdateVariableNamed(DYNX(W_,2243),"dcdc2.diode.off", Less(DYNX(W_,2244),
    "dcdc2.diode.s", 0,"0", 102));
  MixedModeInit(1, DYNX(DYNhelp,2041))
  ThetaMixedCross(0,102)
  MixedModeEndBoolean
  UpdateReal(DYNX(W_,2244), 1)
EndMixedSystemOfEquations

DYNX(W_,2237) = DYNX(W_,2244)*(IF DYNX(W_,2243) THEN 1 ELSE DYNX(W_,2238))+
  DYNX(W_,2240);
DYNX(W_,2210) = DYNX(W_,1932)-DYNX(W_,2237);
DYNX(W_,2211) = DYNX(W_,2210)-DYNX(W_,1944);
DYNX(W_,2212) = DYNX(W_,2211)*DYNX(W_,1960);
DYNX(W_,2242) =  -DYNX(W_,2237)*DYNX(W_,1960);
DYNX(W_,2232) = DYNX(W_,2226)*DYNX(W_,2227);
DYNX(W_,2215) = DYNX(W_,2242)+DYNX(W_,2232);
DYNX(W_,2338) = DYNX(W_,1966)-DYNX(W_,2349);
DYNX(W_,2339) = DYNX(W_,1968)-DYNX(W_,2349);
DYNX(W_,2340) = DYNX(W_,1970)-DYNX(W_,2349);
DYNX(W_,2327) = (PushModelContext(1,"Modelica.Electrical.Machines.SpacePhasors.Functions.activePower({threePhaseMotor2.aimc.vs[1], threePhaseMotor2.aimc.vs[2], threePhaseMotor2.aimc.vs[3]}, { -inverter3.ac.pin[1].i,  -inverter3.ac.pin[2].i,  -inverter3.ac.pin[3].i})")
  Modelica_Electrical_Machines_SpacePhasors_Functions_activePower(
  RealTemporaryDense( &DYNX(W_,2338), 1, 3), RealScalarArray ( 3,  -
  DYNX(W_,1967),  -DYNX(W_,1969),  -DYNX(W_,1971))));
PopAllMarks();
DYNX(W_,2328) =  -DYNX(X_,23)*DYNX(W_,2573);
DYNX(W_,2330) = DYNX(W_,2289)*DYNX(F_,23)*DYNX(X_,23);
DYNX(W_,2379) =  -DYNX(W_,2376)*DYNX(W_,1967);
DYNX(W_,2387) =  -DYNX(W_,2384)*DYNX(W_,1969);
DYNX(W_,2395) =  -DYNX(W_,2392)*DYNX(W_,1971);
DYNX(W_,2332) = DYNX(W_,2379)+DYNX(W_,2387)+DYNX(W_,2395);
DYNX(W_,2337) = 1.5*DYNX(W_,2564)*(DYNX(X_,19)*DYNX(X_,19)+DYNX(X_,20)*
  DYNX(X_,20));
DYNX(W_,2331) = DYNX(W_,2332)+DYNX(W_,2337);
DYNX(W_,2351) = DYNX(W_,1966)-DYNX(W_,2356);
DYNX(W_,2352) = DYNX(W_,1968)-DYNX(W_,2357);
DYNX(W_,2353) = DYNX(W_,1970)-DYNX(W_,2358);
DYNX(W_,2474) = sqrtGuarded(0.3333333333333333*(sqr(DYNX(W_,1967))+sqr(
  DYNX(W_,1969))+sqr(DYNX(W_,1971))),"0.3333333333333333*(inverter3.ac.pin[1].i^2+inverter3.ac.pin[2].i^2+inverter3.ac.pin[3].i^2)");
DYNX(W_,2479) = DYNX(W_,2379)+DYNX(W_,2387)+DYNX(W_,2395);
DYNX(W_,2508) = DYNX(W_,2479)+DYNX(W_,2337);
DYNX(W_,2668) = DYNX(W_,2665)*DYNX(W_,37);
DYNX(W_,2673) = DYNX(W_,2670)*DYNX(W_,39);
DYNX(W_,325) =  NOT DYNX(W_,302);
DYNX(W_,1045) =  NOT DYNX(W_,1023);
DYNX(W_,2248) =  NOT DYNX(W_,2225);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareParameter("pi", "", 0, 3.141592653589793, 0.0,0.0,0.0,0,560)
DeclareVariable("m", "Number of phases [:#(type=Integer)]", 3, 0.0,0.0,0.0,0,517)
DeclareVariable("simplifiedFuelCell.constantVoltage.V", "Value of constant voltage [V]",\
 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("simplifiedFuelCell.constantVoltage.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 "simplifiedFuelCell.constantVoltage.V", 1, 5, 1, 0)
DeclareAlias2("simplifiedFuelCell.constantVoltage.i", "Current flowing from pin p to pin n [A]",\
 "simplifiedFuelCell.pin_p.i", 1, 5, 10, 0)
DeclareAlias2("simplifiedFuelCell.constantVoltage.p.v", "Potential at the pin [V]",\
 "simplifiedFuelCell.constantVoltage.V", 1, 5, 1, 4)
DeclareAlias2("simplifiedFuelCell.constantVoltage.p.i", "Current flowing into the pin [A]",\
 "simplifiedFuelCell.pin_p.i", 1, 5, 10, 132)
DeclareVariable("simplifiedFuelCell.constantVoltage.n.v", "Potential at the pin [V]",\
 0, 0.0,0.0,0.0,0,521)
DeclareAlias2("simplifiedFuelCell.constantVoltage.n.i", "Current flowing into the pin [A]",\
 "simplifiedFuelCell.pin_p.i", -1, 5, 10, 132)
DeclareVariable("simplifiedFuelCell.resistor.R", "Resistance at temperature T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareParameter("simplifiedFuelCell.resistor.T_ref", "Reference temperature [K|degC]",\
 1, 300.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("simplifiedFuelCell.resistor.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 2, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("simplifiedFuelCell.resistor.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("simplifiedFuelCell.resistor.i", "Current flowing from pin p to pin n [A]",\
 "simplifiedFuelCell.pin_p.i", -1, 5, 10, 0)
DeclareAlias2("simplifiedFuelCell.resistor.p.v", "Potential at the pin [V]", \
"simplifiedFuelCell.constantVoltage.V", 1, 5, 1, 4)
DeclareAlias2("simplifiedFuelCell.resistor.p.i", "Current flowing into the pin [A]",\
 "simplifiedFuelCell.pin_p.i", -1, 5, 10, 132)
DeclareAlias2("simplifiedFuelCell.resistor.n.v", "Potential at the pin [V]", \
"simplifiedFuelCell.pin_p.v", 1, 5, 9, 4)
DeclareAlias2("simplifiedFuelCell.resistor.n.i", "Current flowing into the pin [A]",\
 "simplifiedFuelCell.pin_p.i", 1, 5, 10, 132)
DeclareVariable("simplifiedFuelCell.resistor.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("simplifiedFuelCell.resistor.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("simplifiedFuelCell.resistor.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("simplifiedFuelCell.resistor.T_heatPort", "Temperature of heatPort [K|degC]",\
 "simplifiedFuelCell.resistor.T", 1, 5, 6, 0)
DeclareVariable("simplifiedFuelCell.resistor.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("simplifiedFuelCell.pin_p.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,520)
DeclareVariable("simplifiedFuelCell.pin_p.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareParameter("simplifiedFuelCell.R", "Impedance [Ohm]", 3, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("simplifiedFuelCell.L", "Impedance [H]", 4, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("simplifiedFuelCell.V", "Fuel cell voltage [V]", 5, 1000, \
0.0,0.0,0.0,0,560)
DeclareVariable("simplifiedFuelCell.constantVoltage1.V", "Value of constant voltage [V]",\
 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("simplifiedFuelCell.constantVoltage1.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 "simplifiedFuelCell.constantVoltage1.V", 1, 5, 11, 0)
DeclareAlias2("simplifiedFuelCell.constantVoltage1.i", "Current flowing from pin p to pin n [A]",\
 "simplifiedFuelCell.pin_p1.i", -1, 5, 22, 0)
DeclareVariable("simplifiedFuelCell.constantVoltage1.p.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("simplifiedFuelCell.constantVoltage1.p.i", "Current flowing into the pin [A]",\
 "simplifiedFuelCell.pin_p1.i", -1, 5, 22, 132)
DeclareAlias2("simplifiedFuelCell.constantVoltage1.n.v", "Potential at the pin [V]",\
 "simplifiedFuelCell.constantVoltage1.V", -1, 5, 11, 4)
DeclareAlias2("simplifiedFuelCell.constantVoltage1.n.i", "Current flowing into the pin [A]",\
 "simplifiedFuelCell.pin_p1.i", 1, 5, 22, 132)
DeclareVariable("simplifiedFuelCell.ground.p.v", "Potential at the pin [V]", 0.0,\
 0.0,0.0,0.0,0,521)
DeclareVariable("simplifiedFuelCell.ground.p.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("simplifiedFuelCell.resistor1.R", "Resistance at temperature T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareParameter("simplifiedFuelCell.resistor1.T_ref", "Reference temperature [K|degC]",\
 6, 300.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("simplifiedFuelCell.resistor1.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 7, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("simplifiedFuelCell.resistor1.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("simplifiedFuelCell.resistor1.i", "Current flowing from pin p to pin n [A]",\
 "simplifiedFuelCell.pin_p1.i", -1, 5, 22, 0)
DeclareAlias2("simplifiedFuelCell.resistor1.p.v", "Potential at the pin [V]", \
"simplifiedFuelCell.constantVoltage1.V", -1, 5, 11, 4)
DeclareAlias2("simplifiedFuelCell.resistor1.p.i", "Current flowing into the pin [A]",\
 "simplifiedFuelCell.pin_p1.i", -1, 5, 22, 132)
DeclareAlias2("simplifiedFuelCell.resistor1.n.v", "Potential at the pin [V]", \
"simplifiedFuelCell.pin_p1.v", 1, 5, 21, 4)
DeclareAlias2("simplifiedFuelCell.resistor1.n.i", "Current flowing into the pin [A]",\
 "simplifiedFuelCell.pin_p1.i", 1, 5, 22, 132)
DeclareVariable("simplifiedFuelCell.resistor1.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("simplifiedFuelCell.resistor1.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("simplifiedFuelCell.resistor1.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("simplifiedFuelCell.resistor1.T_heatPort", "Temperature of heatPort [K|degC]",\
 "simplifiedFuelCell.resistor1.T", 1, 5, 18, 0)
DeclareVariable("simplifiedFuelCell.resistor1.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("simplifiedFuelCell.pin_p1.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,520)
DeclareVariable("simplifiedFuelCell.pin_p1.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("inverter2.useConstantEnable", "true = disabled boolean input, use constantEnable [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("inverter2.constantEnable", "Constant enabling of firing signals [:#(type=Boolean)]",\
 8, true, 0.0,0.0,0.0,0,562)
DeclareVariable("inverter2.m", "Number of phases [:#(type=Integer)]", 3, 3.0,\
1E+100,0.0,0,517)
DeclareAlias2("inverter2.andCondition_p[1].u1", "Connector of first Boolean input signal [:#(type=Boolean)]",\
 "inverter2.fire_p[1]", 1, 5, 25, 65)
DeclareAlias2("inverter2.andCondition_p[1].u2", "Connector of second Boolean input signal [:#(type=Boolean)]",\
 "inverter2.enableLogic.enableConstantSource.k", 1, 5, 31, 65)
DeclareAlias2("inverter2.andCondition_p[1].y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter2.transistor_p.fire[1]", 1, 5, 80, 65)
DeclareAlias2("inverter2.andCondition_p[2].u1", "Connector of first Boolean input signal [:#(type=Boolean)]",\
 "inverter2.fire_p[2]", 1, 5, 26, 65)
DeclareAlias2("inverter2.andCondition_p[2].u2", "Connector of second Boolean input signal [:#(type=Boolean)]",\
 "inverter2.enableLogic.enableConstantSource.k", 1, 5, 31, 65)
DeclareAlias2("inverter2.andCondition_p[2].y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter2.transistor_p.fire[2]", 1, 5, 81, 65)
DeclareAlias2("inverter2.andCondition_p[3].u1", "Connector of first Boolean input signal [:#(type=Boolean)]",\
 "inverter2.fire_p[3]", 1, 5, 27, 65)
DeclareAlias2("inverter2.andCondition_p[3].u2", "Connector of second Boolean input signal [:#(type=Boolean)]",\
 "inverter2.enableLogic.enableConstantSource.k", 1, 5, 31, 65)
DeclareAlias2("inverter2.andCondition_p[3].y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter2.transistor_p.fire[3]", 1, 5, 82, 65)
DeclareVariable("inverter2.fire_p[1]", "Firing signals of positive potential transistors [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,642)
DeclareVariable("inverter2.fire_p[2]", "Firing signals of positive potential transistors [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,642)
DeclareVariable("inverter2.fire_p[3]", "Firing signals of positive potential transistors [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,642)
DeclareVariable("inverter2.enableLogic.useConstantEnable", "true = disabled boolean input, use constantEnable [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("inverter2.enableLogic.constantEnable", "Constant enabling of firing signals [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("inverter2.enableLogic.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("inverter2.enableLogic.enableConstantSource.k", "Constant output value [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("inverter2.enableLogic.enableConstantSource.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter2.enableLogic.enableConstantSource.k", 1, 5, 31, 65)
DeclareVariable("inverter2.enableLogic.booleanReplicator.nout", "Number of outputs [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareAlias2("inverter2.enableLogic.booleanReplicator.u", "Connector of Boolean input signal [:#(type=Boolean)]",\
 "inverter2.enableLogic.enableConstantSource.k", 1, 5, 31, 65)
DeclareAlias2("inverter2.enableLogic.booleanReplicator.y[1]", "Connector of Boolean output signals [:#(type=Boolean)]",\
 "inverter2.enableLogic.enableConstantSource.k", 1, 5, 31, 65)
DeclareAlias2("inverter2.enableLogic.booleanReplicator.y[2]", "Connector of Boolean output signals [:#(type=Boolean)]",\
 "inverter2.enableLogic.enableConstantSource.k", 1, 5, 31, 65)
DeclareAlias2("inverter2.enableLogic.booleanReplicator.y[3]", "Connector of Boolean output signals [:#(type=Boolean)]",\
 "inverter2.enableLogic.enableConstantSource.k", 1, 5, 31, 65)
DeclareAlias2("inverter2.enableLogic.internalEnable[1]", "m replicated enable signals [:#(type=Boolean)]",\
 "inverter2.enableLogic.enableConstantSource.k", 1, 5, 31, 65)
DeclareAlias2("inverter2.enableLogic.internalEnable[2]", "m replicated enable signals [:#(type=Boolean)]",\
 "inverter2.enableLogic.enableConstantSource.k", 1, 5, 31, 65)
DeclareAlias2("inverter2.enableLogic.internalEnable[3]", "m replicated enable signals [:#(type=Boolean)]",\
 "inverter2.enableLogic.enableConstantSource.k", 1, 5, 31, 65)
DeclareAlias2("inverter2.andCondition_n[1].u1", "Connector of first Boolean input signal [:#(type=Boolean)]",\
 "inverter2.fire_n[1]", 1, 5, 33, 65)
DeclareAlias2("inverter2.andCondition_n[1].u2", "Connector of second Boolean input signal [:#(type=Boolean)]",\
 "inverter2.enableLogic.enableConstantSource.k", 1, 5, 31, 65)
DeclareAlias2("inverter2.andCondition_n[1].y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter2.transistor_n.fire[1]", 1, 5, 194, 65)
DeclareAlias2("inverter2.andCondition_n[2].u1", "Connector of first Boolean input signal [:#(type=Boolean)]",\
 "inverter2.fire_n[2]", 1, 5, 34, 65)
DeclareAlias2("inverter2.andCondition_n[2].u2", "Connector of second Boolean input signal [:#(type=Boolean)]",\
 "inverter2.enableLogic.enableConstantSource.k", 1, 5, 31, 65)
DeclareAlias2("inverter2.andCondition_n[2].y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter2.transistor_n.fire[2]", 1, 5, 195, 65)
DeclareAlias2("inverter2.andCondition_n[3].u1", "Connector of first Boolean input signal [:#(type=Boolean)]",\
 "inverter2.fire_n[3]", 1, 5, 35, 65)
DeclareAlias2("inverter2.andCondition_n[3].u2", "Connector of second Boolean input signal [:#(type=Boolean)]",\
 "inverter2.enableLogic.enableConstantSource.k", 1, 5, 31, 65)
DeclareAlias2("inverter2.andCondition_n[3].y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter2.transistor_n.fire[3]", 1, 5, 196, 65)
DeclareVariable("inverter2.fire_n[1]", "Firing signals of negative potential transistors [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,642)
DeclareVariable("inverter2.fire_n[2]", "Firing signals of negative potential transistors [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,642)
DeclareVariable("inverter2.fire_n[3]", "Firing signals of negative potential transistors [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,642)
DeclareParameter("inverter2.RonTransistor", "Transistor closed resistance [Ohm]",\
 9, 1E-05, 0.0,0.0,0.0,0,560)
DeclareParameter("inverter2.GoffTransistor", "Transistor opened conductance [S]",\
 10, 1E-05, 0.0,0.0,0.0,0,560)
DeclareParameter("inverter2.VkneeTransistor", "Transistor threshold voltage [V]",\
 11, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("inverter2.RonDiode", "Diode closed resistance [Ohm]", 12, \
1E-05, 0.0,0.0,0.0,0,560)
DeclareParameter("inverter2.GoffDiode", "Diode opened conductance [S]", 13, \
1E-05, 0.0,0.0,0.0,0,560)
DeclareParameter("inverter2.VkneeDiode", "Diode threshold voltage [V]", 14, 0, \
0.0,0.0,0.0,0,560)
DeclareVariable("inverter2.dc_p.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,\
0,520)
DeclareVariable("inverter2.dc_p.i", "Current flowing into the pin [A]", 0.0, \
0.0,0.0,0.0,0,776)
DeclareVariable("inverter2.dc_n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,\
0,520)
DeclareVariable("inverter2.dc_n.i", "Current flowing into the pin [A]", 0.0, \
0.0,0.0,0.0,0,776)
DeclareVariable("inverter2.vDC", "DC voltage [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter2.iDC", "DC current [A]", "inverter2.dc_p.i", 1, 5, 37, 0)
DeclareVariable("inverter2.powerDC", "DC power [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter2.ac.m", "Number of phases [:#(type=Integer)]", 3, 1.0,\
1E+100,0.0,0,525)
DeclareVariable("inverter2.ac.pin[1].v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,520)
DeclareVariable("inverter2.ac.pin[1].i", "Current flowing into the pin [A]", 0.0,\
 0.0,0.0,0.0,0,776)
DeclareVariable("inverter2.ac.pin[2].v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,520)
DeclareVariable("inverter2.ac.pin[2].i", "Current flowing into the pin [A]", 0.0,\
 0.0,0.0,0.0,0,776)
DeclareVariable("inverter2.ac.pin[3].v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,520)
DeclareVariable("inverter2.ac.pin[3].i", "Current flowing into the pin [A]", 0.0,\
 0.0,0.0,0.0,0,776)
DeclareAlias2("inverter2.vAC[1]", "AC potential [V]", "inverter2.ac.pin[1].v", 1,\
 5, 43, 0)
DeclareAlias2("inverter2.vAC[2]", "AC potential [V]", "inverter2.ac.pin[2].v", 1,\
 5, 45, 0)
DeclareAlias2("inverter2.vAC[3]", "AC potential [V]", "inverter2.ac.pin[3].v", 1,\
 5, 47, 0)
DeclareAlias2("inverter2.iAC[1]", "AC current [A]", "inverter2.ac.pin[1].i", 1, 5,\
 44, 0)
DeclareAlias2("inverter2.iAC[2]", "AC current [A]", "inverter2.ac.pin[2].i", 1, 5,\
 46, 0)
DeclareAlias2("inverter2.iAC[3]", "AC current [A]", "inverter2.ac.pin[3].i", 1, 5,\
 48, 0)
DeclareVariable("inverter2.powerAC[1]", "AC power [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter2.powerAC[2]", "AC power [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter2.powerAC[3]", "AC power [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter2.powerTotalAC", "AC total power [W]", 0.0, 0.0,0.0,0.0,\
0,512)
DeclareVariable("inverter2.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("inverter2.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter2.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter2.T_heatPort", "Temperature of heatPort [K|degC]", \
293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter2.transistor_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("inverter2.transistor_p.v[1]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter2.transistor_p.v[2]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter2.transistor_p.v[3]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter2.transistor_p.i[1]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter2.transistor_p.i[2]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter2.transistor_p.i[3]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter2.transistor_p.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("inverter2.transistor_p.plug_p.pin[1].v", "Potential at the pin [V]",\
 "inverter2.dc_p.v", 1, 5, 36, 4)
DeclareAlias2("inverter2.transistor_p.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 "inverter2.transistor_p.i[1]", 1, 5, 61, 132)
DeclareAlias2("inverter2.transistor_p.plug_p.pin[2].v", "Potential at the pin [V]",\
 "inverter2.dc_p.v", 1, 5, 36, 4)
DeclareAlias2("inverter2.transistor_p.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 "inverter2.transistor_p.i[2]", 1, 5, 62, 132)
DeclareAlias2("inverter2.transistor_p.plug_p.pin[3].v", "Potential at the pin [V]",\
 "inverter2.dc_p.v", 1, 5, 36, 4)
DeclareAlias2("inverter2.transistor_p.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 "inverter2.transistor_p.i[3]", 1, 5, 63, 132)
DeclareVariable("inverter2.transistor_p.plug_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("inverter2.transistor_p.plug_n.pin[1].v", "Potential at the pin [V]",\
 "inverter2.ac.pin[1].v", 1, 5, 43, 4)
DeclareAlias2("inverter2.transistor_p.plug_n.pin[1].i", "Current flowing into the pin [A]",\
 "inverter2.transistor_p.i[1]", -1, 5, 61, 132)
DeclareAlias2("inverter2.transistor_p.plug_n.pin[2].v", "Potential at the pin [V]",\
 "inverter2.ac.pin[2].v", 1, 5, 45, 4)
DeclareAlias2("inverter2.transistor_p.plug_n.pin[2].i", "Current flowing into the pin [A]",\
 "inverter2.transistor_p.i[2]", -1, 5, 62, 132)
DeclareAlias2("inverter2.transistor_p.plug_n.pin[3].v", "Potential at the pin [V]",\
 "inverter2.ac.pin[3].v", 1, 5, 47, 4)
DeclareAlias2("inverter2.transistor_p.plug_n.pin[3].i", "Current flowing into the pin [A]",\
 "inverter2.transistor_p.i[3]", -1, 5, 63, 132)
DeclareVariable("inverter2.transistor_p.Ron[1]", "Closed thyristor resistance [Ohm]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_p.Ron[2]", "Closed thyristor resistance [Ohm]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_p.Ron[3]", "Closed thyristor resistance [Ohm]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_p.Goff[1]", "Opened thyristor conductance [S]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_p.Goff[2]", "Opened thyristor conductance [S]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_p.Goff[3]", "Opened thyristor conductance [S]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_p.Vknee[1]", "Threshold voltage [V]", 0, \
0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_p.Vknee[2]", "Threshold voltage [V]", 0, \
0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_p.Vknee[3]", "Threshold voltage [V]", 0, \
0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_p.mh", "Number of heatPorts=number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("inverter2.transistor_p.useHeatPort", "=true, if all heat ports are enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("inverter2.transistor_p.T[1]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter2.transistor_p.T[2]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter2.transistor_p.T[3]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter2.transistor_p.fire[1]", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,642)
DeclareVariable("inverter2.transistor_p.fire[2]", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,642)
DeclareVariable("inverter2.transistor_p.fire[3]", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,642)
DeclareVariable("inverter2.transistor_p.idealGTOThyristor[1].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter2.transistor_p.idealGTOThyristor[1].i", "Current flowing from pin p to pin n [A]",\
 "inverter2.transistor_p.i[1]", 1, 5, 61, 0)
DeclareAlias2("inverter2.transistor_p.idealGTOThyristor[1].p.v", \
"Potential at the pin [V]", "inverter2.dc_p.v", 1, 5, 36, 4)
DeclareAlias2("inverter2.transistor_p.idealGTOThyristor[1].p.i", \
"Current flowing into the pin [A]", "inverter2.transistor_p.i[1]", 1, 5, 61, 132)
DeclareAlias2("inverter2.transistor_p.idealGTOThyristor[1].n.v", \
"Potential at the pin [V]", "inverter2.ac.pin[1].v", 1, 5, 43, 4)
DeclareAlias2("inverter2.transistor_p.idealGTOThyristor[1].n.i", \
"Current flowing into the pin [A]", "inverter2.transistor_p.i[1]", -1, 5, 61, 132)
DeclareVariable("inverter2.transistor_p.idealGTOThyristor[1].Ron", \
"Forward state-on differential resistance (closed resistance) [Ohm]", 0.0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_p.idealGTOThyristor[1].Goff", \
"Backward state-off conductance (opened conductance) [S]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_p.idealGTOThyristor[1].Vknee", \
"Forward threshold voltage [V]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_p.idealGTOThyristor[1].useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter2.transistor_p.idealGTOThyristor[1].T", \
"Fixed device temperature if useHeatPort = false [K|degC]", 15, 293.15, 0.0,\
1E+100,300.0,0,560)
DeclareVariable("inverter2.transistor_p.idealGTOThyristor[1].LossPower", \
"Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter2.transistor_p.idealGTOThyristor[1].T_heatPort", \
"Temperature of heatPort [K|degC]", "inverter2.transistor_p.idealGTOThyristor[1].T", 1,\
 7, 15, 0)
DeclareVariable("inverter2.transistor_p.idealGTOThyristor[1].off", \
"Switching state [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter2.transistor_p.idealGTOThyristor[1].s", \
"Auxiliary variable for actual position on the ideal diode characteristic [1]", 0,\
 0.0,0.0,0.0,0,2560)
DeclareVariable("inverter2.transistor_p.idealGTOThyristor[1].unitVoltage", "[V]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("inverter2.transistor_p.idealGTOThyristor[1].unitCurrent", "[A]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("inverter2.transistor_p.idealGTOThyristor[1].fire", \
"[:#(type=Boolean)]", "inverter2.transistor_p.fire[1]", 1, 5, 80, 65)
DeclareVariable("inverter2.transistor_p.idealGTOThyristor[2].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter2.transistor_p.idealGTOThyristor[2].i", "Current flowing from pin p to pin n [A]",\
 "inverter2.transistor_p.i[2]", 1, 5, 62, 0)
DeclareAlias2("inverter2.transistor_p.idealGTOThyristor[2].p.v", \
"Potential at the pin [V]", "inverter2.dc_p.v", 1, 5, 36, 4)
DeclareAlias2("inverter2.transistor_p.idealGTOThyristor[2].p.i", \
"Current flowing into the pin [A]", "inverter2.transistor_p.i[2]", 1, 5, 62, 132)
DeclareAlias2("inverter2.transistor_p.idealGTOThyristor[2].n.v", \
"Potential at the pin [V]", "inverter2.ac.pin[2].v", 1, 5, 45, 4)
DeclareAlias2("inverter2.transistor_p.idealGTOThyristor[2].n.i", \
"Current flowing into the pin [A]", "inverter2.transistor_p.i[2]", -1, 5, 62, 132)
DeclareVariable("inverter2.transistor_p.idealGTOThyristor[2].Ron", \
"Forward state-on differential resistance (closed resistance) [Ohm]", 0.0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_p.idealGTOThyristor[2].Goff", \
"Backward state-off conductance (opened conductance) [S]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_p.idealGTOThyristor[2].Vknee", \
"Forward threshold voltage [V]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_p.idealGTOThyristor[2].useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter2.transistor_p.idealGTOThyristor[2].T", \
"Fixed device temperature if useHeatPort = false [K|degC]", 16, 293.15, 0.0,\
1E+100,300.0,0,560)
DeclareVariable("inverter2.transistor_p.idealGTOThyristor[2].LossPower", \
"Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter2.transistor_p.idealGTOThyristor[2].T_heatPort", \
"Temperature of heatPort [K|degC]", "inverter2.transistor_p.idealGTOThyristor[2].T", 1,\
 7, 16, 0)
DeclareVariable("inverter2.transistor_p.idealGTOThyristor[2].off", \
"Switching state [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter2.transistor_p.idealGTOThyristor[2].s", \
"Auxiliary variable for actual position on the ideal diode characteristic [1]", 0,\
 0.0,0.0,0.0,0,2560)
DeclareVariable("inverter2.transistor_p.idealGTOThyristor[2].unitVoltage", "[V]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("inverter2.transistor_p.idealGTOThyristor[2].unitCurrent", "[A]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("inverter2.transistor_p.idealGTOThyristor[2].fire", \
"[:#(type=Boolean)]", "inverter2.transistor_p.fire[2]", 1, 5, 81, 65)
DeclareVariable("inverter2.transistor_p.idealGTOThyristor[3].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter2.transistor_p.idealGTOThyristor[3].i", "Current flowing from pin p to pin n [A]",\
 "inverter2.transistor_p.i[3]", 1, 5, 63, 0)
DeclareAlias2("inverter2.transistor_p.idealGTOThyristor[3].p.v", \
"Potential at the pin [V]", "inverter2.dc_p.v", 1, 5, 36, 4)
DeclareAlias2("inverter2.transistor_p.idealGTOThyristor[3].p.i", \
"Current flowing into the pin [A]", "inverter2.transistor_p.i[3]", 1, 5, 63, 132)
DeclareAlias2("inverter2.transistor_p.idealGTOThyristor[3].n.v", \
"Potential at the pin [V]", "inverter2.ac.pin[3].v", 1, 5, 47, 4)
DeclareAlias2("inverter2.transistor_p.idealGTOThyristor[3].n.i", \
"Current flowing into the pin [A]", "inverter2.transistor_p.i[3]", -1, 5, 63, 132)
DeclareVariable("inverter2.transistor_p.idealGTOThyristor[3].Ron", \
"Forward state-on differential resistance (closed resistance) [Ohm]", 0.0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_p.idealGTOThyristor[3].Goff", \
"Backward state-off conductance (opened conductance) [S]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_p.idealGTOThyristor[3].Vknee", \
"Forward threshold voltage [V]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_p.idealGTOThyristor[3].useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter2.transistor_p.idealGTOThyristor[3].T", \
"Fixed device temperature if useHeatPort = false [K|degC]", 17, 293.15, 0.0,\
1E+100,300.0,0,560)
DeclareVariable("inverter2.transistor_p.idealGTOThyristor[3].LossPower", \
"Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter2.transistor_p.idealGTOThyristor[3].T_heatPort", \
"Temperature of heatPort [K|degC]", "inverter2.transistor_p.idealGTOThyristor[3].T", 1,\
 7, 17, 0)
DeclareVariable("inverter2.transistor_p.idealGTOThyristor[3].off", \
"Switching state [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter2.transistor_p.idealGTOThyristor[3].s", \
"Auxiliary variable for actual position on the ideal diode characteristic [1]", 0,\
 0.0,0.0,0.0,0,2560)
DeclareVariable("inverter2.transistor_p.idealGTOThyristor[3].unitVoltage", "[V]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("inverter2.transistor_p.idealGTOThyristor[3].unitCurrent", "[A]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("inverter2.transistor_p.idealGTOThyristor[3].fire", \
"[:#(type=Boolean)]", "inverter2.transistor_p.fire[3]", 1, 5, 82, 65)
DeclareVariable("inverter2.diode_p.m", "Number of phases [:#(type=Integer)]", 3,\
 1.0,1E+100,0.0,0,517)
DeclareVariable("inverter2.diode_p.v[1]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter2.diode_p.v[2]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter2.diode_p.v[3]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter2.diode_p.i[1]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter2.diode_p.i[2]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter2.diode_p.i[3]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter2.diode_p.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("inverter2.diode_p.plug_p.pin[1].v", "Potential at the pin [V]", \
"inverter2.ac.pin[1].v", 1, 5, 43, 4)
DeclareAlias2("inverter2.diode_p.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 "inverter2.diode_p.i[1]", 1, 5, 117, 132)
DeclareAlias2("inverter2.diode_p.plug_p.pin[2].v", "Potential at the pin [V]", \
"inverter2.ac.pin[2].v", 1, 5, 45, 4)
DeclareAlias2("inverter2.diode_p.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 "inverter2.diode_p.i[2]", 1, 5, 118, 132)
DeclareAlias2("inverter2.diode_p.plug_p.pin[3].v", "Potential at the pin [V]", \
"inverter2.ac.pin[3].v", 1, 5, 47, 4)
DeclareAlias2("inverter2.diode_p.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 "inverter2.diode_p.i[3]", 1, 5, 119, 132)
DeclareVariable("inverter2.diode_p.plug_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("inverter2.diode_p.plug_n.pin[1].v", "Potential at the pin [V]", \
"inverter2.dc_p.v", 1, 5, 36, 4)
DeclareAlias2("inverter2.diode_p.plug_n.pin[1].i", "Current flowing into the pin [A]",\
 "inverter2.diode_p.i[1]", -1, 5, 117, 132)
DeclareAlias2("inverter2.diode_p.plug_n.pin[2].v", "Potential at the pin [V]", \
"inverter2.dc_p.v", 1, 5, 36, 4)
DeclareAlias2("inverter2.diode_p.plug_n.pin[2].i", "Current flowing into the pin [A]",\
 "inverter2.diode_p.i[2]", -1, 5, 118, 132)
DeclareAlias2("inverter2.diode_p.plug_n.pin[3].v", "Potential at the pin [V]", \
"inverter2.dc_p.v", 1, 5, 36, 4)
DeclareAlias2("inverter2.diode_p.plug_n.pin[3].i", "Current flowing into the pin [A]",\
 "inverter2.diode_p.i[3]", -1, 5, 119, 132)
DeclareVariable("inverter2.diode_p.Ron[1]", "Closed diode resistance [Ohm]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_p.Ron[2]", "Closed diode resistance [Ohm]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_p.Ron[3]", "Closed diode resistance [Ohm]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_p.Goff[1]", "Opened diode conductance [S]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_p.Goff[2]", "Opened diode conductance [S]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_p.Goff[3]", "Opened diode conductance [S]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_p.Vknee[1]", "Threshold voltage [V]", 0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_p.Vknee[2]", "Threshold voltage [V]", 0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_p.Vknee[3]", "Threshold voltage [V]", 0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_p.mh", "Number of heatPorts=number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("inverter2.diode_p.useHeatPort", "=true, if all heat ports are enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("inverter2.diode_p.T[1]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter2.diode_p.T[2]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter2.diode_p.T[3]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter2.diode_p.idealDiode[1].v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter2.diode_p.idealDiode[1].i", "Current flowing from pin p to pin n [A]",\
 "inverter2.diode_p.i[1]", 1, 5, 117, 0)
DeclareAlias2("inverter2.diode_p.idealDiode[1].p.v", "Potential at the pin [V]",\
 "inverter2.ac.pin[1].v", 1, 5, 43, 4)
DeclareAlias2("inverter2.diode_p.idealDiode[1].p.i", "Current flowing into the pin [A]",\
 "inverter2.diode_p.i[1]", 1, 5, 117, 132)
DeclareAlias2("inverter2.diode_p.idealDiode[1].n.v", "Potential at the pin [V]",\
 "inverter2.dc_p.v", 1, 5, 36, 4)
DeclareAlias2("inverter2.diode_p.idealDiode[1].n.i", "Current flowing into the pin [A]",\
 "inverter2.diode_p.i[1]", -1, 5, 117, 132)
DeclareVariable("inverter2.diode_p.idealDiode[1].Ron", "Forward state-on differential resistance (closed resistance) [Ohm]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_p.idealDiode[1].Goff", "Backward state-off conductance (opened conductance) [S]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_p.idealDiode[1].Vknee", "Forward threshold voltage [V]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_p.idealDiode[1].useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter2.diode_p.idealDiode[1].T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 18, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("inverter2.diode_p.idealDiode[1].LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter2.diode_p.idealDiode[1].T_heatPort", "Temperature of heatPort [K|degC]",\
 "inverter2.diode_p.idealDiode[1].T", 1, 7, 18, 0)
DeclareVariable("inverter2.diode_p.idealDiode[1].off", "Switching state [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter2.diode_p.idealDiode[1].s", "Auxiliary variable for actual position on the ideal diode characteristic [1]",\
 0, 0.0,0.0,0.0,0,2560)
DeclareVariable("inverter2.diode_p.idealDiode[1].unitVoltage", "[V]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter2.diode_p.idealDiode[1].unitCurrent", "[A]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter2.diode_p.idealDiode[2].v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter2.diode_p.idealDiode[2].i", "Current flowing from pin p to pin n [A]",\
 "inverter2.diode_p.i[2]", 1, 5, 118, 0)
DeclareAlias2("inverter2.diode_p.idealDiode[2].p.v", "Potential at the pin [V]",\
 "inverter2.ac.pin[2].v", 1, 5, 45, 4)
DeclareAlias2("inverter2.diode_p.idealDiode[2].p.i", "Current flowing into the pin [A]",\
 "inverter2.diode_p.i[2]", 1, 5, 118, 132)
DeclareAlias2("inverter2.diode_p.idealDiode[2].n.v", "Potential at the pin [V]",\
 "inverter2.dc_p.v", 1, 5, 36, 4)
DeclareAlias2("inverter2.diode_p.idealDiode[2].n.i", "Current flowing into the pin [A]",\
 "inverter2.diode_p.i[2]", -1, 5, 118, 132)
DeclareVariable("inverter2.diode_p.idealDiode[2].Ron", "Forward state-on differential resistance (closed resistance) [Ohm]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_p.idealDiode[2].Goff", "Backward state-off conductance (opened conductance) [S]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_p.idealDiode[2].Vknee", "Forward threshold voltage [V]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_p.idealDiode[2].useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter2.diode_p.idealDiode[2].T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 19, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("inverter2.diode_p.idealDiode[2].LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter2.diode_p.idealDiode[2].T_heatPort", "Temperature of heatPort [K|degC]",\
 "inverter2.diode_p.idealDiode[2].T", 1, 7, 19, 0)
DeclareVariable("inverter2.diode_p.idealDiode[2].off", "Switching state [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter2.diode_p.idealDiode[2].s", "Auxiliary variable for actual position on the ideal diode characteristic [1]",\
 0, 0.0,0.0,0.0,0,2560)
DeclareVariable("inverter2.diode_p.idealDiode[2].unitVoltage", "[V]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter2.diode_p.idealDiode[2].unitCurrent", "[A]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter2.diode_p.idealDiode[3].v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter2.diode_p.idealDiode[3].i", "Current flowing from pin p to pin n [A]",\
 "inverter2.diode_p.i[3]", 1, 5, 119, 0)
DeclareAlias2("inverter2.diode_p.idealDiode[3].p.v", "Potential at the pin [V]",\
 "inverter2.ac.pin[3].v", 1, 5, 47, 4)
DeclareAlias2("inverter2.diode_p.idealDiode[3].p.i", "Current flowing into the pin [A]",\
 "inverter2.diode_p.i[3]", 1, 5, 119, 132)
DeclareAlias2("inverter2.diode_p.idealDiode[3].n.v", "Potential at the pin [V]",\
 "inverter2.dc_p.v", 1, 5, 36, 4)
DeclareAlias2("inverter2.diode_p.idealDiode[3].n.i", "Current flowing into the pin [A]",\
 "inverter2.diode_p.i[3]", -1, 5, 119, 132)
DeclareVariable("inverter2.diode_p.idealDiode[3].Ron", "Forward state-on differential resistance (closed resistance) [Ohm]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_p.idealDiode[3].Goff", "Backward state-off conductance (opened conductance) [S]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_p.idealDiode[3].Vknee", "Forward threshold voltage [V]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_p.idealDiode[3].useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter2.diode_p.idealDiode[3].T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 20, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("inverter2.diode_p.idealDiode[3].LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter2.diode_p.idealDiode[3].T_heatPort", "Temperature of heatPort [K|degC]",\
 "inverter2.diode_p.idealDiode[3].T", 1, 7, 20, 0)
DeclareVariable("inverter2.diode_p.idealDiode[3].off", "Switching state [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter2.diode_p.idealDiode[3].s", "Auxiliary variable for actual position on the ideal diode characteristic [1]",\
 0, 0.0,0.0,0.0,0,2560)
DeclareVariable("inverter2.diode_p.idealDiode[3].unitVoltage", "[V]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter2.diode_p.idealDiode[3].unitCurrent", "[A]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter2.star_p.m", "Number of phases [:#(type=Integer)]", 3, \
1.0,1E+100,0.0,0,517)
DeclareVariable("inverter2.star_p.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("inverter2.star_p.plug_p.pin[1].v", "Potential at the pin [V]", \
"inverter2.dc_p.v", 1, 5, 36, 4)
DeclareVariable("inverter2.star_p.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("inverter2.star_p.plug_p.pin[2].v", "Potential at the pin [V]", \
"inverter2.dc_p.v", 1, 5, 36, 4)
DeclareVariable("inverter2.star_p.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("inverter2.star_p.plug_p.pin[3].v", "Potential at the pin [V]", \
"inverter2.dc_p.v", 1, 5, 36, 4)
DeclareVariable("inverter2.star_p.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("inverter2.star_p.pin_n.v", "Potential at the pin [V]", \
"inverter2.dc_p.v", 1, 5, 36, 4)
DeclareAlias2("inverter2.star_p.pin_n.i", "Current flowing into the pin [A]", \
"inverter2.dc_p.i", 1, 5, 37, 132)
DeclareVariable("inverter2.transistor_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("inverter2.transistor_n.v[1]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter2.transistor_n.v[2]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter2.transistor_n.v[3]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter2.transistor_n.i[1]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter2.transistor_n.i[2]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter2.transistor_n.i[3]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter2.transistor_n.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("inverter2.transistor_n.plug_p.pin[1].v", "Potential at the pin [V]",\
 "inverter2.ac.pin[1].v", 1, 5, 43, 4)
DeclareAlias2("inverter2.transistor_n.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 "inverter2.transistor_n.i[1]", 1, 5, 175, 132)
DeclareAlias2("inverter2.transistor_n.plug_p.pin[2].v", "Potential at the pin [V]",\
 "inverter2.ac.pin[2].v", 1, 5, 45, 4)
DeclareAlias2("inverter2.transistor_n.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 "inverter2.transistor_n.i[2]", 1, 5, 176, 132)
DeclareAlias2("inverter2.transistor_n.plug_p.pin[3].v", "Potential at the pin [V]",\
 "inverter2.ac.pin[3].v", 1, 5, 47, 4)
DeclareAlias2("inverter2.transistor_n.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 "inverter2.transistor_n.i[3]", 1, 5, 177, 132)
DeclareVariable("inverter2.transistor_n.plug_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("inverter2.transistor_n.plug_n.pin[1].v", "Potential at the pin [V]",\
 "inverter2.dc_n.v", 1, 5, 38, 4)
DeclareAlias2("inverter2.transistor_n.plug_n.pin[1].i", "Current flowing into the pin [A]",\
 "inverter2.transistor_n.i[1]", -1, 5, 175, 132)
DeclareAlias2("inverter2.transistor_n.plug_n.pin[2].v", "Potential at the pin [V]",\
 "inverter2.dc_n.v", 1, 5, 38, 4)
DeclareAlias2("inverter2.transistor_n.plug_n.pin[2].i", "Current flowing into the pin [A]",\
 "inverter2.transistor_n.i[2]", -1, 5, 176, 132)
DeclareAlias2("inverter2.transistor_n.plug_n.pin[3].v", "Potential at the pin [V]",\
 "inverter2.dc_n.v", 1, 5, 38, 4)
DeclareAlias2("inverter2.transistor_n.plug_n.pin[3].i", "Current flowing into the pin [A]",\
 "inverter2.transistor_n.i[3]", -1, 5, 177, 132)
DeclareVariable("inverter2.transistor_n.Ron[1]", "Closed thyristor resistance [Ohm]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_n.Ron[2]", "Closed thyristor resistance [Ohm]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_n.Ron[3]", "Closed thyristor resistance [Ohm]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_n.Goff[1]", "Opened thyristor conductance [S]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_n.Goff[2]", "Opened thyristor conductance [S]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_n.Goff[3]", "Opened thyristor conductance [S]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_n.Vknee[1]", "Threshold voltage [V]", 0, \
0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_n.Vknee[2]", "Threshold voltage [V]", 0, \
0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_n.Vknee[3]", "Threshold voltage [V]", 0, \
0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_n.mh", "Number of heatPorts=number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("inverter2.transistor_n.useHeatPort", "=true, if all heat ports are enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("inverter2.transistor_n.T[1]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter2.transistor_n.T[2]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter2.transistor_n.T[3]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter2.transistor_n.fire[1]", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,642)
DeclareVariable("inverter2.transistor_n.fire[2]", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,642)
DeclareVariable("inverter2.transistor_n.fire[3]", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,642)
DeclareVariable("inverter2.transistor_n.idealGTOThyristor[1].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter2.transistor_n.idealGTOThyristor[1].i", "Current flowing from pin p to pin n [A]",\
 "inverter2.transistor_n.i[1]", 1, 5, 175, 0)
DeclareAlias2("inverter2.transistor_n.idealGTOThyristor[1].p.v", \
"Potential at the pin [V]", "inverter2.ac.pin[1].v", 1, 5, 43, 4)
DeclareAlias2("inverter2.transistor_n.idealGTOThyristor[1].p.i", \
"Current flowing into the pin [A]", "inverter2.transistor_n.i[1]", 1, 5, 175, 132)
DeclareAlias2("inverter2.transistor_n.idealGTOThyristor[1].n.v", \
"Potential at the pin [V]", "inverter2.dc_n.v", 1, 5, 38, 4)
DeclareAlias2("inverter2.transistor_n.idealGTOThyristor[1].n.i", \
"Current flowing into the pin [A]", "inverter2.transistor_n.i[1]", -1, 5, 175, 132)
DeclareVariable("inverter2.transistor_n.idealGTOThyristor[1].Ron", \
"Forward state-on differential resistance (closed resistance) [Ohm]", 0.0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_n.idealGTOThyristor[1].Goff", \
"Backward state-off conductance (opened conductance) [S]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_n.idealGTOThyristor[1].Vknee", \
"Forward threshold voltage [V]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_n.idealGTOThyristor[1].useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter2.transistor_n.idealGTOThyristor[1].T", \
"Fixed device temperature if useHeatPort = false [K|degC]", 21, 293.15, 0.0,\
1E+100,300.0,0,560)
DeclareVariable("inverter2.transistor_n.idealGTOThyristor[1].LossPower", \
"Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter2.transistor_n.idealGTOThyristor[1].T_heatPort", \
"Temperature of heatPort [K|degC]", "inverter2.transistor_n.idealGTOThyristor[1].T", 1,\
 7, 21, 0)
DeclareVariable("inverter2.transistor_n.idealGTOThyristor[1].off", \
"Switching state [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter2.transistor_n.idealGTOThyristor[1].s", \
"Auxiliary variable for actual position on the ideal diode characteristic [1]", 0,\
 0.0,0.0,0.0,0,2560)
DeclareVariable("inverter2.transistor_n.idealGTOThyristor[1].unitVoltage", "[V]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("inverter2.transistor_n.idealGTOThyristor[1].unitCurrent", "[A]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("inverter2.transistor_n.idealGTOThyristor[1].fire", \
"[:#(type=Boolean)]", "inverter2.transistor_n.fire[1]", 1, 5, 194, 65)
DeclareVariable("inverter2.transistor_n.idealGTOThyristor[2].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter2.transistor_n.idealGTOThyristor[2].i", "Current flowing from pin p to pin n [A]",\
 "inverter2.transistor_n.i[2]", 1, 5, 176, 0)
DeclareAlias2("inverter2.transistor_n.idealGTOThyristor[2].p.v", \
"Potential at the pin [V]", "inverter2.ac.pin[2].v", 1, 5, 45, 4)
DeclareAlias2("inverter2.transistor_n.idealGTOThyristor[2].p.i", \
"Current flowing into the pin [A]", "inverter2.transistor_n.i[2]", 1, 5, 176, 132)
DeclareAlias2("inverter2.transistor_n.idealGTOThyristor[2].n.v", \
"Potential at the pin [V]", "inverter2.dc_n.v", 1, 5, 38, 4)
DeclareAlias2("inverter2.transistor_n.idealGTOThyristor[2].n.i", \
"Current flowing into the pin [A]", "inverter2.transistor_n.i[2]", -1, 5, 176, 132)
DeclareVariable("inverter2.transistor_n.idealGTOThyristor[2].Ron", \
"Forward state-on differential resistance (closed resistance) [Ohm]", 0.0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_n.idealGTOThyristor[2].Goff", \
"Backward state-off conductance (opened conductance) [S]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_n.idealGTOThyristor[2].Vknee", \
"Forward threshold voltage [V]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_n.idealGTOThyristor[2].useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter2.transistor_n.idealGTOThyristor[2].T", \
"Fixed device temperature if useHeatPort = false [K|degC]", 22, 293.15, 0.0,\
1E+100,300.0,0,560)
DeclareVariable("inverter2.transistor_n.idealGTOThyristor[2].LossPower", \
"Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter2.transistor_n.idealGTOThyristor[2].T_heatPort", \
"Temperature of heatPort [K|degC]", "inverter2.transistor_n.idealGTOThyristor[2].T", 1,\
 7, 22, 0)
DeclareVariable("inverter2.transistor_n.idealGTOThyristor[2].off", \
"Switching state [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter2.transistor_n.idealGTOThyristor[2].s", \
"Auxiliary variable for actual position on the ideal diode characteristic [1]", 0,\
 0.0,0.0,0.0,0,2560)
DeclareVariable("inverter2.transistor_n.idealGTOThyristor[2].unitVoltage", "[V]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("inverter2.transistor_n.idealGTOThyristor[2].unitCurrent", "[A]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("inverter2.transistor_n.idealGTOThyristor[2].fire", \
"[:#(type=Boolean)]", "inverter2.transistor_n.fire[2]", 1, 5, 195, 65)
DeclareVariable("inverter2.transistor_n.idealGTOThyristor[3].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter2.transistor_n.idealGTOThyristor[3].i", "Current flowing from pin p to pin n [A]",\
 "inverter2.transistor_n.i[3]", 1, 5, 177, 0)
DeclareAlias2("inverter2.transistor_n.idealGTOThyristor[3].p.v", \
"Potential at the pin [V]", "inverter2.ac.pin[3].v", 1, 5, 47, 4)
DeclareAlias2("inverter2.transistor_n.idealGTOThyristor[3].p.i", \
"Current flowing into the pin [A]", "inverter2.transistor_n.i[3]", 1, 5, 177, 132)
DeclareAlias2("inverter2.transistor_n.idealGTOThyristor[3].n.v", \
"Potential at the pin [V]", "inverter2.dc_n.v", 1, 5, 38, 4)
DeclareAlias2("inverter2.transistor_n.idealGTOThyristor[3].n.i", \
"Current flowing into the pin [A]", "inverter2.transistor_n.i[3]", -1, 5, 177, 132)
DeclareVariable("inverter2.transistor_n.idealGTOThyristor[3].Ron", \
"Forward state-on differential resistance (closed resistance) [Ohm]", 0.0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_n.idealGTOThyristor[3].Goff", \
"Backward state-off conductance (opened conductance) [S]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_n.idealGTOThyristor[3].Vknee", \
"Forward threshold voltage [V]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.transistor_n.idealGTOThyristor[3].useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter2.transistor_n.idealGTOThyristor[3].T", \
"Fixed device temperature if useHeatPort = false [K|degC]", 23, 293.15, 0.0,\
1E+100,300.0,0,560)
DeclareVariable("inverter2.transistor_n.idealGTOThyristor[3].LossPower", \
"Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter2.transistor_n.idealGTOThyristor[3].T_heatPort", \
"Temperature of heatPort [K|degC]", "inverter2.transistor_n.idealGTOThyristor[3].T", 1,\
 7, 23, 0)
DeclareVariable("inverter2.transistor_n.idealGTOThyristor[3].off", \
"Switching state [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter2.transistor_n.idealGTOThyristor[3].s", \
"Auxiliary variable for actual position on the ideal diode characteristic [1]", 0,\
 0.0,0.0,0.0,0,2560)
DeclareVariable("inverter2.transistor_n.idealGTOThyristor[3].unitVoltage", "[V]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("inverter2.transistor_n.idealGTOThyristor[3].unitCurrent", "[A]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("inverter2.transistor_n.idealGTOThyristor[3].fire", \
"[:#(type=Boolean)]", "inverter2.transistor_n.fire[3]", 1, 5, 196, 65)
DeclareVariable("inverter2.diode_n.m", "Number of phases [:#(type=Integer)]", 3,\
 1.0,1E+100,0.0,0,517)
DeclareVariable("inverter2.diode_n.v[1]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter2.diode_n.v[2]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter2.diode_n.v[3]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter2.diode_n.i[1]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter2.diode_n.i[2]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter2.diode_n.i[3]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter2.diode_n.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("inverter2.diode_n.plug_p.pin[1].v", "Potential at the pin [V]", \
"inverter2.dc_n.v", 1, 5, 38, 4)
DeclareAlias2("inverter2.diode_n.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 "inverter2.diode_n.i[1]", 1, 5, 231, 132)
DeclareAlias2("inverter2.diode_n.plug_p.pin[2].v", "Potential at the pin [V]", \
"inverter2.dc_n.v", 1, 5, 38, 4)
DeclareAlias2("inverter2.diode_n.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 "inverter2.diode_n.i[2]", 1, 5, 232, 132)
DeclareAlias2("inverter2.diode_n.plug_p.pin[3].v", "Potential at the pin [V]", \
"inverter2.dc_n.v", 1, 5, 38, 4)
DeclareAlias2("inverter2.diode_n.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 "inverter2.diode_n.i[3]", 1, 5, 233, 132)
DeclareVariable("inverter2.diode_n.plug_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("inverter2.diode_n.plug_n.pin[1].v", "Potential at the pin [V]", \
"inverter2.ac.pin[1].v", 1, 5, 43, 4)
DeclareAlias2("inverter2.diode_n.plug_n.pin[1].i", "Current flowing into the pin [A]",\
 "inverter2.diode_n.i[1]", -1, 5, 231, 132)
DeclareAlias2("inverter2.diode_n.plug_n.pin[2].v", "Potential at the pin [V]", \
"inverter2.ac.pin[2].v", 1, 5, 45, 4)
DeclareAlias2("inverter2.diode_n.plug_n.pin[2].i", "Current flowing into the pin [A]",\
 "inverter2.diode_n.i[2]", -1, 5, 232, 132)
DeclareAlias2("inverter2.diode_n.plug_n.pin[3].v", "Potential at the pin [V]", \
"inverter2.ac.pin[3].v", 1, 5, 47, 4)
DeclareAlias2("inverter2.diode_n.plug_n.pin[3].i", "Current flowing into the pin [A]",\
 "inverter2.diode_n.i[3]", -1, 5, 233, 132)
DeclareVariable("inverter2.diode_n.Ron[1]", "Closed diode resistance [Ohm]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_n.Ron[2]", "Closed diode resistance [Ohm]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_n.Ron[3]", "Closed diode resistance [Ohm]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_n.Goff[1]", "Opened diode conductance [S]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_n.Goff[2]", "Opened diode conductance [S]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_n.Goff[3]", "Opened diode conductance [S]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_n.Vknee[1]", "Threshold voltage [V]", 0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_n.Vknee[2]", "Threshold voltage [V]", 0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_n.Vknee[3]", "Threshold voltage [V]", 0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_n.mh", "Number of heatPorts=number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("inverter2.diode_n.useHeatPort", "=true, if all heat ports are enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("inverter2.diode_n.T[1]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter2.diode_n.T[2]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter2.diode_n.T[3]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter2.diode_n.idealDiode[1].v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter2.diode_n.idealDiode[1].i", "Current flowing from pin p to pin n [A]",\
 "inverter2.diode_n.i[1]", 1, 5, 231, 0)
DeclareAlias2("inverter2.diode_n.idealDiode[1].p.v", "Potential at the pin [V]",\
 "inverter2.dc_n.v", 1, 5, 38, 4)
DeclareAlias2("inverter2.diode_n.idealDiode[1].p.i", "Current flowing into the pin [A]",\
 "inverter2.diode_n.i[1]", 1, 5, 231, 132)
DeclareAlias2("inverter2.diode_n.idealDiode[1].n.v", "Potential at the pin [V]",\
 "inverter2.ac.pin[1].v", 1, 5, 43, 4)
DeclareAlias2("inverter2.diode_n.idealDiode[1].n.i", "Current flowing into the pin [A]",\
 "inverter2.diode_n.i[1]", -1, 5, 231, 132)
DeclareVariable("inverter2.diode_n.idealDiode[1].Ron", "Forward state-on differential resistance (closed resistance) [Ohm]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_n.idealDiode[1].Goff", "Backward state-off conductance (opened conductance) [S]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_n.idealDiode[1].Vknee", "Forward threshold voltage [V]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_n.idealDiode[1].useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter2.diode_n.idealDiode[1].T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 24, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("inverter2.diode_n.idealDiode[1].LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter2.diode_n.idealDiode[1].T_heatPort", "Temperature of heatPort [K|degC]",\
 "inverter2.diode_n.idealDiode[1].T", 1, 7, 24, 0)
DeclareVariable("inverter2.diode_n.idealDiode[1].off", "Switching state [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter2.diode_n.idealDiode[1].s", "Auxiliary variable for actual position on the ideal diode characteristic [1]",\
 0, 0.0,0.0,0.0,0,2560)
DeclareVariable("inverter2.diode_n.idealDiode[1].unitVoltage", "[V]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter2.diode_n.idealDiode[1].unitCurrent", "[A]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter2.diode_n.idealDiode[2].v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter2.diode_n.idealDiode[2].i", "Current flowing from pin p to pin n [A]",\
 "inverter2.diode_n.i[2]", 1, 5, 232, 0)
DeclareAlias2("inverter2.diode_n.idealDiode[2].p.v", "Potential at the pin [V]",\
 "inverter2.dc_n.v", 1, 5, 38, 4)
DeclareAlias2("inverter2.diode_n.idealDiode[2].p.i", "Current flowing into the pin [A]",\
 "inverter2.diode_n.i[2]", 1, 5, 232, 132)
DeclareAlias2("inverter2.diode_n.idealDiode[2].n.v", "Potential at the pin [V]",\
 "inverter2.ac.pin[2].v", 1, 5, 45, 4)
DeclareAlias2("inverter2.diode_n.idealDiode[2].n.i", "Current flowing into the pin [A]",\
 "inverter2.diode_n.i[2]", -1, 5, 232, 132)
DeclareVariable("inverter2.diode_n.idealDiode[2].Ron", "Forward state-on differential resistance (closed resistance) [Ohm]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_n.idealDiode[2].Goff", "Backward state-off conductance (opened conductance) [S]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_n.idealDiode[2].Vknee", "Forward threshold voltage [V]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_n.idealDiode[2].useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter2.diode_n.idealDiode[2].T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 25, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("inverter2.diode_n.idealDiode[2].LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter2.diode_n.idealDiode[2].T_heatPort", "Temperature of heatPort [K|degC]",\
 "inverter2.diode_n.idealDiode[2].T", 1, 7, 25, 0)
DeclareVariable("inverter2.diode_n.idealDiode[2].off", "Switching state [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter2.diode_n.idealDiode[2].s", "Auxiliary variable for actual position on the ideal diode characteristic [1]",\
 0, 0.0,0.0,0.0,0,2560)
DeclareVariable("inverter2.diode_n.idealDiode[2].unitVoltage", "[V]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter2.diode_n.idealDiode[2].unitCurrent", "[A]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter2.diode_n.idealDiode[3].v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter2.diode_n.idealDiode[3].i", "Current flowing from pin p to pin n [A]",\
 "inverter2.diode_n.i[3]", 1, 5, 233, 0)
DeclareAlias2("inverter2.diode_n.idealDiode[3].p.v", "Potential at the pin [V]",\
 "inverter2.dc_n.v", 1, 5, 38, 4)
DeclareAlias2("inverter2.diode_n.idealDiode[3].p.i", "Current flowing into the pin [A]",\
 "inverter2.diode_n.i[3]", 1, 5, 233, 132)
DeclareAlias2("inverter2.diode_n.idealDiode[3].n.v", "Potential at the pin [V]",\
 "inverter2.ac.pin[3].v", 1, 5, 47, 4)
DeclareAlias2("inverter2.diode_n.idealDiode[3].n.i", "Current flowing into the pin [A]",\
 "inverter2.diode_n.i[3]", -1, 5, 233, 132)
DeclareVariable("inverter2.diode_n.idealDiode[3].Ron", "Forward state-on differential resistance (closed resistance) [Ohm]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_n.idealDiode[3].Goff", "Backward state-off conductance (opened conductance) [S]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_n.idealDiode[3].Vknee", "Forward threshold voltage [V]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter2.diode_n.idealDiode[3].useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter2.diode_n.idealDiode[3].T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 26, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("inverter2.diode_n.idealDiode[3].LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter2.diode_n.idealDiode[3].T_heatPort", "Temperature of heatPort [K|degC]",\
 "inverter2.diode_n.idealDiode[3].T", 1, 7, 26, 0)
DeclareVariable("inverter2.diode_n.idealDiode[3].off", "Switching state [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter2.diode_n.idealDiode[3].s", "Auxiliary variable for actual position on the ideal diode characteristic [1]",\
 0, 0.0,0.0,0.0,0,2560)
DeclareVariable("inverter2.diode_n.idealDiode[3].unitVoltage", "[V]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter2.diode_n.idealDiode[3].unitCurrent", "[A]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter2.star_n.m", "Number of phases [:#(type=Integer)]", 3, \
1.0,1E+100,0.0,0,517)
DeclareVariable("inverter2.star_n.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("inverter2.star_n.plug_p.pin[1].v", "Potential at the pin [V]", \
"inverter2.dc_n.v", 1, 5, 38, 4)
DeclareVariable("inverter2.star_n.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("inverter2.star_n.plug_p.pin[2].v", "Potential at the pin [V]", \
"inverter2.dc_n.v", 1, 5, 38, 4)
DeclareVariable("inverter2.star_n.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("inverter2.star_n.plug_p.pin[3].v", "Potential at the pin [V]", \
"inverter2.dc_n.v", 1, 5, 38, 4)
DeclareVariable("inverter2.star_n.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("inverter2.star_n.pin_n.v", "Potential at the pin [V]", \
"inverter2.dc_n.v", 1, 5, 38, 4)
DeclareAlias2("inverter2.star_n.pin_n.i", "Current flowing into the pin [A]", \
"inverter2.dc_n.i", 1, 5, 39, 132)
DeclareParameter("dcdc.RonTransistor", "Transistor closed resistance [Ohm]", 27,\
 1E-05, 0.0,0.0,0.0,0,560)
DeclareParameter("dcdc.GoffTransistor", "Transistor opened conductance [S]", 28,\
 1E-05, 0.0,0.0,0.0,0,560)
DeclareParameter("dcdc.VkneeTransistor", "Transistor threshold voltage [V]", 29,\
 0, 0.0,0.0,0.0,0,560)
DeclareParameter("dcdc.RonDiode", "Closed diode resistance [Ohm]", 30, 1E-05, \
0.0,1E+100,0.0,0,560)
DeclareParameter("dcdc.GoffDiode", "Opened diode conductance [S]", 31, 1E-05, \
0.0,1E+100,0.0,0,560)
DeclareParameter("dcdc.VkneeDiode", "Diode forward threshold voltage [V]", 32, 0,\
 0.0,1E+100,0.0,0,560)
DeclareAlias2("dcdc.dc_p1.v", "Potential at the pin [V]", "simplifiedFuelCell.pin_p.v", 1,\
 5, 9, 4)
DeclareAlias2("dcdc.dc_p1.i", "Current flowing into the pin [A]", \
"simplifiedFuelCell.pin_p.i", -1, 5, 10, 132)
DeclareAlias2("dcdc.dc_n1.v", "Potential at the pin [V]", "simplifiedFuelCell.pin_p1.v", 1,\
 5, 21, 4)
DeclareAlias2("dcdc.dc_n1.i", "Current flowing into the pin [A]", \
"simplifiedFuelCell.pin_p1.i", -1, 5, 22, 132)
DeclareVariable("dcdc.vDC1", "DC voltage side 1 [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dcdc.iDC1", "DC current side 1 [A]", "simplifiedFuelCell.pin_p.i", -1,\
 5, 10, 0)
DeclareVariable("dcdc.powerDC1", "DC power side 1 [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("dcdc.dc_p2.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("dcdc.dc_p2.i", "Current flowing into the pin [A]", \
"inverter2.dc_p.i", -1, 5, 37, 132)
DeclareAlias2("dcdc.dc_n2.v", "Potential at the pin [V]", "simplifiedFuelCell.pin_p1.v", 1,\
 5, 21, 4)
DeclareAlias2("dcdc.dc_n2.i", "Current flowing into the pin [A]", \
"inverter2.dc_n.i", -1, 5, 39, 132)
DeclareVariable("dcdc.vDC2", "DC voltages side 2 [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dcdc.iDC2", "DC current side 2 [A]", "inverter2.dc_p.i", -1, 5, 37,\
 0)
DeclareVariable("dcdc.powerDC2", "DC power side 2 [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("dcdc.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("dcdc.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("dcdc.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("dcdc.T_heatPort", "Temperature of heatPort [K|degC]", 293.15, \
0.0,1E+100,300.0,0,513)
DeclareVariable("dcdc.useConstantEnable", "true = disabled boolean input, use constantEnable [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("dcdc.constantEnable", "Constant enabling of firing signals [:#(type=Boolean)]",\
 33, true, 0.0,0.0,0.0,0,562)
DeclareVariable("dcdc.m", "Number of phases [:#(type=Integer)]", 1, 1.0,1E+100,\
0.0,0,517)
DeclareVariable("dcdc.enableLogic.useConstantEnable", "true = disabled boolean input, use constantEnable [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("dcdc.enableLogic.constantEnable", "Constant enabling of firing signals [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("dcdc.enableLogic.m", "Number of phases [:#(type=Integer)]", 1, \
1.0,1E+100,0.0,0,517)
DeclareVariable("dcdc.enableLogic.enableConstantSource.k", "Constant output value [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("dcdc.enableLogic.enableConstantSource.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "dcdc.enableLogic.enableConstantSource.k", 1, 5, 299, 65)
DeclareVariable("dcdc.enableLogic.booleanReplicator.nout", "Number of outputs [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,517)
DeclareAlias2("dcdc.enableLogic.booleanReplicator.u", "Connector of Boolean input signal [:#(type=Boolean)]",\
 "dcdc.enableLogic.enableConstantSource.k", 1, 5, 299, 65)
DeclareAlias2("dcdc.enableLogic.booleanReplicator.y[1]", "Connector of Boolean output signals [:#(type=Boolean)]",\
 "dcdc.enableLogic.enableConstantSource.k", 1, 5, 299, 65)
DeclareAlias2("dcdc.enableLogic.internalEnable[1]", "m replicated enable signals [:#(type=Boolean)]",\
 "dcdc.enableLogic.enableConstantSource.k", 1, 5, 299, 65)
DeclareAlias2("dcdc.andCondition_p.u1", "Connector of first Boolean input signal [:#(type=Boolean)]",\
 "dcdc.fire_p", 1, 5, 302, 65)
DeclareAlias2("dcdc.andCondition_p.u2", "Connector of second Boolean input signal [:#(type=Boolean)]",\
 "dcdc.enableLogic.enableConstantSource.k", 1, 5, 299, 65)
DeclareVariable("dcdc.andCondition_p.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,642)
DeclareVariable("dcdc.fire_p", "Firing signal of positive potential transistor [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,642)
DeclareVariable("dcdc.transistor.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("dcdc.transistor.i", "Current flowing from pin p to pin n [A]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dcdc.transistor.p.v", "Potential at the pin [V]", \
"simplifiedFuelCell.pin_p.v", 1, 5, 9, 4)
DeclareAlias2("dcdc.transistor.p.i", "Current flowing into the pin [A]", \
"dcdc.transistor.i", 1, 5, 304, 132)
DeclareAlias2("dcdc.transistor.n.v", "Potential at the pin [V]", \
"simplifiedFuelCell.pin_p1.v", 1, 5, 21, 4)
DeclareAlias2("dcdc.transistor.n.i", "Current flowing into the pin [A]", \
"dcdc.transistor.i", -1, 5, 304, 132)
DeclareVariable("dcdc.transistor.Ron", "Forward state-on differential resistance (closed resistance) [Ohm]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("dcdc.transistor.Goff", "Backward state-off conductance (opened conductance) [S]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("dcdc.transistor.Vknee", "Forward threshold voltage [V]", 0.0, \
0.0,1E+100,0.0,0,513)
DeclareVariable("dcdc.transistor.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("dcdc.transistor.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 34, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("dcdc.transistor.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dcdc.transistor.T_heatPort", "Temperature of heatPort [K|degC]", \
"dcdc.transistor.T", 1, 7, 34, 0)
DeclareVariable("dcdc.transistor.off", "Switching state [:#(type=Boolean)]", \
true, 0.0,0.0,0.0,0,706)
DeclareVariable("dcdc.transistor.s", "Auxiliary variable for actual position on the ideal diode characteristic [1]",\
 0, 0.0,0.0,0.0,0,2560)
DeclareVariable("dcdc.transistor.unitVoltage", "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("dcdc.transistor.unitCurrent", "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("dcdc.transistor.fire", "[:#(type=Boolean)]", "dcdc.andCondition_p.y", 1,\
 5, 301, 65)
DeclareVariable("dcdc.diode.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dcdc.diode.i", "Current flowing from pin p to pin n [A]", \
"inverter2.dc_p.i", 1, 5, 37, 0)
DeclareAlias2("dcdc.diode.p.v", "Potential at the pin [V]", "simplifiedFuelCell.pin_p.v", 1,\
 5, 9, 4)
DeclareAlias2("dcdc.diode.p.i", "Current flowing into the pin [A]", \
"inverter2.dc_p.i", 1, 5, 37, 132)
DeclareAlias2("dcdc.diode.n.v", "Potential at the pin [V]", "dcdc.dc_p2.v", 1, 5,\
 287, 4)
DeclareAlias2("dcdc.diode.n.i", "Current flowing into the pin [A]", \
"inverter2.dc_p.i", -1, 5, 37, 132)
DeclareVariable("dcdc.diode.Ron", "Forward state-on differential resistance (closed resistance) [Ohm]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("dcdc.diode.Goff", "Backward state-off conductance (opened conductance) [S]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("dcdc.diode.Vknee", "Forward threshold voltage [V]", 0.0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("dcdc.diode.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("dcdc.diode.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 35, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("dcdc.diode.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dcdc.diode.T_heatPort", "Temperature of heatPort [K|degC]", \
"dcdc.diode.T", 1, 7, 35, 0)
DeclareVariable("dcdc.diode.off", "Switching state [:#(type=Boolean)]", true, \
0.0,0.0,0.0,0,706)
DeclareVariable("dcdc.diode.s", "Auxiliary variable for actual position on the ideal diode characteristic [1]",\
 0, 0.0,0.0,0.0,0,2560)
DeclareVariable("dcdc.diode.unitVoltage", "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("dcdc.diode.unitCurrent", "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("signalPWM2.useConstantDutyCycle", "Enables constant duty cycle [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("signalPWM2.constantDutyCycle", "Constant duty cycle", 36, 0.6,\
 0.0,0.0,0.0,0,560)
DeclareParameter("signalPWM2.f", "Switching frequency [Hz]", 37, 100, 0.0,0.0,\
0.0,0,560)
DeclareParameter("signalPWM2.startTime", "Start time [s]", 38, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("signalPWM2.fire", "Firing PWM signal [:#(type=Boolean)]", \
"dcdc.fire_p", 1, 5, 302, 65)
DeclareVariable("signalPWM2.notFire", "Firing PWM signal [:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,642)
DeclareVariable("signalPWM2.const.k", "Constant output value", 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("signalPWM2.const.y", "Connector of Real output signal", \
"signalPWM2.const.k", 1, 5, 326, 0)
DeclareParameter("signalPWM2.limiter.uMax", "Upper limits of input signals", 39,\
 1, 0.0,0.0,0.0,0,560)
DeclareParameter("signalPWM2.limiter.uMin", "Lower limits of input signals", 40,\
 0, 0.0,0.0,0.0,0,560)
DeclareVariable("signalPWM2.limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("signalPWM2.limiter.homotopyType", "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("signalPWM2.limiter.limitsAtInit", "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("signalPWM2.limiter.u", "Connector of Real input signal", \
"signalPWM2.const.k", 1, 5, 326, 0)
DeclareVariable("signalPWM2.limiter.y", "Connector of Real output signal", 0.0, \
0.0,0.0,0.0,0,513)
DeclareAlias2("signalPWM2.limiter.simplifiedExpr", "Simplified expression for homotopy-based initialization",\
 "signalPWM2.const.k", 1, 5, 326, 1024)
DeclareVariable("signalPWM2.greaterEqual.u1", "Connector of first Real input signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("signalPWM2.greaterEqual.u2", "Connector of second Real input signal",\
 0.0, 0.0,0.0,0.0,0,640)
DeclareAlias2("signalPWM2.greaterEqual.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "dcdc.fire_p", 1, 5, 302, 65)
DeclareVariable("signalPWM2.zeroOrderHold.samplePeriod", "Sample period of component [s]",\
 0.1, 1E-13,1E+100,0.0,0,513)
DeclareVariable("signalPWM2.zeroOrderHold.startTime", "First sample time instant [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM2.zeroOrderHold.sampleTrigger", "True, if sample time instant [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2690)
DeclareVariable("signalPWM2.zeroOrderHold.firstTrigger", "Rising edge signals first sample instant [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2706)
DeclareAlias2("signalPWM2.zeroOrderHold.u", "Connector of Real input signal", \
"signalPWM2.limiter.y", 1, 5, 330, 0)
DeclareAlias2("signalPWM2.zeroOrderHold.y", "Connector of Real output signal", \
"signalPWM2.greaterEqual.u2", 1, 5, 332, 0)
DeclareVariable("signalPWM2.zeroOrderHold.ySample", "", 0, 0.0,0.0,0.0,0,656)
DeclareVariable("signalPWM2.sawtooth.amplitude", "Amplitude of saw tooth", 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM2.sawtooth.period", "Time for one period [s]", 1, \
1E-60,1E+100,0.0,0,513)
DeclareVariable("signalPWM2.sawtooth.nperiod", "Number of periods (< 0 means infinite number of periods) [:#(type=Integer)]",\
 -1, 0.0,0.0,0.0,0,517)
DeclareAlias2("signalPWM2.sawtooth.y", "Connector of Real output signal", \
"signalPWM2.greaterEqual.u1", 1, 5, 331, 0)
DeclareVariable("signalPWM2.sawtooth.offset", "Offset of output signal y", 0, \
0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM2.sawtooth.startTime", "Output y = offset for time < startTime [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM2.sawtooth.T_start", "Start time of current period [s]",\
 0.0, 0.0,0.0,0.0,0,2688)
DeclareVariable("signalPWM2.sawtooth.count", "Period count [:#(type=Integer)]", 0,\
 0.0,0.0,0.0,0,2692)
DeclareAlias2("signalPWM2.inverse.u", "Connector of Boolean input signal [:#(type=Boolean)]",\
 "dcdc.fire_p", 1, 5, 302, 65)
DeclareAlias2("signalPWM2.inverse.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "signalPWM2.notFire", 1, 5, 325, 65)
DeclareParameter("threePhaseMotor.m", "Number of phases [:#(type=Integer)]", 41,\
 3, 0.0,0.0,0.0,0,564)
DeclareParameter("threePhaseMotor.wref", "[rev/min]", 42, 4000, 0.0,0.0,0.0,0,560)
DeclareVariable("threePhaseMotor.aimc.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("threePhaseMotor.aimc.p", "Number of pole pairs (Integer) [:#(type=Integer)]",\
 2, 1.0,1E+100,0.0,0,517)
DeclareVariable("threePhaseMotor.aimc.fsNominal", "Nominal frequency [Hz]", 50, \
0.0,0.0,0.0,0,513)
DeclareParameter("threePhaseMotor.aimc.TsOperational", "Operational temperature of stator resistance [K|degC]",\
 43, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("threePhaseMotor.aimc.Rs", "Stator resistance per phase at TRef [Ohm]",\
 0.03, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.TsRef", "Reference temperature of stator resistance [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor.aimc.alpha20s", "Temperature coefficient of stator resistance at 20 degC [1/K|1/K]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.Lszero", "Stator zero sequence inductance [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.Lssigma", "Stator stray inductance per phase [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.Jr", "Rotor's moment of inertia [kg.m2]", \
0.29, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.useSupport", "Enable / disable (=fixed stator) support [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("threePhaseMotor.aimc.Js", "Stator's moment of inertia [kg.m2]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.useThermalPort", "Enable / disable (=fixed temperatures) thermal port [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("threePhaseMotor.aimc.frictionParameters.PRef", "Reference friction losses at wRef [W]",\
 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.frictionParameters.wRef", "Reference angular velocity that the PRef refer to [rad/s|rev/min]",\
 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.frictionParameters.power_w", \
"Exponent of friction torque w.r.t. angular velocity", 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.frictionParameters.tauRef", \
"Reference friction torque at reference angular velocity [N.m]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.frictionParameters.linear", \
"Linear angular velocity range with respect to reference angular velocity", \
0.001, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.frictionParameters.wLinear", \
"Linear angular velocity range [rad/s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.frictionParameters.tauLinear", \
"Torque corresponding with linear angular velocity range [N.m]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.phiMechanical", "Mechanical angle of rotor against stator [rad|deg]",\
 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor.aimc.der(phiMechanical)", "der(Mechanical angle of rotor against stator) [rad/s]",\
 "fan.inertia.w", 1, 1, 6, 0)
DeclareAlias2("threePhaseMotor.aimc.wMechanical", "Mechanical angular velocity of rotor against stator [rad/s|rev/min]",\
 "fan.inertia.w", 1, 1, 6, 0)
DeclareVariable("threePhaseMotor.aimc.tauElectrical", "Electromagnetic torque [N.m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor.aimc.tauShaft", "Shaft torque [N.m]", \
"threePhaseMotor.flange1.tau", -1, 5, 650, 0)
DeclareAlias2("threePhaseMotor.aimc.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "variableSpeedDrive_ThreePhase.speedSensor.flange.phi", 1, 1, 4, 4)
DeclareAlias2("threePhaseMotor.aimc.flange.tau", "Cut torque in the flange [N.m]",\
 "threePhaseMotor.flange1.tau", 1, 5, 650, 132)
DeclareAlias2("threePhaseMotor.aimc.inertiaRotor.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "variableSpeedDrive_ThreePhase.speedSensor.flange.phi", 1, 1, 4, 4)
DeclareAlias2("threePhaseMotor.aimc.inertiaRotor.flange_a.tau", "Cut torque in the flange [N.m]",\
 "threePhaseMotor.aimc.tauElectrical", 1, 5, 365, 132)
DeclareAlias2("threePhaseMotor.aimc.inertiaRotor.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "variableSpeedDrive_ThreePhase.speedSensor.flange.phi", 1, 1, 4, 4)
DeclareAlias2("threePhaseMotor.aimc.inertiaRotor.flange_b.tau", "Cut torque in the flange [N.m]",\
 "threePhaseMotor.flange1.tau", 1, 5, 650, 132)
DeclareVariable("threePhaseMotor.aimc.inertiaRotor.J", "Moment of inertia [kg.m2]",\
 1, 0.0,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.inertiaRotor.stateSelect", \
"Priority to use phi and w as states [:#(type=StateSelect)]", 3, 1.0,5.0,0.0,0,1541)
DeclareAlias2("threePhaseMotor.aimc.inertiaRotor.phi", "Absolute rotation angle of component [rad|deg]",\
 "variableSpeedDrive_ThreePhase.speedSensor.flange.phi", 1, 1, 4, 0)
DeclareAlias2("threePhaseMotor.aimc.inertiaRotor.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 "fan.inertia.w", 1, 1, 6, 0)
DeclareAlias2("threePhaseMotor.aimc.inertiaRotor.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 "fan.inertia.w", 1, 1, 6, 0)
DeclareAlias2("threePhaseMotor.aimc.inertiaRotor.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 "fan.inertia.der(w)", 1, 6, 6, 0)
DeclareAlias2("threePhaseMotor.aimc.inertiaRotor.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "fan.inertia.der(w)", 1, 6, 6, 0)
DeclareAlias2("threePhaseMotor.aimc.inertiaStator.flange_a.phi", \
"Absolute rotation angle of flange [rad|deg]", "threePhaseMotor.aimc.fixed.phi0", 1,\
 7, 44, 4)
DeclareVariable("threePhaseMotor.aimc.inertiaStator.flange_a.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("threePhaseMotor.aimc.inertiaStator.flange_b.phi", \
"Absolute rotation angle of flange [rad|deg]", "threePhaseMotor.aimc.fixed.phi0", 1,\
 7, 44, 4)
DeclareVariable("threePhaseMotor.aimc.inertiaStator.flange_b.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor.aimc.inertiaStator.J", "Moment of inertia [kg.m2]",\
 1, 0.0,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.inertiaStator.stateSelect", \
"Priority to use phi and w as states [:#(type=StateSelect)]", 3, 1.0,5.0,0.0,0,1541)
DeclareAlias2("threePhaseMotor.aimc.inertiaStator.phi", "Absolute rotation angle of component [rad|deg]",\
 "threePhaseMotor.aimc.fixed.phi0", 1, 7, 44, 0)
DeclareVariable("threePhaseMotor.aimc.inertiaStator.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.inertiaStator.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.inertiaStator.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.inertiaStator.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("threePhaseMotor.aimc.fixed.phi0", "Fixed offset angle of housing [rad|deg]",\
 44, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("threePhaseMotor.aimc.fixed.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "threePhaseMotor.aimc.fixed.phi0", 1, 7, 44, 4)
DeclareAlias2("threePhaseMotor.aimc.fixed.flange.tau", "Cut torque in the flange [N.m]",\
 "threePhaseMotor.aimc.tauElectrical", -1, 5, 365, 132)
DeclareAlias2("threePhaseMotor.aimc.friction.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "variableSpeedDrive_ThreePhase.speedSensor.flange.phi", 1, 1, 4, 4)
DeclareVariable("threePhaseMotor.aimc.friction.flange.tau", "Cut torque in the flange [N.m]",\
 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("threePhaseMotor.aimc.friction.support.phi", "Absolute rotation angle of flange [rad|deg]",\
 "threePhaseMotor.aimc.fixed.phi0", 1, 7, 44, 4)
DeclareVariable("threePhaseMotor.aimc.friction.support.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor.aimc.friction.phi", "Angle between shaft and support [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor.aimc.friction.der(phi)", "der(Angle between shaft and support) [rad/s]",\
 "fan.inertia.w", 1, 1, 6, 0)
DeclareVariable("threePhaseMotor.aimc.friction.tau", "Torque [N.m]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareAlias2("threePhaseMotor.aimc.friction.w", "Relative angular velocity of flange and support [rad/s]",\
 "fan.inertia.w", 1, 1, 6, 0)
DeclareVariable("threePhaseMotor.aimc.friction.frictionParameters.PRef", \
"Reference friction losses at wRef [W]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.friction.frictionParameters.wRef", \
"Reference angular velocity that the PRef refer to [rad/s|rev/min]", 1E-60, \
1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.friction.frictionParameters.power_w", \
"Exponent of friction torque w.r.t. angular velocity", 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.friction.frictionParameters.tauRef", \
"Reference friction torque at reference angular velocity [N.m]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.friction.frictionParameters.linear", \
"Linear angular velocity range with respect to reference angular velocity", \
0.001, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.friction.frictionParameters.wLinear", \
"Linear angular velocity range [rad/s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.friction.frictionParameters.tauLinear", \
"Torque corresponding with linear angular velocity range [N.m]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.friction.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("threePhaseMotor.aimc.friction.heatPort.T", "Port temperature [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("threePhaseMotor.aimc.friction.heatPort.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor.aimc.friction.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("threePhaseMotor.aimc.internalSupport.phi", "Absolute rotation angle of flange [rad|deg]",\
 "threePhaseMotor.aimc.fixed.phi0", 1, 7, 44, 1028)
DeclareVariable("threePhaseMotor.aimc.internalSupport.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,2825)
DeclareVariable("threePhaseMotor.aimc.statorCoreParameters.m", "Number of phases (1 for DC, 3 for induction machines) [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("threePhaseMotor.aimc.statorCoreParameters.PRef", \
"Reference core losses at reference inner voltage VRef [W]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.statorCoreParameters.VRef", \
"Reference inner RMS voltage that reference core losses PRef refer to [V]", 100,\
 1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.statorCoreParameters.wRef", \
"Reference angular velocity that reference core losses PRef refer to [rad/s]", \
1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.statorCoreParameters.ratioHysteresis", \
"Ratio of hysteresis losses with respect to the total core losses at VRef and fRef",\
 0.0, 0.0,1.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.statorCoreParameters.GcRef", \
"Reference conductance at reference frequency and voltage [S]", 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("threePhaseMotor.aimc.statorCoreParameters.wMin", "[rad/s]", 0.0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.strayLoadParameters.PRef", \
"Reference stray load losses at IRef and wRef [W]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.strayLoadParameters.IRef", \
"Reference RMS current that PRef refers to [A]", 100, 1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.strayLoadParameters.wRef", \
"Reference angular velocity that PRef refers to [rad/s|rev/min]", 1E-60, 1E-60,\
1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.strayLoadParameters.power_w", \
"Exponent of stray load loss torque w.r.t. angular velocity", 1E-60, 1E-60,\
1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.strayLoadParameters.tauRef", \
"Reference stray load torque at reference angular velocity and reference current [N.m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.powerBalance.powerStator", \
"Electrical power (stator) [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.powerBalance.powerMechanical", \
"Mechanical power [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.powerBalance.powerInertiaStator", \
"Stator inertia power [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.powerBalance.powerInertiaRotor", \
"Rotor inertia power [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.powerBalance.lossPowerTotal", \
"Total loss power [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.powerBalance.lossPowerStatorWinding", \
"Stator copper losses [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.powerBalance.lossPowerStatorCore", \
"Stator core losses [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.powerBalance.lossPowerRotorCore", \
"Rotor core losses [W]", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.powerBalance.lossPowerStrayLoad", \
"Stray load losses [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.powerBalance.lossPowerFriction", \
"Friction losses [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.powerBalance.lossPowerRotorWinding", \
"Rotor copper losses [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.vs[1]", "Stator instantaneous voltages [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.vs[2]", "Stator instantaneous voltages [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.vs[3]", "Stator instantaneous voltages [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor.aimc.is[1]", "Stator instantaneous currents [A]",\
 "inverter2.ac.pin[1].i", -1, 5, 44, 0)
DeclareAlias2("threePhaseMotor.aimc.is[2]", "Stator instantaneous currents [A]",\
 "inverter2.ac.pin[2].i", -1, 5, 46, 0)
DeclareAlias2("threePhaseMotor.aimc.is[3]", "Stator instantaneous currents [A]",\
 "inverter2.ac.pin[3].i", -1, 5, 48, 0)
DeclareVariable("threePhaseMotor.aimc.i_0_s", "Stator zero-sequence current [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.der(i_0_s)", "der(Stator zero-sequence current) [A/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("threePhaseMotor.aimc.idq_ss[1]", "Stator space phasor current / stator fixed frame [A]",\
 "threePhaseMotor.aimc.lssigma.i_[1]", 1, 5, 478, 0)
DeclareAlias2("threePhaseMotor.aimc.idq_ss[2]", "Stator space phasor current / stator fixed frame [A]",\
 "threePhaseMotor.aimc.lssigma.i_[2]", 1, 5, 479, 0)
DeclareState("threePhaseMotor.aimc.idq_sr[1]", "Stator space phasor current / rotor fixed frame [A]",\
 0, 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("threePhaseMotor.aimc.der(idq_sr[1])", "der(Stator space phasor current / rotor fixed frame) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("threePhaseMotor.aimc.idq_sr[2]", "Stator space phasor current / rotor fixed frame [A]",\
 1, 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("threePhaseMotor.aimc.der(idq_sr[2])", "der(Stator space phasor current / rotor fixed frame) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.idq_rs[1]", "Rotor space phasor current / stator fixed frame [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.idq_rs[2]", "Rotor space phasor current / stator fixed frame [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.der(idq_rs[1])", "der(Rotor space phasor current / stator fixed frame) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.der(idq_rs[2])", "der(Rotor space phasor current / stator fixed frame) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("threePhaseMotor.aimc.idq_rr[1]", "Rotor space phasor current / rotor fixed frame [A]",\
 2, 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("threePhaseMotor.aimc.der(idq_rr[1])", "der(Rotor space phasor current / rotor fixed frame) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("threePhaseMotor.aimc.idq_rr[2]", "Rotor space phasor current / rotor fixed frame [A]",\
 3, 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("threePhaseMotor.aimc.der(idq_rr[2])", "der(Rotor space phasor current / rotor fixed frame) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.plug_sp.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("threePhaseMotor.aimc.plug_sp.pin[1].v", "Potential at the pin [V]",\
 "inverter2.ac.pin[1].v", 1, 5, 43, 4)
DeclareAlias2("threePhaseMotor.aimc.plug_sp.pin[1].i", "Current flowing into the pin [A]",\
 "inverter2.ac.pin[1].i", -1, 5, 44, 132)
DeclareAlias2("threePhaseMotor.aimc.plug_sp.pin[2].v", "Potential at the pin [V]",\
 "inverter2.ac.pin[2].v", 1, 5, 45, 4)
DeclareAlias2("threePhaseMotor.aimc.plug_sp.pin[2].i", "Current flowing into the pin [A]",\
 "inverter2.ac.pin[2].i", -1, 5, 46, 132)
DeclareAlias2("threePhaseMotor.aimc.plug_sp.pin[3].v", "Potential at the pin [V]",\
 "inverter2.ac.pin[3].v", 1, 5, 47, 4)
DeclareAlias2("threePhaseMotor.aimc.plug_sp.pin[3].i", "Current flowing into the pin [A]",\
 "inverter2.ac.pin[3].i", -1, 5, 48, 132)
DeclareVariable("threePhaseMotor.aimc.plug_sn.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareVariable("threePhaseMotor.aimc.plug_sn.pin[1].v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("threePhaseMotor.aimc.plug_sn.pin[1].i", "Current flowing into the pin [A]",\
 "inverter2.ac.pin[1].i", 1, 5, 44, 132)
DeclareAlias2("threePhaseMotor.aimc.plug_sn.pin[2].v", "Potential at the pin [V]",\
 "threePhaseMotor.aimc.plug_sn.pin[1].v", 1, 5, 426, 4)
DeclareAlias2("threePhaseMotor.aimc.plug_sn.pin[2].i", "Current flowing into the pin [A]",\
 "inverter2.ac.pin[2].i", 1, 5, 46, 132)
DeclareAlias2("threePhaseMotor.aimc.plug_sn.pin[3].v", "Potential at the pin [V]",\
 "threePhaseMotor.aimc.plug_sn.pin[1].v", 1, 5, 426, 4)
DeclareAlias2("threePhaseMotor.aimc.plug_sn.pin[3].i", "Current flowing into the pin [A]",\
 "inverter2.ac.pin[3].i", 1, 5, 48, 132)
DeclareVariable("threePhaseMotor.aimc.rs.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("threePhaseMotor.aimc.rs.v[1]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.rs.v[2]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.rs.v[3]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor.aimc.rs.i[1]", "Currents flowing into positive polyphase plugs [A]",\
 "inverter2.ac.pin[1].i", -1, 5, 44, 0)
DeclareAlias2("threePhaseMotor.aimc.rs.i[2]", "Currents flowing into positive polyphase plugs [A]",\
 "inverter2.ac.pin[2].i", -1, 5, 46, 0)
DeclareAlias2("threePhaseMotor.aimc.rs.i[3]", "Currents flowing into positive polyphase plugs [A]",\
 "inverter2.ac.pin[3].i", -1, 5, 48, 0)
DeclareVariable("threePhaseMotor.aimc.rs.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("threePhaseMotor.aimc.rs.plug_p.pin[1].v", "Potential at the pin [V]",\
 "inverter2.ac.pin[1].v", 1, 5, 43, 4)
DeclareAlias2("threePhaseMotor.aimc.rs.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 "inverter2.ac.pin[1].i", -1, 5, 44, 132)
DeclareAlias2("threePhaseMotor.aimc.rs.plug_p.pin[2].v", "Potential at the pin [V]",\
 "inverter2.ac.pin[2].v", 1, 5, 45, 4)
DeclareAlias2("threePhaseMotor.aimc.rs.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 "inverter2.ac.pin[2].i", -1, 5, 46, 132)
DeclareAlias2("threePhaseMotor.aimc.rs.plug_p.pin[3].v", "Potential at the pin [V]",\
 "inverter2.ac.pin[3].v", 1, 5, 47, 4)
DeclareAlias2("threePhaseMotor.aimc.rs.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 "inverter2.ac.pin[3].i", -1, 5, 48, 132)
DeclareVariable("threePhaseMotor.aimc.rs.plug_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareVariable("threePhaseMotor.aimc.rs.plug_n.pin[1].v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("threePhaseMotor.aimc.rs.plug_n.pin[1].i", "Current flowing into the pin [A]",\
 "inverter2.ac.pin[1].i", 1, 5, 44, 132)
DeclareVariable("threePhaseMotor.aimc.rs.plug_n.pin[2].v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("threePhaseMotor.aimc.rs.plug_n.pin[2].i", "Current flowing into the pin [A]",\
 "inverter2.ac.pin[2].i", 1, 5, 46, 132)
DeclareVariable("threePhaseMotor.aimc.rs.plug_n.pin[3].v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("threePhaseMotor.aimc.rs.plug_n.pin[3].i", "Current flowing into the pin [A]",\
 "inverter2.ac.pin[3].i", 1, 5, 48, 132)
DeclareVariable("threePhaseMotor.aimc.rs.R[1]", "Resistances R_ref at temperatures T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.rs.R[2]", "Resistances R_ref at temperatures T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.rs.R[3]", "Resistances R_ref at temperatures T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.rs.T_ref[1]", "Reference temperatures [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor.aimc.rs.T_ref[2]", "Reference temperatures [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor.aimc.rs.T_ref[3]", "Reference temperatures [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor.aimc.rs.alpha[1]", "Temperature coefficients of resistances at reference temperatures [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.rs.alpha[2]", "Temperature coefficients of resistances at reference temperatures [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.rs.alpha[3]", "Temperature coefficients of resistances at reference temperatures [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.rs.mh", "Number of heatPorts=number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("threePhaseMotor.aimc.rs.useHeatPort", "=true, if all heat ports are enabled [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("threePhaseMotor.aimc.rs.T[1]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor.aimc.rs.T[2]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor.aimc.rs.T[3]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("threePhaseMotor.aimc.rs.heatPort[1].T", "Port temperature [K|degC]",\
 "threePhaseMotor.aimc.thermalAmbient.constTs.k", 1, 5, 582, 4)
DeclareAlias2("threePhaseMotor.aimc.rs.heatPort[1].Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "threePhaseMotor.aimc.rs.resistor[1].LossPower", -1, 5, 456, 132)
DeclareAlias2("threePhaseMotor.aimc.rs.heatPort[2].T", "Port temperature [K|degC]",\
 "threePhaseMotor.aimc.thermalAmbient.constTs.k", 1, 5, 582, 4)
DeclareAlias2("threePhaseMotor.aimc.rs.heatPort[2].Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "threePhaseMotor.aimc.rs.resistor[2].LossPower", -1, 5, 464, 132)
DeclareAlias2("threePhaseMotor.aimc.rs.heatPort[3].T", "Port temperature [K|degC]",\
 "threePhaseMotor.aimc.thermalAmbient.constTs.k", 1, 5, 582, 4)
DeclareAlias2("threePhaseMotor.aimc.rs.heatPort[3].Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "threePhaseMotor.aimc.rs.resistor[3].LossPower", -1, 5, 472, 132)
DeclareVariable("threePhaseMotor.aimc.rs.resistor[1].R", "Resistance at temperature T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.rs.resistor[1].T_ref", "Reference temperature [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor.aimc.rs.resistor[1].alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.rs.resistor[1].v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor.aimc.rs.resistor[1].i", "Current flowing from pin p to pin n [A]",\
 "inverter2.ac.pin[1].i", -1, 5, 44, 0)
DeclareAlias2("threePhaseMotor.aimc.rs.resistor[1].p.v", "Potential at the pin [V]",\
 "inverter2.ac.pin[1].v", 1, 5, 43, 4)
DeclareAlias2("threePhaseMotor.aimc.rs.resistor[1].p.i", "Current flowing into the pin [A]",\
 "inverter2.ac.pin[1].i", -1, 5, 44, 132)
DeclareAlias2("threePhaseMotor.aimc.rs.resistor[1].n.v", "Potential at the pin [V]",\
 "threePhaseMotor.aimc.rs.plug_n.pin[1].v", 1, 5, 433, 4)
DeclareAlias2("threePhaseMotor.aimc.rs.resistor[1].n.i", "Current flowing into the pin [A]",\
 "inverter2.ac.pin[1].i", 1, 5, 44, 132)
DeclareVariable("threePhaseMotor.aimc.rs.resistor[1].useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("threePhaseMotor.aimc.rs.resistor[1].T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("threePhaseMotor.aimc.rs.resistor[1].heatPort.T", "Port temperature [K|degC]",\
 "threePhaseMotor.aimc.thermalAmbient.constTs.k", 1, 5, 582, 4)
DeclareAlias2("threePhaseMotor.aimc.rs.resistor[1].heatPort.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor.aimc.rs.resistor[1].LossPower", -1, 5, 456, 132)
DeclareVariable("threePhaseMotor.aimc.rs.resistor[1].LossPower", \
"Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor.aimc.rs.resistor[1].T_heatPort", "Temperature of heatPort [K|degC]",\
 "threePhaseMotor.aimc.thermalAmbient.constTs.k", 1, 5, 582, 0)
DeclareVariable("threePhaseMotor.aimc.rs.resistor[1].R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.rs.resistor[2].R", "Resistance at temperature T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.rs.resistor[2].T_ref", "Reference temperature [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor.aimc.rs.resistor[2].alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.rs.resistor[2].v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor.aimc.rs.resistor[2].i", "Current flowing from pin p to pin n [A]",\
 "inverter2.ac.pin[2].i", -1, 5, 46, 0)
DeclareAlias2("threePhaseMotor.aimc.rs.resistor[2].p.v", "Potential at the pin [V]",\
 "inverter2.ac.pin[2].v", 1, 5, 45, 4)
DeclareAlias2("threePhaseMotor.aimc.rs.resistor[2].p.i", "Current flowing into the pin [A]",\
 "inverter2.ac.pin[2].i", -1, 5, 46, 132)
DeclareAlias2("threePhaseMotor.aimc.rs.resistor[2].n.v", "Potential at the pin [V]",\
 "threePhaseMotor.aimc.rs.plug_n.pin[2].v", 1, 5, 434, 4)
DeclareAlias2("threePhaseMotor.aimc.rs.resistor[2].n.i", "Current flowing into the pin [A]",\
 "inverter2.ac.pin[2].i", 1, 5, 46, 132)
DeclareVariable("threePhaseMotor.aimc.rs.resistor[2].useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("threePhaseMotor.aimc.rs.resistor[2].T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("threePhaseMotor.aimc.rs.resistor[2].heatPort.T", "Port temperature [K|degC]",\
 "threePhaseMotor.aimc.thermalAmbient.constTs.k", 1, 5, 582, 4)
DeclareAlias2("threePhaseMotor.aimc.rs.resistor[2].heatPort.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor.aimc.rs.resistor[2].LossPower", -1, 5, 464, 132)
DeclareVariable("threePhaseMotor.aimc.rs.resistor[2].LossPower", \
"Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor.aimc.rs.resistor[2].T_heatPort", "Temperature of heatPort [K|degC]",\
 "threePhaseMotor.aimc.thermalAmbient.constTs.k", 1, 5, 582, 0)
DeclareVariable("threePhaseMotor.aimc.rs.resistor[2].R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.rs.resistor[3].R", "Resistance at temperature T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.rs.resistor[3].T_ref", "Reference temperature [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor.aimc.rs.resistor[3].alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.rs.resistor[3].v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor.aimc.rs.resistor[3].i", "Current flowing from pin p to pin n [A]",\
 "inverter2.ac.pin[3].i", -1, 5, 48, 0)
DeclareAlias2("threePhaseMotor.aimc.rs.resistor[3].p.v", "Potential at the pin [V]",\
 "inverter2.ac.pin[3].v", 1, 5, 47, 4)
DeclareAlias2("threePhaseMotor.aimc.rs.resistor[3].p.i", "Current flowing into the pin [A]",\
 "inverter2.ac.pin[3].i", -1, 5, 48, 132)
DeclareAlias2("threePhaseMotor.aimc.rs.resistor[3].n.v", "Potential at the pin [V]",\
 "threePhaseMotor.aimc.rs.plug_n.pin[3].v", 1, 5, 435, 4)
DeclareAlias2("threePhaseMotor.aimc.rs.resistor[3].n.i", "Current flowing into the pin [A]",\
 "inverter2.ac.pin[3].i", 1, 5, 48, 132)
DeclareVariable("threePhaseMotor.aimc.rs.resistor[3].useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("threePhaseMotor.aimc.rs.resistor[3].T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("threePhaseMotor.aimc.rs.resistor[3].heatPort.T", "Port temperature [K|degC]",\
 "threePhaseMotor.aimc.thermalAmbient.constTs.k", 1, 5, 582, 4)
DeclareAlias2("threePhaseMotor.aimc.rs.resistor[3].heatPort.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor.aimc.rs.resistor[3].LossPower", -1, 5, 472, 132)
DeclareVariable("threePhaseMotor.aimc.rs.resistor[3].LossPower", \
"Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor.aimc.rs.resistor[3].T_heatPort", "Temperature of heatPort [K|degC]",\
 "threePhaseMotor.aimc.thermalAmbient.constTs.k", 1, 5, 582, 0)
DeclareVariable("threePhaseMotor.aimc.rs.resistor[3].R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.lssigma.L[1]", "Inductance of both axes [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.lssigma.L[2]", "Inductance of both axes [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.lssigma.v_[1]", "[V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.lssigma.v_[2]", "[V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.lssigma.i_[1]", "[A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.lssigma.i_[2]", "[A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.lssigma.der(i_[1])", "[A/s]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.lssigma.der(i_[2])", "[A/s]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.lssigma.spacePhasor_a.v_[1]", \
"1=real, 2=imaginary part [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareVariable("threePhaseMotor.aimc.lssigma.spacePhasor_a.v_[2]", \
"1=real, 2=imaginary part [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("threePhaseMotor.aimc.lssigma.spacePhasor_a.i_[1]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor.aimc.lssigma.i_[1]", 1, 5, 478,\
 132)
DeclareAlias2("threePhaseMotor.aimc.lssigma.spacePhasor_a.i_[2]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor.aimc.lssigma.i_[2]", 1, 5, 479,\
 132)
DeclareAlias2("threePhaseMotor.aimc.lssigma.spacePhasor_b.v_[1]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor.aimc.airGapS.der(psi_ms[1])", 1,\
 5, 608, 4)
DeclareAlias2("threePhaseMotor.aimc.lssigma.spacePhasor_b.v_[2]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor.aimc.airGapS.der(psi_ms[2])", 1,\
 5, 609, 4)
DeclareAlias2("threePhaseMotor.aimc.lssigma.spacePhasor_b.i_[1]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor.aimc.lssigma.i_[1]", -1, 5, 478,\
 132)
DeclareAlias2("threePhaseMotor.aimc.lssigma.spacePhasor_b.i_[2]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor.aimc.lssigma.i_[2]", -1, 5, 479,\
 132)
DeclareVariable("threePhaseMotor.aimc.lszero.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.lszero.i", "Current flowing from pin p to pin n [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.lszero.der(i)", "der(Current flowing from pin p to pin n) [A/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.lszero.p.v", "Potential at the pin [V]", \
0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("threePhaseMotor.aimc.lszero.p.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor.aimc.lszero.n.v", "Potential at the pin [V]", 0,\
 0.0,0.0,0.0,0,521)
DeclareVariable("threePhaseMotor.aimc.lszero.n.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor.aimc.lszero.L", "Inductance [H]", 1, 0.0,0.0,\
0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.statorCore.coreParameters.m", \
"Number of phases (1 for DC, 3 for induction machines) [:#(type=Integer)]", 3, \
0.0,0.0,0.0,0,517)
DeclareVariable("threePhaseMotor.aimc.statorCore.coreParameters.PRef", \
"Reference core losses at reference inner voltage VRef [W]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.statorCore.coreParameters.VRef", \
"Reference inner RMS voltage that reference core losses PRef refer to [V]", \
1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.statorCore.coreParameters.wRef", \
"Reference angular velocity that reference core losses PRef refer to [rad/s]", \
1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.statorCore.coreParameters.ratioHysteresis",\
 "Ratio of hysteresis losses with respect to the total core losses at VRef and fRef",\
 0.0, 0.0,1.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.statorCore.coreParameters.GcRef", \
"Reference conductance at reference frequency and voltage [S]", 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("threePhaseMotor.aimc.statorCore.coreParameters.wMin", "[rad/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.statorCore.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("threePhaseMotor.aimc.statorCore.turnsRatio", "Effective number of stator turns / effective number of rotor turns (if used as rotor core)",\
 1, 1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.statorCore.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("threePhaseMotor.aimc.statorCore.heatPort.T", "Port temperature [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("threePhaseMotor.aimc.statorCore.heatPort.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor.aimc.statorCore.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("threePhaseMotor.aimc.statorCore.spacePhasor.v_[1]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor.aimc.lssigma.spacePhasor_a.v_[1]", 1,\
 5, 482, 4)
DeclareAlias2("threePhaseMotor.aimc.statorCore.spacePhasor.v_[2]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor.aimc.lssigma.spacePhasor_a.v_[2]", 1,\
 5, 483, 4)
DeclareVariable("threePhaseMotor.aimc.statorCore.spacePhasor.i_[1]", \
"1=real, 2=imaginary part [A]", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor.aimc.statorCore.spacePhasor.i_[2]", \
"1=real, 2=imaginary part [A]", 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("threePhaseMotor.aimc.statorCore.w", "Remagnetization angular velocity [rad/s]",\
 "threePhaseMotor.aimc.statorCoreParameters.wRef", 1, 5, 395, 0)
DeclareVariable("threePhaseMotor.aimc.statorCore.Gc", "Variable core loss conductance [S]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.statorCore.wLimit", "Limited angular velocity [rad/s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor.aimc.spacePhasorS.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("threePhaseMotor.aimc.spacePhasorS.turnsRatio", "Turns ratio [1]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.spacePhasorS.v[1]", "Instantaneous phase voltages [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.spacePhasorS.v[2]", "Instantaneous phase voltages [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.spacePhasorS.v[3]", "Instantaneous phase voltages [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor.aimc.spacePhasorS.i[1]", "Instantaneous phase currents [A]",\
 "inverter2.ac.pin[1].i", -1, 5, 44, 0)
DeclareAlias2("threePhaseMotor.aimc.spacePhasorS.i[2]", "Instantaneous phase currents [A]",\
 "inverter2.ac.pin[2].i", -1, 5, 46, 0)
DeclareAlias2("threePhaseMotor.aimc.spacePhasorS.i[3]", "Instantaneous phase currents [A]",\
 "inverter2.ac.pin[3].i", -1, 5, 48, 0)
DeclareVariable("threePhaseMotor.aimc.spacePhasorS.TransformationMatrix[1, 1]", \
"[1]", 0.6666666666666666, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor.aimc.spacePhasorS.TransformationMatrix[1, 2]", \
"[1]", -0.33333333333333315, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor.aimc.spacePhasorS.TransformationMatrix[1, 3]", \
"[1]", -0.3333333333333336, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor.aimc.spacePhasorS.TransformationMatrix[2, 1]", \
"[1]", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor.aimc.spacePhasorS.TransformationMatrix[2, 2]", \
"[1]", 0.5773502691896257, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor.aimc.spacePhasorS.TransformationMatrix[2, 3]", \
"[1]", -0.5773502691896255, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor.aimc.spacePhasorS.InverseTransformation[1, 1]",\
 "", 1.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor.aimc.spacePhasorS.InverseTransformation[1, 2]",\
 "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor.aimc.spacePhasorS.InverseTransformation[2, 1]",\
 "", -0.4999999999999998, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor.aimc.spacePhasorS.InverseTransformation[2, 2]",\
 "", 0.8660254037844387, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor.aimc.spacePhasorS.InverseTransformation[3, 1]",\
 "", -0.5000000000000004, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor.aimc.spacePhasorS.InverseTransformation[3, 2]",\
 "", -0.8660254037844384, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor.aimc.spacePhasorS.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("threePhaseMotor.aimc.spacePhasorS.plug_p.pin[1].v", \
"Potential at the pin [V]", "threePhaseMotor.aimc.rs.plug_n.pin[1].v", 1, 5, 433,\
 4)
DeclareAlias2("threePhaseMotor.aimc.spacePhasorS.plug_p.pin[1].i", \
"Current flowing into the pin [A]", "inverter2.ac.pin[1].i", -1, 5, 44, 132)
DeclareAlias2("threePhaseMotor.aimc.spacePhasorS.plug_p.pin[2].v", \
"Potential at the pin [V]", "threePhaseMotor.aimc.rs.plug_n.pin[2].v", 1, 5, 434,\
 4)
DeclareAlias2("threePhaseMotor.aimc.spacePhasorS.plug_p.pin[2].i", \
"Current flowing into the pin [A]", "inverter2.ac.pin[2].i", -1, 5, 46, 132)
DeclareAlias2("threePhaseMotor.aimc.spacePhasorS.plug_p.pin[3].v", \
"Potential at the pin [V]", "threePhaseMotor.aimc.rs.plug_n.pin[3].v", 1, 5, 435,\
 4)
DeclareAlias2("threePhaseMotor.aimc.spacePhasorS.plug_p.pin[3].i", \
"Current flowing into the pin [A]", "inverter2.ac.pin[3].i", -1, 5, 48, 132)
DeclareVariable("threePhaseMotor.aimc.spacePhasorS.plug_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("threePhaseMotor.aimc.spacePhasorS.plug_n.pin[1].v", \
"Potential at the pin [V]", "threePhaseMotor.aimc.plug_sn.pin[1].v", 1, 5, 426, 4)
DeclareAlias2("threePhaseMotor.aimc.spacePhasorS.plug_n.pin[1].i", \
"Current flowing into the pin [A]", "inverter2.ac.pin[1].i", 1, 5, 44, 132)
DeclareAlias2("threePhaseMotor.aimc.spacePhasorS.plug_n.pin[2].v", \
"Potential at the pin [V]", "threePhaseMotor.aimc.plug_sn.pin[1].v", 1, 5, 426, 4)
DeclareAlias2("threePhaseMotor.aimc.spacePhasorS.plug_n.pin[2].i", \
"Current flowing into the pin [A]", "inverter2.ac.pin[2].i", 1, 5, 46, 132)
DeclareAlias2("threePhaseMotor.aimc.spacePhasorS.plug_n.pin[3].v", \
"Potential at the pin [V]", "threePhaseMotor.aimc.plug_sn.pin[1].v", 1, 5, 426, 4)
DeclareAlias2("threePhaseMotor.aimc.spacePhasorS.plug_n.pin[3].i", \
"Current flowing into the pin [A]", "inverter2.ac.pin[3].i", 1, 5, 48, 132)
DeclareVariable("threePhaseMotor.aimc.spacePhasorS.zero.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("threePhaseMotor.aimc.spacePhasorS.zero.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor.aimc.spacePhasorS.ground.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("threePhaseMotor.aimc.spacePhasorS.ground.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("threePhaseMotor.aimc.spacePhasorS.spacePhasor.v_[1]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor.aimc.lssigma.spacePhasor_a.v_[1]", 1,\
 5, 482, 4)
DeclareAlias2("threePhaseMotor.aimc.spacePhasorS.spacePhasor.v_[2]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor.aimc.lssigma.spacePhasor_a.v_[2]", 1,\
 5, 483, 4)
DeclareAlias2("threePhaseMotor.aimc.spacePhasorS.spacePhasor.i_[1]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor.aimc.lssigma.i_[1]", -1, 5, 478,\
 132)
DeclareAlias2("threePhaseMotor.aimc.spacePhasorS.spacePhasor.i_[2]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor.aimc.lssigma.i_[2]", -1, 5, 479,\
 132)
DeclareVariable("threePhaseMotor.aimc.strayLoad.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("threePhaseMotor.aimc.strayLoad.v[1]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.strayLoad.v[2]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.strayLoad.v[3]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("threePhaseMotor.aimc.strayLoad.i[1]", "Currents flowing into positive polyphase plugs [A]",\
 "inverter2.ac.pin[1].i", -1, 5, 44, 0)
DeclareAlias2("threePhaseMotor.aimc.strayLoad.i[2]", "Currents flowing into positive polyphase plugs [A]",\
 "inverter2.ac.pin[2].i", -1, 5, 46, 0)
DeclareAlias2("threePhaseMotor.aimc.strayLoad.i[3]", "Currents flowing into positive polyphase plugs [A]",\
 "inverter2.ac.pin[3].i", -1, 5, 48, 0)
DeclareVariable("threePhaseMotor.aimc.strayLoad.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("threePhaseMotor.aimc.strayLoad.plug_p.pin[1].v", "Potential at the pin [V]",\
 "inverter2.ac.pin[1].v", 1, 5, 43, 4)
DeclareAlias2("threePhaseMotor.aimc.strayLoad.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 "inverter2.ac.pin[1].i", -1, 5, 44, 132)
DeclareAlias2("threePhaseMotor.aimc.strayLoad.plug_p.pin[2].v", "Potential at the pin [V]",\
 "inverter2.ac.pin[2].v", 1, 5, 45, 4)
DeclareAlias2("threePhaseMotor.aimc.strayLoad.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 "inverter2.ac.pin[2].i", -1, 5, 46, 132)
DeclareAlias2("threePhaseMotor.aimc.strayLoad.plug_p.pin[3].v", "Potential at the pin [V]",\
 "inverter2.ac.pin[3].v", 1, 5, 47, 4)
DeclareAlias2("threePhaseMotor.aimc.strayLoad.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 "inverter2.ac.pin[3].i", -1, 5, 48, 132)
DeclareVariable("threePhaseMotor.aimc.strayLoad.plug_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("threePhaseMotor.aimc.strayLoad.plug_n.pin[1].v", "Potential at the pin [V]",\
 "inverter2.ac.pin[1].v", 1, 5, 43, 4)
DeclareAlias2("threePhaseMotor.aimc.strayLoad.plug_n.pin[1].i", "Current flowing into the pin [A]",\
 "inverter2.ac.pin[1].i", 1, 5, 44, 132)
DeclareAlias2("threePhaseMotor.aimc.strayLoad.plug_n.pin[2].v", "Potential at the pin [V]",\
 "inverter2.ac.pin[2].v", 1, 5, 45, 4)
DeclareAlias2("threePhaseMotor.aimc.strayLoad.plug_n.pin[2].i", "Current flowing into the pin [A]",\
 "inverter2.ac.pin[2].i", 1, 5, 46, 132)
DeclareAlias2("threePhaseMotor.aimc.strayLoad.plug_n.pin[3].v", "Potential at the pin [V]",\
 "inverter2.ac.pin[3].v", 1, 5, 47, 4)
DeclareAlias2("threePhaseMotor.aimc.strayLoad.plug_n.pin[3].i", "Current flowing into the pin [A]",\
 "inverter2.ac.pin[3].i", 1, 5, 48, 132)
DeclareAlias2("threePhaseMotor.aimc.strayLoad.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "variableSpeedDrive_ThreePhase.speedSensor.flange.phi", 1, 1, 4, 4)
DeclareVariable("threePhaseMotor.aimc.strayLoad.flange.tau", "Cut torque in the flange [N.m]",\
 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("threePhaseMotor.aimc.strayLoad.support.phi", "Absolute rotation angle of flange [rad|deg]",\
 "threePhaseMotor.aimc.fixed.phi0", 1, 7, 44, 4)
DeclareVariable("threePhaseMotor.aimc.strayLoad.support.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor.aimc.strayLoad.phi", "Angle between shaft and support [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor.aimc.strayLoad.der(phi)", "der(Angle between shaft and support) [rad/s]",\
 "fan.inertia.w", 1, 1, 6, 0)
DeclareVariable("threePhaseMotor.aimc.strayLoad.tau", "Torque [N.m]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareAlias2("threePhaseMotor.aimc.strayLoad.w", "Relative angular velocity of flange and support [rad/s]",\
 "fan.inertia.w", 1, 1, 6, 0)
DeclareVariable("threePhaseMotor.aimc.strayLoad.strayLoadParameters.PRef", \
"Reference stray load losses at IRef and wRef [W]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.strayLoad.strayLoadParameters.IRef", \
"Reference RMS current that PRef refers to [A]", 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.strayLoad.strayLoadParameters.wRef", \
"Reference angular velocity that PRef refers to [rad/s|rev/min]", 1E-60, 1E-60,\
1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.strayLoad.strayLoadParameters.power_w", \
"Exponent of stray load loss torque w.r.t. angular velocity", 1E-60, 1E-60,\
1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.strayLoad.strayLoadParameters.tauRef", \
"Reference stray load torque at reference angular velocity and reference current [N.m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.strayLoad.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("threePhaseMotor.aimc.strayLoad.heatPort.T", "Port temperature [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("threePhaseMotor.aimc.strayLoad.heatPort.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor.aimc.strayLoad.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.strayLoad.iRMS", "[A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.thermalAmbient.m", "Number of stator phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("threePhaseMotor.aimc.thermalAmbient.useTemperatureInputs", \
"If true, temperature inputs are used; else, temperatures are constant [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("threePhaseMotor.aimc.thermalAmbient.TDefault", "Default temperature [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor.aimc.thermalAmbient.Ts", "Temperature of stator windings [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor.aimc.thermalAmbient.Q_flowStatorWinding", \
"Heat flow rate of stator windings [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.thermalAmbient.Q_flowStatorCore", \
"Heat flow rate of stator core losses [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.thermalAmbient.Q_flowRotorCore", \
"Heat flow rate of stator core losses [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.thermalAmbient.Q_flowStrayLoad", \
"Heat flow rate of stray load losses [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.thermalAmbient.Q_flowFriction", \
"Heat flow rate of friction losses [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.thermalAmbient.thermalPort.m", \
"Number of stator phases [:#(type=Integer)]", 3, 0.0,0.0,0.0,0,525)
DeclareAlias2("threePhaseMotor.aimc.thermalAmbient.thermalPort.heatPortStatorWinding[1].T",\
 "Port temperature [K|degC]", "threePhaseMotor.aimc.thermalAmbient.constTs.k", 1,\
 5, 582, 4)
DeclareAlias2("threePhaseMotor.aimc.thermalAmbient.thermalPort.heatPortStatorWinding[1].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor.aimc.rs.resistor[1].LossPower", 1, 5, 456, 132)
DeclareAlias2("threePhaseMotor.aimc.thermalAmbient.thermalPort.heatPortStatorWinding[2].T",\
 "Port temperature [K|degC]", "threePhaseMotor.aimc.thermalAmbient.constTs.k", 1,\
 5, 582, 4)
DeclareAlias2("threePhaseMotor.aimc.thermalAmbient.thermalPort.heatPortStatorWinding[2].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor.aimc.rs.resistor[2].LossPower", 1, 5, 464, 132)
DeclareAlias2("threePhaseMotor.aimc.thermalAmbient.thermalPort.heatPortStatorWinding[3].T",\
 "Port temperature [K|degC]", "threePhaseMotor.aimc.thermalAmbient.constTs.k", 1,\
 5, 582, 4)
DeclareAlias2("threePhaseMotor.aimc.thermalAmbient.thermalPort.heatPortStatorWinding[3].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor.aimc.rs.resistor[3].LossPower", 1, 5, 472, 132)
DeclareVariable("threePhaseMotor.aimc.thermalAmbient.thermalPort.heatPortStatorCore.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("threePhaseMotor.aimc.thermalAmbient.thermalPort.heatPortStatorCore.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor.aimc.thermalAmbient.thermalPort.heatPortRotorCore.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("threePhaseMotor.aimc.thermalAmbient.thermalPort.heatPortRotorCore.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor.aimc.thermalAmbient.thermalPort.heatPortStrayLoad.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("threePhaseMotor.aimc.thermalAmbient.thermalPort.heatPortStrayLoad.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor.aimc.thermalAmbient.thermalPort.heatPortFriction.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("threePhaseMotor.aimc.thermalAmbient.thermalPort.heatPortFriction.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareAlias2("threePhaseMotor.aimc.thermalAmbient.thermalPort.heatPortRotorWinding.T",\
 "Port temperature [K|degC]", "threePhaseMotor.aimc.thermalAmbient.constTr.k", 1,\
 5, 586, 4)
DeclareAlias2("threePhaseMotor.aimc.thermalAmbient.thermalPort.heatPortRotorWinding.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor.aimc.powerBalance.lossPowerRotorWinding", 1, 5, 414, 132)
DeclareAlias2("threePhaseMotor.aimc.thermalAmbient.temperatureStatorWinding.port.T",\
 "Port temperature [K|degC]", "threePhaseMotor.aimc.thermalAmbient.constTs.k", 1,\
 5, 582, 4)
DeclareAlias2("threePhaseMotor.aimc.thermalAmbient.temperatureStatorWinding.port.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor.aimc.thermalAmbient.Q_flowStatorWinding", 1, 5, 556, 132)
DeclareAlias2("threePhaseMotor.aimc.thermalAmbient.temperatureStatorWinding.T", \
"[K]", "threePhaseMotor.aimc.thermalAmbient.constTs.k", 1, 5, 582, 0)
DeclareVariable("threePhaseMotor.aimc.thermalAmbient.temperatureStatorCore.T", \
"Fixed temperature at port [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor.aimc.thermalAmbient.temperatureStatorCore.port.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("threePhaseMotor.aimc.thermalAmbient.temperatureStatorCore.port.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor.aimc.thermalAmbient.temperatureRotorCore.T", \
"Fixed temperature at port [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor.aimc.thermalAmbient.temperatureRotorCore.port.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("threePhaseMotor.aimc.thermalAmbient.temperatureRotorCore.port.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor.aimc.thermalAmbient.temperatureStrayLoad.T", \
"Fixed temperature at port [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor.aimc.thermalAmbient.temperatureStrayLoad.port.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("threePhaseMotor.aimc.thermalAmbient.temperatureStrayLoad.port.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor.aimc.thermalAmbient.temperatureFriction.T", \
"Fixed temperature at port [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor.aimc.thermalAmbient.temperatureFriction.port.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("threePhaseMotor.aimc.thermalAmbient.temperatureFriction.port.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor.aimc.thermalAmbient.constTs.k", \
"Constant output value [K]", 1, 0.0,1E+100,300.0,0,513)
DeclareAlias2("threePhaseMotor.aimc.thermalAmbient.constTs.y", "Connector of Real output signal [K]",\
 "threePhaseMotor.aimc.thermalAmbient.constTs.k", 1, 5, 582, 0)
DeclareVariable("threePhaseMotor.aimc.thermalAmbient.thermalCollectorStator.m", \
"Number of collected heat flows [:#(type=Integer)]", 3, 1.0,1E+100,0.0,0,517)
DeclareAlias2("threePhaseMotor.aimc.thermalAmbient.thermalCollectorStator.port_a[1].T",\
 "Port temperature [K|degC]", "threePhaseMotor.aimc.thermalAmbient.constTs.k", 1,\
 5, 582, 4)
DeclareAlias2("threePhaseMotor.aimc.thermalAmbient.thermalCollectorStator.port_a[1].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor.aimc.rs.resistor[1].LossPower", 1, 5, 456, 132)
DeclareAlias2("threePhaseMotor.aimc.thermalAmbient.thermalCollectorStator.port_a[2].T",\
 "Port temperature [K|degC]", "threePhaseMotor.aimc.thermalAmbient.constTs.k", 1,\
 5, 582, 4)
DeclareAlias2("threePhaseMotor.aimc.thermalAmbient.thermalCollectorStator.port_a[2].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor.aimc.rs.resistor[2].LossPower", 1, 5, 464, 132)
DeclareAlias2("threePhaseMotor.aimc.thermalAmbient.thermalCollectorStator.port_a[3].T",\
 "Port temperature [K|degC]", "threePhaseMotor.aimc.thermalAmbient.constTs.k", 1,\
 5, 582, 4)
DeclareAlias2("threePhaseMotor.aimc.thermalAmbient.thermalCollectorStator.port_a[3].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor.aimc.rs.resistor[3].LossPower", 1, 5, 472, 132)
DeclareAlias2("threePhaseMotor.aimc.thermalAmbient.thermalCollectorStator.port_b.T",\
 "Port temperature [K|degC]", "threePhaseMotor.aimc.thermalAmbient.constTs.k", 1,\
 5, 582, 4)
DeclareAlias2("threePhaseMotor.aimc.thermalAmbient.thermalCollectorStator.port_b.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor.aimc.thermalAmbient.Q_flowStatorWinding", -1, 5, 556, 132)
DeclareVariable("threePhaseMotor.aimc.thermalAmbient.Tr", "Temperature of rotor (squirrel cage) [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("threePhaseMotor.aimc.thermalAmbient.Q_flowRotorWinding", \
"Heat flow rate of rotor (squirrel cage) [W]", "threePhaseMotor.aimc.powerBalance.lossPowerRotorWinding", 1,\
 5, 414, 0)
DeclareVariable("threePhaseMotor.aimc.thermalAmbient.Q_flowTotal", "[W]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor.aimc.thermalAmbient.temperatureRotorWinding.port.T",\
 "Port temperature [K|degC]", "threePhaseMotor.aimc.thermalAmbient.constTr.k", 1,\
 5, 586, 4)
DeclareAlias2("threePhaseMotor.aimc.thermalAmbient.temperatureRotorWinding.port.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor.aimc.powerBalance.lossPowerRotorWinding", 1, 5, 414, 132)
DeclareAlias2("threePhaseMotor.aimc.thermalAmbient.temperatureRotorWinding.T", \
"[K]", "threePhaseMotor.aimc.thermalAmbient.constTr.k", 1, 5, 586, 0)
DeclareVariable("threePhaseMotor.aimc.thermalAmbient.constTr.k", \
"Constant output value [K]", 1, 0.0,1E+100,300.0,0,513)
DeclareAlias2("threePhaseMotor.aimc.thermalAmbient.constTr.y", "Connector of Real output signal [K]",\
 "threePhaseMotor.aimc.thermalAmbient.constTr.k", 1, 5, 586, 0)
DeclareVariable("threePhaseMotor.aimc.pi", "", 3.141592653589793, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor.aimc.internalThermalPort.m", "Number of stator phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,2573)
DeclareAlias2("threePhaseMotor.aimc.internalThermalPort.heatPortStatorWinding[1].T",\
 "Port temperature [K|degC]", "threePhaseMotor.aimc.thermalAmbient.constTs.k", 1,\
 5, 582, 1028)
DeclareVariable("threePhaseMotor.aimc.internalThermalPort.heatPortStatorWinding[1].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareAlias2("threePhaseMotor.aimc.internalThermalPort.heatPortStatorWinding[2].T",\
 "Port temperature [K|degC]", "threePhaseMotor.aimc.thermalAmbient.constTs.k", 1,\
 5, 582, 1028)
DeclareVariable("threePhaseMotor.aimc.internalThermalPort.heatPortStatorWinding[2].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareAlias2("threePhaseMotor.aimc.internalThermalPort.heatPortStatorWinding[3].T",\
 "Port temperature [K|degC]", "threePhaseMotor.aimc.thermalAmbient.constTs.k", 1,\
 5, 582, 1028)
DeclareVariable("threePhaseMotor.aimc.internalThermalPort.heatPortStatorWinding[3].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareVariable("threePhaseMotor.aimc.internalThermalPort.heatPortStatorCore.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,2569)
DeclareVariable("threePhaseMotor.aimc.internalThermalPort.heatPortStatorCore.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareVariable("threePhaseMotor.aimc.internalThermalPort.heatPortRotorCore.T", \
"Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,2569)
DeclareVariable("threePhaseMotor.aimc.internalThermalPort.heatPortRotorCore.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareVariable("threePhaseMotor.aimc.internalThermalPort.heatPortStrayLoad.T", \
"Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,2569)
DeclareVariable("threePhaseMotor.aimc.internalThermalPort.heatPortStrayLoad.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareVariable("threePhaseMotor.aimc.internalThermalPort.heatPortFriction.T", \
"Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,2569)
DeclareVariable("threePhaseMotor.aimc.internalThermalPort.heatPortFriction.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareAlias2("threePhaseMotor.aimc.internalThermalPort.heatPortRotorWinding.T",\
 "Port temperature [K|degC]", "threePhaseMotor.aimc.thermalAmbient.constTr.k", 1,\
 5, 586, 1028)
DeclareVariable("threePhaseMotor.aimc.internalThermalPort.heatPortRotorWinding.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareAlias2("threePhaseMotor.aimc.ir[1]", "Rotor cage currents [A]", \
"threePhaseMotor.aimc.idq_rr[1]", 1, 1, 2, 0)
DeclareAlias2("threePhaseMotor.aimc.ir[2]", "Rotor cage currents [A]", \
"threePhaseMotor.aimc.idq_rr[2]", 1, 1, 3, 0)
DeclareVariable("threePhaseMotor.aimc.airGapS.Lm", "Main field inductance [H]", \
0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.airGapS.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("threePhaseMotor.aimc.airGapS.p", "Number of pole pairs [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareAlias2("threePhaseMotor.aimc.airGapS.tauElectrical", "[N.m]", \
"threePhaseMotor.aimc.tauElectrical", 1, 5, 365, 0)
DeclareVariable("threePhaseMotor.aimc.airGapS.gamma", "Rotor displacement angle [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.airGapS.der(gamma)", "der(Rotor displacement angle) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor.aimc.airGapS.i_ss[1]", "Stator current space phasor with respect to the stator fixed frame [A]",\
 "threePhaseMotor.aimc.lssigma.i_[1]", 1, 5, 478, 0)
DeclareAlias2("threePhaseMotor.aimc.airGapS.i_ss[2]", "Stator current space phasor with respect to the stator fixed frame [A]",\
 "threePhaseMotor.aimc.lssigma.i_[2]", 1, 5, 479, 0)
DeclareAlias2("threePhaseMotor.aimc.airGapS.i_sr[1]", "Stator current space phasor with respect to the rotor fixed frame [A]",\
 "threePhaseMotor.aimc.idq_sr[1]", 1, 1, 0, 0)
DeclareAlias2("threePhaseMotor.aimc.airGapS.i_sr[2]", "Stator current space phasor with respect to the rotor fixed frame [A]",\
 "threePhaseMotor.aimc.idq_sr[2]", 1, 1, 1, 0)
DeclareAlias2("threePhaseMotor.aimc.airGapS.i_rs[1]", "Rotor current space phasor with respect to the stator fixed frame [A]",\
 "threePhaseMotor.aimc.idq_rs[1]", 1, 5, 420, 0)
DeclareAlias2("threePhaseMotor.aimc.airGapS.i_rs[2]", "Rotor current space phasor with respect to the stator fixed frame [A]",\
 "threePhaseMotor.aimc.idq_rs[2]", 1, 5, 421, 0)
DeclareAlias2("threePhaseMotor.aimc.airGapS.i_rr[1]", "Rotor current space phasor with respect to the rotor fixed frame [A]",\
 "threePhaseMotor.aimc.idq_rr[1]", 1, 1, 2, 0)
DeclareAlias2("threePhaseMotor.aimc.airGapS.i_rr[2]", "Rotor current space phasor with respect to the rotor fixed frame [A]",\
 "threePhaseMotor.aimc.idq_rr[2]", 1, 1, 3, 0)
DeclareVariable("threePhaseMotor.aimc.airGapS.psi_ms[1]", "Magnetizing flux phasor with respect to the stator fixed frame [Wb]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.airGapS.psi_ms[2]", "Magnetizing flux phasor with respect to the stator fixed frame [Wb]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.airGapS.der(psi_ms[1])", "der(Magnetizing flux phasor with respect to the stator fixed frame) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.airGapS.der(psi_ms[2])", "der(Magnetizing flux phasor with respect to the stator fixed frame) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.airGapS.psi_mr[1]", "Magnetizing flux phasor with respect to the rotor fixed frame [Wb]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.airGapS.psi_mr[2]", "Magnetizing flux phasor with respect to the rotor fixed frame [Wb]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.airGapS.der(psi_mr[1])", "der(Magnetizing flux phasor with respect to the rotor fixed frame) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.airGapS.der(psi_mr[2])", "der(Magnetizing flux phasor with respect to the rotor fixed frame) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.airGapS.RotationMatrix[1, 1]", \
"Matrix of rotation from rotor to stator [1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.airGapS.RotationMatrix[1, 2]", \
"Matrix of rotation from rotor to stator [1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.airGapS.RotationMatrix[2, 1]", \
"Matrix of rotation from rotor to stator [1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.airGapS.RotationMatrix[2, 2]", \
"Matrix of rotation from rotor to stator [1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.airGapS.der(RotationMatrix[1, 1])", \
"der(Matrix of rotation from rotor to stator) [s-1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.airGapS.der(RotationMatrix[1, 2])", \
"der(Matrix of rotation from rotor to stator) [s-1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.airGapS.der(RotationMatrix[2, 1])", \
"der(Matrix of rotation from rotor to stator) [s-1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.airGapS.der(RotationMatrix[2, 2])", \
"der(Matrix of rotation from rotor to stator) [s-1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor.aimc.airGapS.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "variableSpeedDrive_ThreePhase.speedSensor.flange.phi", 1, 1, 4, 4)
DeclareAlias2("threePhaseMotor.aimc.airGapS.flange.tau", "Cut torque in the flange [N.m]",\
 "threePhaseMotor.aimc.tauElectrical", -1, 5, 365, 132)
DeclareAlias2("threePhaseMotor.aimc.airGapS.support.phi", "Absolute rotation angle of flange [rad|deg]",\
 "threePhaseMotor.aimc.fixed.phi0", 1, 7, 44, 4)
DeclareAlias2("threePhaseMotor.aimc.airGapS.support.tau", "Cut torque in the flange [N.m]",\
 "threePhaseMotor.aimc.tauElectrical", 1, 5, 365, 132)
DeclareAlias2("threePhaseMotor.aimc.airGapS.spacePhasor_s.v_[1]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor.aimc.airGapS.der(psi_ms[1])", 1,\
 5, 608, 4)
DeclareAlias2("threePhaseMotor.aimc.airGapS.spacePhasor_s.v_[2]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor.aimc.airGapS.der(psi_ms[2])", 1,\
 5, 609, 4)
DeclareAlias2("threePhaseMotor.aimc.airGapS.spacePhasor_s.i_[1]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor.aimc.lssigma.i_[1]", 1, 5, 478,\
 132)
DeclareAlias2("threePhaseMotor.aimc.airGapS.spacePhasor_s.i_[2]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor.aimc.lssigma.i_[2]", 1, 5, 479,\
 132)
DeclareAlias2("threePhaseMotor.aimc.airGapS.spacePhasor_r.v_[1]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor.aimc.airGapS.der(psi_mr[1])", 1,\
 5, 612, 4)
DeclareAlias2("threePhaseMotor.aimc.airGapS.spacePhasor_r.v_[2]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor.aimc.airGapS.der(psi_mr[2])", 1,\
 5, 613, 4)
DeclareAlias2("threePhaseMotor.aimc.airGapS.spacePhasor_r.i_[1]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor.aimc.idq_rr[1]", 1, 1, 2, 132)
DeclareAlias2("threePhaseMotor.aimc.airGapS.spacePhasor_r.i_[2]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor.aimc.idq_rr[2]", 1, 1, 3, 132)
DeclareVariable("threePhaseMotor.aimc.airGapS.i_ms[1]", "Magnetizing current space phasor with respect to the stator fixed frame [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.airGapS.i_ms[2]", "Magnetizing current space phasor with respect to the stator fixed frame [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.airGapS.der(i_ms[1])", "der(Magnetizing current space phasor with respect to the stator fixed frame) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.airGapS.der(i_ms[2])", "der(Magnetizing current space phasor with respect to the stator fixed frame) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor.aimc.airGapS.L[1, 1]", "Inductance matrix [H]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor.aimc.airGapS.L[1, 2]", "Inductance matrix [H]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor.aimc.airGapS.L[2, 1]", "Inductance matrix [H]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor.aimc.airGapS.L[2, 2]", "Inductance matrix [H]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor.aimc.Lm", "Stator main field inductance per phase [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.Lrsigma", "Rotor stray inductance per phase (equivalent three phase winding) [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.Rr", "Rotor resistance per phase (equivalent three phase winding) at TRef [Ohm]",\
 0.04, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.TrRef", "Reference temperature of rotor resistance [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor.aimc.alpha20r", "Temperature coefficient of rotor resistance at 20 degC [1/K]",\
 0, 0.0,0.0,0.0,0,513)
DeclareParameter("threePhaseMotor.aimc.TrOperational", "Operational temperature of rotor resistance [K|degC]",\
 45, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("threePhaseMotor.aimc.squirrelCageR.Lrsigma", "Rotor stray inductance per phase translated to stator [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.squirrelCageR.Rr", "Rotor resistance per phase translated to stator at T_ref [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.squirrelCageR.T_ref", "Reference temperature [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor.aimc.squirrelCageR.alpha", "Temperature coefficient of resistance at T_ref [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimc.squirrelCageR.useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("threePhaseMotor.aimc.squirrelCageR.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("threePhaseMotor.aimc.squirrelCageR.heatPort.T", "Port temperature [K|degC]",\
 "threePhaseMotor.aimc.thermalAmbient.constTr.k", 1, 5, 586, 4)
DeclareAlias2("threePhaseMotor.aimc.squirrelCageR.heatPort.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor.aimc.powerBalance.lossPowerRotorWinding", -1, 5, 414, 132)
DeclareAlias2("threePhaseMotor.aimc.squirrelCageR.LossPower", "Loss power leaving component via heatPort [W]",\
 "threePhaseMotor.aimc.powerBalance.lossPowerRotorWinding", 1, 5, 414, 0)
DeclareAlias2("threePhaseMotor.aimc.squirrelCageR.T_heatPort", "Temperature of heatPort [K|degC]",\
 "threePhaseMotor.aimc.thermalAmbient.constTr.k", 1, 5, 586, 0)
DeclareVariable("threePhaseMotor.aimc.squirrelCageR.Rr_actual", "Actual resistance = Rr*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("threePhaseMotor.aimc.squirrelCageR.spacePhasor_r.v_[1]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor.aimc.airGapS.der(psi_mr[1])", 1,\
 5, 612, 4)
DeclareAlias2("threePhaseMotor.aimc.squirrelCageR.spacePhasor_r.v_[2]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor.aimc.airGapS.der(psi_mr[2])", 1,\
 5, 613, 4)
DeclareAlias2("threePhaseMotor.aimc.squirrelCageR.spacePhasor_r.i_[1]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor.aimc.idq_rr[1]", -1, 1, 2, 132)
DeclareAlias2("threePhaseMotor.aimc.squirrelCageR.spacePhasor_r.i_[2]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor.aimc.idq_rr[2]", -1, 1, 3, 132)
DeclareAlias2("threePhaseMotor.aimc.squirrelCageR.spacePhasor_r.der(i_[1])", \
"der(1=real, 2=imaginary part) [A/s]", "threePhaseMotor.aimc.der(idq_rr[1])", -1,\
 6, 2, 4)
DeclareAlias2("threePhaseMotor.aimc.squirrelCageR.spacePhasor_r.der(i_[2])", \
"der(1=real, 2=imaginary part) [A/s]", "threePhaseMotor.aimc.der(idq_rr[2])", -1,\
 6, 3, 4)
DeclareAlias2("threePhaseMotor.aimc.squirrelCageR.i[1]", "Currents out from squirrel cage [A]",\
 "threePhaseMotor.aimc.idq_rr[1]", 1, 1, 2, 0)
DeclareAlias2("threePhaseMotor.aimc.squirrelCageR.i[2]", "Currents out from squirrel cage [A]",\
 "threePhaseMotor.aimc.idq_rr[2]", 1, 1, 3, 0)
DeclareVariable("threePhaseMotor.terminalBox.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("threePhaseMotor.terminalBox.plug_sp.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("threePhaseMotor.terminalBox.plug_sp.pin[1].v", "Potential at the pin [V]",\
 "inverter2.ac.pin[1].v", 1, 5, 43, 4)
DeclareAlias2("threePhaseMotor.terminalBox.plug_sp.pin[1].i", "Current flowing into the pin [A]",\
 "inverter2.ac.pin[1].i", 1, 5, 44, 132)
DeclareAlias2("threePhaseMotor.terminalBox.plug_sp.pin[2].v", "Potential at the pin [V]",\
 "inverter2.ac.pin[2].v", 1, 5, 45, 4)
DeclareAlias2("threePhaseMotor.terminalBox.plug_sp.pin[2].i", "Current flowing into the pin [A]",\
 "inverter2.ac.pin[2].i", 1, 5, 46, 132)
DeclareAlias2("threePhaseMotor.terminalBox.plug_sp.pin[3].v", "Potential at the pin [V]",\
 "inverter2.ac.pin[3].v", 1, 5, 47, 4)
DeclareAlias2("threePhaseMotor.terminalBox.plug_sp.pin[3].i", "Current flowing into the pin [A]",\
 "inverter2.ac.pin[3].i", 1, 5, 48, 132)
DeclareVariable("threePhaseMotor.terminalBox.plug_sn.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("threePhaseMotor.terminalBox.plug_sn.pin[1].v", "Potential at the pin [V]",\
 "threePhaseMotor.aimc.plug_sn.pin[1].v", 1, 5, 426, 4)
DeclareAlias2("threePhaseMotor.terminalBox.plug_sn.pin[1].i", "Current flowing into the pin [A]",\
 "inverter2.ac.pin[1].i", -1, 5, 44, 132)
DeclareAlias2("threePhaseMotor.terminalBox.plug_sn.pin[2].v", "Potential at the pin [V]",\
 "threePhaseMotor.aimc.plug_sn.pin[1].v", 1, 5, 426, 4)
DeclareAlias2("threePhaseMotor.terminalBox.plug_sn.pin[2].i", "Current flowing into the pin [A]",\
 "inverter2.ac.pin[2].i", -1, 5, 46, 132)
DeclareAlias2("threePhaseMotor.terminalBox.plug_sn.pin[3].v", "Potential at the pin [V]",\
 "threePhaseMotor.aimc.plug_sn.pin[1].v", 1, 5, 426, 4)
DeclareAlias2("threePhaseMotor.terminalBox.plug_sn.pin[3].i", "Current flowing into the pin [A]",\
 "inverter2.ac.pin[3].i", -1, 5, 48, 132)
DeclareVariable("threePhaseMotor.terminalBox.star.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("threePhaseMotor.terminalBox.star.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("threePhaseMotor.terminalBox.star.plug_p.pin[1].v", \
"Potential at the pin [V]", "threePhaseMotor.aimc.plug_sn.pin[1].v", 1, 5, 426, 4)
DeclareAlias2("threePhaseMotor.terminalBox.star.plug_p.pin[1].i", \
"Current flowing into the pin [A]", "inverter2.ac.pin[1].i", -1, 5, 44, 132)
DeclareAlias2("threePhaseMotor.terminalBox.star.plug_p.pin[2].v", \
"Potential at the pin [V]", "threePhaseMotor.aimc.plug_sn.pin[1].v", 1, 5, 426, 4)
DeclareAlias2("threePhaseMotor.terminalBox.star.plug_p.pin[2].i", \
"Current flowing into the pin [A]", "inverter2.ac.pin[2].i", -1, 5, 46, 132)
DeclareAlias2("threePhaseMotor.terminalBox.star.plug_p.pin[3].v", \
"Potential at the pin [V]", "threePhaseMotor.aimc.plug_sn.pin[1].v", 1, 5, 426, 4)
DeclareAlias2("threePhaseMotor.terminalBox.star.plug_p.pin[3].i", \
"Current flowing into the pin [A]", "inverter2.ac.pin[3].i", -1, 5, 48, 132)
DeclareAlias2("threePhaseMotor.terminalBox.star.pin_n.v", "Potential at the pin [V]",\
 "threePhaseMotor.aimc.plug_sn.pin[1].v", 1, 5, 426, 4)
DeclareVariable("threePhaseMotor.terminalBox.star.pin_n.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor.terminalBox.plugSupply.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("threePhaseMotor.terminalBox.plugSupply.pin[1].v", \
"Potential at the pin [V]", "inverter2.ac.pin[1].v", 1, 5, 43, 4)
DeclareAlias2("threePhaseMotor.terminalBox.plugSupply.pin[1].i", \
"Current flowing into the pin [A]", "inverter2.ac.pin[1].i", -1, 5, 44, 132)
DeclareAlias2("threePhaseMotor.terminalBox.plugSupply.pin[2].v", \
"Potential at the pin [V]", "inverter2.ac.pin[2].v", 1, 5, 45, 4)
DeclareAlias2("threePhaseMotor.terminalBox.plugSupply.pin[2].i", \
"Current flowing into the pin [A]", "inverter2.ac.pin[2].i", -1, 5, 46, 132)
DeclareAlias2("threePhaseMotor.terminalBox.plugSupply.pin[3].v", \
"Potential at the pin [V]", "inverter2.ac.pin[3].v", 1, 5, 47, 4)
DeclareAlias2("threePhaseMotor.terminalBox.plugSupply.pin[3].i", \
"Current flowing into the pin [A]", "inverter2.ac.pin[3].i", -1, 5, 48, 132)
DeclareAlias2("threePhaseMotor.terminalBox.starpoint.v", "Potential at the pin [V]",\
 "threePhaseMotor.aimc.plug_sn.pin[1].v", 1, 5, 426, 4)
DeclareVariable("threePhaseMotor.terminalBox.starpoint.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("threePhaseMotor.flange1.phi", "Absolute rotation angle of flange [rad|deg]",\
 "variableSpeedDrive_ThreePhase.speedSensor.flange.phi", 1, 1, 4, 4)
DeclareVariable("threePhaseMotor.flange1.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("threePhaseMotor.aimcData.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareParameter("threePhaseMotor.aimcData.Jr", "Rotor's moment of inertia [kg.m2]",\
 46, 0.29, 0.0,0.0,0.0,0,560)
DeclareVariable("threePhaseMotor.aimcData.Js", "Stator's moment of inertia [kg.m2]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("threePhaseMotor.aimcData.p", "Number of pole pairs (Integer) [:#(type=Integer)]",\
 47, 2, 1.0,1E+100,0.0,0,564)
DeclareParameter("threePhaseMotor.aimcData.fsNominal", "Nominal frequency [Hz]",\
 48, 50, 0.0,0.0,0.0,0,560)
DeclareParameter("threePhaseMotor.aimcData.Rs", "Stator resistance per phase at TRef [Ohm]",\
 49, 0.03, 0.0,0.0,0.0,0,560)
DeclareParameter("threePhaseMotor.aimcData.TsRef", "Reference temperature of stator resistance [K|degC]",\
 50, 293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("threePhaseMotor.aimcData.alpha20s", "Temperature coefficient of stator resistance at 20 degC [1/K]",\
 51, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("threePhaseMotor.aimcData.effectiveStatorTurns", \
"Effective number of stator turns", 52, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("threePhaseMotor.aimcData.Lszero", "Stator zero sequence inductance [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimcData.Lssigma", "Stator stray inductance per phase [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimcData.frictionParameters.PRef", \
"Reference friction losses at wRef [W]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor.aimcData.frictionParameters.wRef", \
"Reference angular velocity that the PRef refer to [rad/s|rev/min]", 1E-60, \
1E-60,1E+100,0.0,0,513)
DeclareParameter("threePhaseMotor.aimcData.frictionParameters.power_w", \
"Exponent of friction torque w.r.t. angular velocity", 53, 2, 1E-60,1E+100,0.0,0,560)
DeclareVariable("threePhaseMotor.aimcData.frictionParameters.tauRef", \
"Reference friction torque at reference angular velocity [N.m]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("threePhaseMotor.aimcData.frictionParameters.linear", \
"Linear angular velocity range with respect to reference angular velocity [1]", \
0.001, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimcData.frictionParameters.wLinear", \
"Linear angular velocity range [rad/s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimcData.frictionParameters.tauLinear", \
"Torque corresponding with linear angular velocity range [N.m]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("threePhaseMotor.aimcData.statorCoreParameters.m", \
"Number of phases (1 for DC, 3 for induction machines) [:#(type=Integer)]", 3, \
0.0,0.0,0.0,0,517)
DeclareVariable("threePhaseMotor.aimcData.statorCoreParameters.PRef", \
"Reference core losses at reference inner voltage VRef [W]", 0, 0.0,1E+100,0.0,0,513)
DeclareParameter("threePhaseMotor.aimcData.statorCoreParameters.VRef", \
"Reference inner RMS voltage that reference core losses PRef refer to [V]", 54, 100,\
 1E-60,1E+100,0.0,0,560)
DeclareVariable("threePhaseMotor.aimcData.statorCoreParameters.wRef", \
"Reference angular velocity that reference core losses PRef refer to [rad/s]", \
1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor.aimcData.statorCoreParameters.ratioHysteresis",\
 "Ratio of hysteresis losses with respect to the total core losses at VRef and fRef",\
 0, 0.0,1.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimcData.statorCoreParameters.GcRef", \
"Reference conductance at reference frequency and voltage [S]", 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("threePhaseMotor.aimcData.statorCoreParameters.wMin", "[rad/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimcData.strayLoadParameters.PRef", \
"Reference stray load losses at IRef and wRef [W]", 0, 0.0,1E+100,0.0,0,513)
DeclareParameter("threePhaseMotor.aimcData.strayLoadParameters.IRef", \
"Reference RMS current that PRef refers to [A]", 55, 100, 1E-60,1E+100,0.0,0,560)
DeclareVariable("threePhaseMotor.aimcData.strayLoadParameters.wRef", \
"Reference angular velocity that PRef refers to [rad/s|rev/min]", 1E-60, 1E-60,\
1E+100,0.0,0,513)
DeclareParameter("threePhaseMotor.aimcData.strayLoadParameters.power_w", \
"Exponent of stray load loss torque w.r.t. angular velocity", 56, 1, 1E-60,\
1E+100,0.0,0,560)
DeclareVariable("threePhaseMotor.aimcData.strayLoadParameters.tauRef", \
"Reference stray load torque at reference angular velocity and reference current [N.m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimcData.Lm", "Stator main field inductance per phase [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor.aimcData.Lrsigma", "Rotor stray inductance per phase (equivalent three phase winding) [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("threePhaseMotor.aimcData.Rr", "Rotor resistance per phase (equivalent three phase winding) at TRef [Ohm]",\
 57, 0.04, 0.0,0.0,0.0,0,560)
DeclareParameter("threePhaseMotor.aimcData.TrRef", "Reference temperature of rotor resistance [K|degC]",\
 58, 293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("threePhaseMotor.aimcData.alpha20r", "Temperature coefficient of rotor resistance at 20 degC [1/K]",\
 59, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("threePhaseMotor.plug_p1.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("threePhaseMotor.plug_p1.pin[1].v", "Potential at the pin [V]", \
"inverter2.ac.pin[1].v", 1, 5, 43, 4)
DeclareAlias2("threePhaseMotor.plug_p1.pin[1].i", "Current flowing into the pin [A]",\
 "inverter2.ac.pin[1].i", -1, 5, 44, 132)
DeclareAlias2("threePhaseMotor.plug_p1.pin[2].v", "Potential at the pin [V]", \
"inverter2.ac.pin[2].v", 1, 5, 45, 4)
DeclareAlias2("threePhaseMotor.plug_p1.pin[2].i", "Current flowing into the pin [A]",\
 "inverter2.ac.pin[2].i", -1, 5, 46, 132)
DeclareAlias2("threePhaseMotor.plug_p1.pin[3].v", "Potential at the pin [V]", \
"inverter2.ac.pin[3].v", 1, 5, 47, 4)
DeclareAlias2("threePhaseMotor.plug_p1.pin[3].i", "Current flowing into the pin [A]",\
 "inverter2.ac.pin[3].i", -1, 5, 48, 132)
DeclareVariable("threePhaseMotor.rpm", "Reference speed of the generator [rad/s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("signalPWM[1].useConstantDutyCycle", "Enables constant duty cycle [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("signalPWM[1].constantDutyCycle", "Constant duty cycle", 60, 0,\
 0.0,0.0,0.0,0,560)
DeclareParameter("signalPWM[1].f", "Switching frequency [Hz|kHz]", 61, 100000, \
0.0,0.0,0.0,0,560)
DeclareParameter("signalPWM[1].startTime", "Start time [s]", 62, 0, 0.0,0.0,0.0,\
0,560)
DeclareAlias2("signalPWM[1].dutyCycle", "Duty cycle [rad/s]", "variableSpeedDrive_ThreePhase.y1[1]", 1,\
 5, 737, 0)
DeclareAlias2("signalPWM[1].fire", "Firing PWM signal [:#(type=Boolean)]", \
"inverter2.fire_n[1]", 1, 5, 33, 65)
DeclareAlias2("signalPWM[1].notFire", "Firing PWM signal [:#(type=Boolean)]", \
"inverter2.fire_p[1]", 1, 5, 25, 65)
DeclareParameter("signalPWM[1].limiter.uMax", "Upper limits of input signals [rad/s]",\
 63, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("signalPWM[1].limiter.uMin", "Lower limits of input signals [rad/s]",\
 64, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("signalPWM[1].limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("signalPWM[1].limiter.homotopyType", "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("signalPWM[1].limiter.limitsAtInit", "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("signalPWM[1].limiter.u", "Connector of Real input signal [rad/s]",\
 "variableSpeedDrive_ThreePhase.y1[1]", 1, 5, 737, 0)
DeclareVariable("signalPWM[1].limiter.y", "Connector of Real output signal [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("signalPWM[1].limiter.simplifiedExpr", "Simplified expression for homotopy-based initialization [rad/s]",\
 "variableSpeedDrive_ThreePhase.y1[1]", 1, 5, 737, 1024)
DeclareVariable("signalPWM[1].greaterEqual.u1", "Connector of first Real input signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("signalPWM[1].greaterEqual.u2", "Connector of second Real input signal [rad/s]",\
 0.0, 0.0,0.0,0.0,0,640)
DeclareAlias2("signalPWM[1].greaterEqual.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter2.fire_n[1]", 1, 5, 33, 65)
DeclareVariable("signalPWM[1].zeroOrderHold.samplePeriod", "Sample period of component [s]",\
 0.1, 1E-13,1E+100,0.0,0,513)
DeclareVariable("signalPWM[1].zeroOrderHold.startTime", "First sample time instant [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM[1].zeroOrderHold.sampleTrigger", "True, if sample time instant [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2690)
DeclareVariable("signalPWM[1].zeroOrderHold.firstTrigger", "Rising edge signals first sample instant [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2706)
DeclareAlias2("signalPWM[1].zeroOrderHold.u", "Connector of Real input signal [rad/s]",\
 "signalPWM[1].limiter.y", 1, 5, 678, 0)
DeclareAlias2("signalPWM[1].zeroOrderHold.y", "Connector of Real output signal [rad/s]",\
 "signalPWM[1].greaterEqual.u2", 1, 5, 680, 0)
DeclareVariable("signalPWM[1].zeroOrderHold.ySample", "[rad/s]", 0, 0.0,0.0,0.0,\
0,656)
DeclareVariable("signalPWM[1].sawtooth.amplitude", "Amplitude of saw tooth", 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM[1].sawtooth.period", "Time for one period [s]", 1, \
1E-60,1E+100,0.0,0,513)
DeclareVariable("signalPWM[1].sawtooth.nperiod", "Number of periods (< 0 means infinite number of periods) [:#(type=Integer)]",\
 -1, 0.0,0.0,0.0,0,517)
DeclareAlias2("signalPWM[1].sawtooth.y", "Connector of Real output signal", \
"signalPWM[1].greaterEqual.u1", 1, 5, 679, 0)
DeclareVariable("signalPWM[1].sawtooth.offset", "Offset of output signal y", 0, \
0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM[1].sawtooth.startTime", "Output y = offset for time < startTime [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM[1].sawtooth.T_start", "Start time of current period [s]",\
 0.0, 0.0,0.0,0.0,0,2688)
DeclareVariable("signalPWM[1].sawtooth.count", "Period count [:#(type=Integer)]",\
 0, 0.0,0.0,0.0,0,2692)
DeclareAlias2("signalPWM[1].inverse.u", "Connector of Boolean input signal [:#(type=Boolean)]",\
 "inverter2.fire_n[1]", 1, 5, 33, 65)
DeclareAlias2("signalPWM[1].inverse.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter2.fire_p[1]", 1, 5, 25, 65)
DeclareVariable("signalPWM[2].useConstantDutyCycle", "Enables constant duty cycle [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("signalPWM[2].constantDutyCycle", "Constant duty cycle", 65, 0,\
 0.0,0.0,0.0,0,560)
DeclareParameter("signalPWM[2].f", "Switching frequency [Hz|kHz]", 66, 100000, \
0.0,0.0,0.0,0,560)
DeclareParameter("signalPWM[2].startTime", "Start time [s]", 67, 0, 0.0,0.0,0.0,\
0,560)
DeclareAlias2("signalPWM[2].dutyCycle", "Duty cycle [rad/s]", "variableSpeedDrive_ThreePhase.y1[1]", 1,\
 5, 737, 0)
DeclareAlias2("signalPWM[2].fire", "Firing PWM signal [:#(type=Boolean)]", \
"inverter2.fire_n[2]", 1, 5, 34, 65)
DeclareAlias2("signalPWM[2].notFire", "Firing PWM signal [:#(type=Boolean)]", \
"inverter2.fire_p[2]", 1, 5, 26, 65)
DeclareParameter("signalPWM[2].limiter.uMax", "Upper limits of input signals [rad/s]",\
 68, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("signalPWM[2].limiter.uMin", "Lower limits of input signals [rad/s]",\
 69, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("signalPWM[2].limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("signalPWM[2].limiter.homotopyType", "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("signalPWM[2].limiter.limitsAtInit", "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("signalPWM[2].limiter.u", "Connector of Real input signal [rad/s]",\
 "variableSpeedDrive_ThreePhase.y1[1]", 1, 5, 737, 0)
DeclareVariable("signalPWM[2].limiter.y", "Connector of Real output signal [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("signalPWM[2].limiter.simplifiedExpr", "Simplified expression for homotopy-based initialization [rad/s]",\
 "variableSpeedDrive_ThreePhase.y1[1]", 1, 5, 737, 1024)
DeclareVariable("signalPWM[2].greaterEqual.u1", "Connector of first Real input signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("signalPWM[2].greaterEqual.u2", "Connector of second Real input signal [rad/s]",\
 0.0, 0.0,0.0,0.0,0,640)
DeclareAlias2("signalPWM[2].greaterEqual.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter2.fire_n[2]", 1, 5, 34, 65)
DeclareVariable("signalPWM[2].zeroOrderHold.samplePeriod", "Sample period of component [s]",\
 0.1, 1E-13,1E+100,0.0,0,513)
DeclareVariable("signalPWM[2].zeroOrderHold.startTime", "First sample time instant [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM[2].zeroOrderHold.sampleTrigger", "True, if sample time instant [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2690)
DeclareVariable("signalPWM[2].zeroOrderHold.firstTrigger", "Rising edge signals first sample instant [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2706)
DeclareAlias2("signalPWM[2].zeroOrderHold.u", "Connector of Real input signal [rad/s]",\
 "signalPWM[2].limiter.y", 1, 5, 697, 0)
DeclareAlias2("signalPWM[2].zeroOrderHold.y", "Connector of Real output signal [rad/s]",\
 "signalPWM[2].greaterEqual.u2", 1, 5, 699, 0)
DeclareVariable("signalPWM[2].zeroOrderHold.ySample", "[rad/s]", 0, 0.0,0.0,0.0,\
0,656)
DeclareVariable("signalPWM[2].sawtooth.amplitude", "Amplitude of saw tooth", 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM[2].sawtooth.period", "Time for one period [s]", 1, \
1E-60,1E+100,0.0,0,513)
DeclareVariable("signalPWM[2].sawtooth.nperiod", "Number of periods (< 0 means infinite number of periods) [:#(type=Integer)]",\
 -1, 0.0,0.0,0.0,0,517)
DeclareAlias2("signalPWM[2].sawtooth.y", "Connector of Real output signal", \
"signalPWM[2].greaterEqual.u1", 1, 5, 698, 0)
DeclareVariable("signalPWM[2].sawtooth.offset", "Offset of output signal y", 0, \
0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM[2].sawtooth.startTime", "Output y = offset for time < startTime [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM[2].sawtooth.T_start", "Start time of current period [s]",\
 0.0, 0.0,0.0,0.0,0,2688)
DeclareVariable("signalPWM[2].sawtooth.count", "Period count [:#(type=Integer)]",\
 0, 0.0,0.0,0.0,0,2692)
DeclareAlias2("signalPWM[2].inverse.u", "Connector of Boolean input signal [:#(type=Boolean)]",\
 "inverter2.fire_n[2]", 1, 5, 34, 65)
DeclareAlias2("signalPWM[2].inverse.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter2.fire_p[2]", 1, 5, 26, 65)
DeclareVariable("signalPWM[3].useConstantDutyCycle", "Enables constant duty cycle [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("signalPWM[3].constantDutyCycle", "Constant duty cycle", 70, 0,\
 0.0,0.0,0.0,0,560)
DeclareParameter("signalPWM[3].f", "Switching frequency [Hz|kHz]", 71, 100000, \
0.0,0.0,0.0,0,560)
DeclareParameter("signalPWM[3].startTime", "Start time [s]", 72, 0, 0.0,0.0,0.0,\
0,560)
DeclareAlias2("signalPWM[3].dutyCycle", "Duty cycle [rad/s]", "variableSpeedDrive_ThreePhase.y1[1]", 1,\
 5, 737, 0)
DeclareAlias2("signalPWM[3].fire", "Firing PWM signal [:#(type=Boolean)]", \
"inverter2.fire_n[3]", 1, 5, 35, 65)
DeclareAlias2("signalPWM[3].notFire", "Firing PWM signal [:#(type=Boolean)]", \
"inverter2.fire_p[3]", 1, 5, 27, 65)
DeclareParameter("signalPWM[3].limiter.uMax", "Upper limits of input signals [rad/s]",\
 73, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("signalPWM[3].limiter.uMin", "Lower limits of input signals [rad/s]",\
 74, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("signalPWM[3].limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("signalPWM[3].limiter.homotopyType", "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("signalPWM[3].limiter.limitsAtInit", "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("signalPWM[3].limiter.u", "Connector of Real input signal [rad/s]",\
 "variableSpeedDrive_ThreePhase.y1[1]", 1, 5, 737, 0)
DeclareVariable("signalPWM[3].limiter.y", "Connector of Real output signal [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("signalPWM[3].limiter.simplifiedExpr", "Simplified expression for homotopy-based initialization [rad/s]",\
 "variableSpeedDrive_ThreePhase.y1[1]", 1, 5, 737, 1024)
DeclareVariable("signalPWM[3].greaterEqual.u1", "Connector of first Real input signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("signalPWM[3].greaterEqual.u2", "Connector of second Real input signal [rad/s]",\
 0.0, 0.0,0.0,0.0,0,640)
DeclareAlias2("signalPWM[3].greaterEqual.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter2.fire_n[3]", 1, 5, 35, 65)
DeclareVariable("signalPWM[3].zeroOrderHold.samplePeriod", "Sample period of component [s]",\
 0.1, 1E-13,1E+100,0.0,0,513)
DeclareVariable("signalPWM[3].zeroOrderHold.startTime", "First sample time instant [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM[3].zeroOrderHold.sampleTrigger", "True, if sample time instant [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2690)
DeclareVariable("signalPWM[3].zeroOrderHold.firstTrigger", "Rising edge signals first sample instant [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2706)
DeclareAlias2("signalPWM[3].zeroOrderHold.u", "Connector of Real input signal [rad/s]",\
 "signalPWM[3].limiter.y", 1, 5, 716, 0)
DeclareAlias2("signalPWM[3].zeroOrderHold.y", "Connector of Real output signal [rad/s]",\
 "signalPWM[3].greaterEqual.u2", 1, 5, 718, 0)
DeclareVariable("signalPWM[3].zeroOrderHold.ySample", "[rad/s]", 0, 0.0,0.0,0.0,\
0,656)
DeclareVariable("signalPWM[3].sawtooth.amplitude", "Amplitude of saw tooth", 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM[3].sawtooth.period", "Time for one period [s]", 1, \
1E-60,1E+100,0.0,0,513)
DeclareVariable("signalPWM[3].sawtooth.nperiod", "Number of periods (< 0 means infinite number of periods) [:#(type=Integer)]",\
 -1, 0.0,0.0,0.0,0,517)
DeclareAlias2("signalPWM[3].sawtooth.y", "Connector of Real output signal", \
"signalPWM[3].greaterEqual.u1", 1, 5, 717, 0)
DeclareVariable("signalPWM[3].sawtooth.offset", "Offset of output signal y", 0, \
0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM[3].sawtooth.startTime", "Output y = offset for time < startTime [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM[3].sawtooth.T_start", "Start time of current period [s]",\
 0.0, 0.0,0.0,0.0,0,2688)
DeclareVariable("signalPWM[3].sawtooth.count", "Period count [:#(type=Integer)]",\
 0, 0.0,0.0,0.0,0,2692)
DeclareAlias2("signalPWM[3].inverse.u", "Connector of Boolean input signal [:#(type=Boolean)]",\
 "inverter2.fire_n[3]", 1, 5, 35, 65)
DeclareAlias2("signalPWM[3].inverse.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter2.fire_p[3]", 1, 5, 27, 65)
DeclareState("variableSpeedDrive_ThreePhase.speedSensor.flange.phi", \
"Absolute rotation angle of flange [rad|deg]", 4, 0.0, 0.0,0.0,0.0,0,568)
DeclareDerivative("variableSpeedDrive_ThreePhase.speedSensor.flange.der(phi)", \
"der(Absolute rotation angle of flange) [rad/s]", 0.0, 0.0,0.0,0.0,0,520)
DeclareVariable("variableSpeedDrive_ThreePhase.speedSensor.flange.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("variableSpeedDrive_ThreePhase.speedSensor.w", "Absolute angular velocity of flange as output signal [rad/s]",\
 "variableSpeedDrive_ThreePhase.speedSensor.flange.der(phi)", 1, 6, 4, 0)
DeclareVariable("variableSpeedDrive_ThreePhase.currentController.k", "Gain [1]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("variableSpeedDrive_ThreePhase.currentController.T", \
"Time Constant (T>0 required) [s]", 1, 1E-60,1E+100,0.0,0,513)
DeclareVariable("variableSpeedDrive_ThreePhase.currentController.initType", \
"Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareParameter("variableSpeedDrive_ThreePhase.currentController.x_start", \
"Initial or guess value of state [rad/s]", 75, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("variableSpeedDrive_ThreePhase.currentController.y_start", \
"Initial value of output [rad/s]", 76, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("variableSpeedDrive_ThreePhase.currentController.u", \
"Connector of Real input signal [rad/s]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("variableSpeedDrive_ThreePhase.currentController.y", \
"Connector of Real output signal [rad/s]", "variableSpeedDrive_ThreePhase.y1[1]", 1,\
 5, 737, 0)
DeclareState("variableSpeedDrive_ThreePhase.currentController.x", \
"State of block [rad/s]", 5, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("variableSpeedDrive_ThreePhase.currentController.der(x)", \
"der(State of block) [rad/s2]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("variableSpeedDrive_ThreePhase.flange1.phi", "Absolute rotation angle of flange [rad|deg]",\
 "variableSpeedDrive_ThreePhase.speedSensor.flange.phi", 1, 1, 4, 4)
DeclareVariable("variableSpeedDrive_ThreePhase.flange1.tau", "Cut torque in the flange [N.m]",\
 0, 0.0,0.0,0.0,0,777)
DeclareVariable("variableSpeedDrive_ThreePhase.y1[1]", "Connector of Real output signal [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("variableSpeedDrive_ThreePhase.y1[2]", "Connector of Real output signal [rad/s]",\
 "variableSpeedDrive_ThreePhase.y1[1]", 1, 5, 737, 0)
DeclareAlias2("variableSpeedDrive_ThreePhase.y1[3]", "Connector of Real output signal [rad/s]",\
 "variableSpeedDrive_ThreePhase.y1[1]", 1, 5, 737, 0)
DeclareVariable("variableSpeedDrive_ThreePhase.const.k", "Constant output value [rad/s]",\
 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("variableSpeedDrive_ThreePhase.const.y", "Connector of Real output signal [rad/s]",\
 "variableSpeedDrive_ThreePhase.const.k", 1, 5, 738, 0)
DeclareParameter("variableSpeedDrive_ThreePhase.wref", "Constant output value [rad/s]",\
 77, 41000, 0.0,0.0,0.0,0,560)
DeclareAlias2("variableSpeedDrive_ThreePhase.feedback.u1", "[rad/s]", \
"variableSpeedDrive_ThreePhase.speedSensor.flange.der(phi)", 1, 6, 4, 0)
DeclareAlias2("variableSpeedDrive_ThreePhase.feedback.u2", "[rad/s]", \
"variableSpeedDrive_ThreePhase.const.k", 1, 5, 738, 0)
DeclareAlias2("variableSpeedDrive_ThreePhase.feedback.y", "[rad/s]", \
"variableSpeedDrive_ThreePhase.currentController.u", 1, 5, 735, 0)
DeclareParameter("variableSpeedDrive_ThreePhase.T", "Time Constant (T>0 required) [s]",\
 78, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("variableSpeedDrive_ThreePhase.k", "Gain [1]", 79, 1, 0.0,0.0,\
0.0,0,560)
DeclareAlias2("variableSpeedDrive_ThreePhase.realExtend.u", "[rad/s]", \
"variableSpeedDrive_ThreePhase.y1[1]", 1, 5, 737, 0)
DeclareAlias2("variableSpeedDrive_ThreePhase.realExtend.y[1]", "[rad/s]", \
"variableSpeedDrive_ThreePhase.y1[1]", 1, 5, 737, 0)
DeclareAlias2("variableSpeedDrive_ThreePhase.realExtend.y[2]", "[rad/s]", \
"variableSpeedDrive_ThreePhase.y1[1]", 1, 5, 737, 0)
DeclareAlias2("variableSpeedDrive_ThreePhase.realExtend.y[3]", "[rad/s]", \
"variableSpeedDrive_ThreePhase.y1[1]", 1, 5, 737, 0)
DeclareAlias2("fan.inertia.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "variableSpeedDrive_ThreePhase.speedSensor.flange.phi", 1, 1, 4, 4)
DeclareAlias2("fan.inertia.flange_a.tau", "Cut torque in the flange [N.m]", \
"threePhaseMotor.flange1.tau", -1, 5, 650, 132)
DeclareAlias2("fan.inertia.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "variableSpeedDrive_ThreePhase.speedSensor.flange.phi", 1, 1, 4, 4)
DeclareVariable("fan.inertia.flange_b.tau", "Cut torque in the flange [N.m]", \
0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("fan.inertia.J", "Moment of inertia [kg.m2]", 1, 0.0,1E+100,0.0,\
0,513)
DeclareVariable("fan.inertia.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 3, 1.0,5.0,0.0,0,1541)
DeclareAlias2("fan.inertia.phi", "Absolute rotation angle of component [rad|deg]",\
 "variableSpeedDrive_ThreePhase.speedSensor.flange.phi", 1, 1, 4, 0)
DeclareAlias2("fan.inertia.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 "fan.inertia.w", 1, 1, 6, 0)
DeclareState("fan.inertia.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 6, 0, 0.0,0.0,0.0,0,544)
DeclareDerivative("fan.inertia.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("fan.inertia.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "fan.inertia.der(w)", 1, 6, 6, 0)
DeclareAlias2("fan.flange_a1.phi", "Absolute rotation angle of flange [rad|deg]",\
 "variableSpeedDrive_ThreePhase.speedSensor.flange.phi", 1, 1, 4, 4)
DeclareAlias2("fan.flange_a1.tau", "Cut torque in the flange [N.m]", \
"threePhaseMotor.flange1.tau", -1, 5, 650, 132)
DeclareParameter("fan.J", "Moment of inertia of the fan blades [kg.m2]", 80, 1, \
0.0,0.0,0.0,0,560)
DeclareParameter("fan.deltaPhi", "Fixed rotation of left flange with respect to right flange [rad|deg]",\
 81, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("inverter1.useConstantEnable", "true = disabled boolean input, use constantEnable [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("inverter1.constantEnable", "Constant enabling of firing signals [:#(type=Boolean)]",\
 82, true, 0.0,0.0,0.0,0,562)
DeclareVariable("inverter1.m", "Number of phases [:#(type=Integer)]", 3, 3.0,\
1E+100,0.0,0,517)
DeclareAlias2("inverter1.andCondition_p[1].u1", "Connector of first Boolean input signal [:#(type=Boolean)]",\
 "inverter1.fire_p[1]", 1, 5, 744, 65)
DeclareAlias2("inverter1.andCondition_p[1].u2", "Connector of second Boolean input signal [:#(type=Boolean)]",\
 "inverter1.enableLogic.enableConstantSource.k", 1, 5, 750, 65)
DeclareAlias2("inverter1.andCondition_p[1].y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter1.transistor_p.fire[1]", 1, 5, 797, 65)
DeclareAlias2("inverter1.andCondition_p[2].u1", "Connector of first Boolean input signal [:#(type=Boolean)]",\
 "inverter1.fire_p[2]", 1, 5, 745, 65)
DeclareAlias2("inverter1.andCondition_p[2].u2", "Connector of second Boolean input signal [:#(type=Boolean)]",\
 "inverter1.enableLogic.enableConstantSource.k", 1, 5, 750, 65)
DeclareAlias2("inverter1.andCondition_p[2].y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter1.transistor_p.fire[2]", 1, 5, 798, 65)
DeclareAlias2("inverter1.andCondition_p[3].u1", "Connector of first Boolean input signal [:#(type=Boolean)]",\
 "inverter1.fire_p[3]", 1, 5, 746, 65)
DeclareAlias2("inverter1.andCondition_p[3].u2", "Connector of second Boolean input signal [:#(type=Boolean)]",\
 "inverter1.enableLogic.enableConstantSource.k", 1, 5, 750, 65)
DeclareAlias2("inverter1.andCondition_p[3].y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter1.transistor_p.fire[3]", 1, 5, 799, 65)
DeclareVariable("inverter1.fire_p[1]", "Firing signals of positive potential transistors [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,642)
DeclareVariable("inverter1.fire_p[2]", "Firing signals of positive potential transistors [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,642)
DeclareVariable("inverter1.fire_p[3]", "Firing signals of positive potential transistors [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,642)
DeclareVariable("inverter1.enableLogic.useConstantEnable", "true = disabled boolean input, use constantEnable [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("inverter1.enableLogic.constantEnable", "Constant enabling of firing signals [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("inverter1.enableLogic.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("inverter1.enableLogic.enableConstantSource.k", "Constant output value [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("inverter1.enableLogic.enableConstantSource.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter1.enableLogic.enableConstantSource.k", 1, 5, 750, 65)
DeclareVariable("inverter1.enableLogic.booleanReplicator.nout", "Number of outputs [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareAlias2("inverter1.enableLogic.booleanReplicator.u", "Connector of Boolean input signal [:#(type=Boolean)]",\
 "inverter1.enableLogic.enableConstantSource.k", 1, 5, 750, 65)
DeclareAlias2("inverter1.enableLogic.booleanReplicator.y[1]", "Connector of Boolean output signals [:#(type=Boolean)]",\
 "inverter1.enableLogic.enableConstantSource.k", 1, 5, 750, 65)
DeclareAlias2("inverter1.enableLogic.booleanReplicator.y[2]", "Connector of Boolean output signals [:#(type=Boolean)]",\
 "inverter1.enableLogic.enableConstantSource.k", 1, 5, 750, 65)
DeclareAlias2("inverter1.enableLogic.booleanReplicator.y[3]", "Connector of Boolean output signals [:#(type=Boolean)]",\
 "inverter1.enableLogic.enableConstantSource.k", 1, 5, 750, 65)
DeclareAlias2("inverter1.enableLogic.internalEnable[1]", "m replicated enable signals [:#(type=Boolean)]",\
 "inverter1.enableLogic.enableConstantSource.k", 1, 5, 750, 65)
DeclareAlias2("inverter1.enableLogic.internalEnable[2]", "m replicated enable signals [:#(type=Boolean)]",\
 "inverter1.enableLogic.enableConstantSource.k", 1, 5, 750, 65)
DeclareAlias2("inverter1.enableLogic.internalEnable[3]", "m replicated enable signals [:#(type=Boolean)]",\
 "inverter1.enableLogic.enableConstantSource.k", 1, 5, 750, 65)
DeclareAlias2("inverter1.andCondition_n[1].u1", "Connector of first Boolean input signal [:#(type=Boolean)]",\
 "inverter1.fire_n[1]", 1, 5, 752, 65)
DeclareAlias2("inverter1.andCondition_n[1].u2", "Connector of second Boolean input signal [:#(type=Boolean)]",\
 "inverter1.enableLogic.enableConstantSource.k", 1, 5, 750, 65)
DeclareAlias2("inverter1.andCondition_n[1].y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter1.transistor_n.fire[1]", 1, 5, 911, 65)
DeclareAlias2("inverter1.andCondition_n[2].u1", "Connector of first Boolean input signal [:#(type=Boolean)]",\
 "inverter1.fire_n[2]", 1, 5, 753, 65)
DeclareAlias2("inverter1.andCondition_n[2].u2", "Connector of second Boolean input signal [:#(type=Boolean)]",\
 "inverter1.enableLogic.enableConstantSource.k", 1, 5, 750, 65)
DeclareAlias2("inverter1.andCondition_n[2].y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter1.transistor_n.fire[2]", 1, 5, 912, 65)
DeclareAlias2("inverter1.andCondition_n[3].u1", "Connector of first Boolean input signal [:#(type=Boolean)]",\
 "inverter1.fire_n[3]", 1, 5, 754, 65)
DeclareAlias2("inverter1.andCondition_n[3].u2", "Connector of second Boolean input signal [:#(type=Boolean)]",\
 "inverter1.enableLogic.enableConstantSource.k", 1, 5, 750, 65)
DeclareAlias2("inverter1.andCondition_n[3].y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter1.transistor_n.fire[3]", 1, 5, 913, 65)
DeclareVariable("inverter1.fire_n[1]", "Firing signals of negative potential transistors [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,642)
DeclareVariable("inverter1.fire_n[2]", "Firing signals of negative potential transistors [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,642)
DeclareVariable("inverter1.fire_n[3]", "Firing signals of negative potential transistors [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,642)
DeclareParameter("inverter1.RonTransistor", "Transistor closed resistance [Ohm]",\
 83, 1E-05, 0.0,0.0,0.0,0,560)
DeclareParameter("inverter1.GoffTransistor", "Transistor opened conductance [S]",\
 84, 1E-05, 0.0,0.0,0.0,0,560)
DeclareParameter("inverter1.VkneeTransistor", "Transistor threshold voltage [V]",\
 85, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("inverter1.RonDiode", "Diode closed resistance [Ohm]", 86, \
1E-05, 0.0,0.0,0.0,0,560)
DeclareParameter("inverter1.GoffDiode", "Diode opened conductance [S]", 87, \
1E-05, 0.0,0.0,0.0,0,560)
DeclareParameter("inverter1.VkneeDiode", "Diode threshold voltage [V]", 88, 0, \
0.0,0.0,0.0,0,560)
DeclareVariable("inverter1.dc_p.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,\
0,520)
DeclareAlias2("inverter1.dc_p.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", 1, 1, 16, 132)
DeclareVariable("inverter1.dc_n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,\
0,520)
DeclareAlias2("inverter1.dc_n.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", -1, 1, 16, 132)
DeclareVariable("inverter1.vDC", "DC voltage [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter1.iDC", "DC current [A]", "simpleLine2.inductor.i", 1, 1,\
 16, 0)
DeclareVariable("inverter1.powerDC", "DC power [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter1.ac.m", "Number of phases [:#(type=Integer)]", 3, 1.0,\
1E+100,0.0,0,525)
DeclareVariable("inverter1.ac.pin[1].v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,520)
DeclareVariable("inverter1.ac.pin[1].i", "Current flowing into the pin [A]", 0.0,\
 0.0,0.0,0.0,0,776)
DeclareVariable("inverter1.ac.pin[2].v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,520)
DeclareVariable("inverter1.ac.pin[2].i", "Current flowing into the pin [A]", 0.0,\
 0.0,0.0,0.0,0,776)
DeclareVariable("inverter1.ac.pin[3].v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,520)
DeclareVariable("inverter1.ac.pin[3].i", "Current flowing into the pin [A]", 0.0,\
 0.0,0.0,0.0,0,776)
DeclareAlias2("inverter1.vAC[1]", "AC potential [V]", "inverter1.ac.pin[1].v", 1,\
 5, 760, 0)
DeclareAlias2("inverter1.vAC[2]", "AC potential [V]", "inverter1.ac.pin[2].v", 1,\
 5, 762, 0)
DeclareAlias2("inverter1.vAC[3]", "AC potential [V]", "inverter1.ac.pin[3].v", 1,\
 5, 764, 0)
DeclareAlias2("inverter1.iAC[1]", "AC current [A]", "inverter1.ac.pin[1].i", 1, 5,\
 761, 0)
DeclareAlias2("inverter1.iAC[2]", "AC current [A]", "inverter1.ac.pin[2].i", 1, 5,\
 763, 0)
DeclareAlias2("inverter1.iAC[3]", "AC current [A]", "inverter1.ac.pin[3].i", 1, 5,\
 765, 0)
DeclareVariable("inverter1.powerAC[1]", "AC power [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter1.powerAC[2]", "AC power [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter1.powerAC[3]", "AC power [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter1.powerTotalAC", "AC total power [W]", 0.0, 0.0,0.0,0.0,\
0,512)
DeclareVariable("inverter1.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("inverter1.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter1.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter1.T_heatPort", "Temperature of heatPort [K|degC]", \
293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter1.transistor_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("inverter1.transistor_p.v[1]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter1.transistor_p.v[2]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter1.transistor_p.v[3]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter1.transistor_p.i[1]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter1.transistor_p.i[2]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter1.transistor_p.i[3]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter1.transistor_p.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("inverter1.transistor_p.plug_p.pin[1].v", "Potential at the pin [V]",\
 "inverter1.dc_p.v", 1, 5, 755, 4)
DeclareAlias2("inverter1.transistor_p.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 "inverter1.transistor_p.i[1]", 1, 5, 778, 132)
DeclareAlias2("inverter1.transistor_p.plug_p.pin[2].v", "Potential at the pin [V]",\
 "inverter1.dc_p.v", 1, 5, 755, 4)
DeclareAlias2("inverter1.transistor_p.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 "inverter1.transistor_p.i[2]", 1, 5, 779, 132)
DeclareAlias2("inverter1.transistor_p.plug_p.pin[3].v", "Potential at the pin [V]",\
 "inverter1.dc_p.v", 1, 5, 755, 4)
DeclareAlias2("inverter1.transistor_p.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 "inverter1.transistor_p.i[3]", 1, 5, 780, 132)
DeclareVariable("inverter1.transistor_p.plug_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("inverter1.transistor_p.plug_n.pin[1].v", "Potential at the pin [V]",\
 "inverter1.ac.pin[1].v", 1, 5, 760, 4)
DeclareAlias2("inverter1.transistor_p.plug_n.pin[1].i", "Current flowing into the pin [A]",\
 "inverter1.transistor_p.i[1]", -1, 5, 778, 132)
DeclareAlias2("inverter1.transistor_p.plug_n.pin[2].v", "Potential at the pin [V]",\
 "inverter1.ac.pin[2].v", 1, 5, 762, 4)
DeclareAlias2("inverter1.transistor_p.plug_n.pin[2].i", "Current flowing into the pin [A]",\
 "inverter1.transistor_p.i[2]", -1, 5, 779, 132)
DeclareAlias2("inverter1.transistor_p.plug_n.pin[3].v", "Potential at the pin [V]",\
 "inverter1.ac.pin[3].v", 1, 5, 764, 4)
DeclareAlias2("inverter1.transistor_p.plug_n.pin[3].i", "Current flowing into the pin [A]",\
 "inverter1.transistor_p.i[3]", -1, 5, 780, 132)
DeclareVariable("inverter1.transistor_p.Ron[1]", "Closed thyristor resistance [Ohm]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_p.Ron[2]", "Closed thyristor resistance [Ohm]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_p.Ron[3]", "Closed thyristor resistance [Ohm]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_p.Goff[1]", "Opened thyristor conductance [S]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_p.Goff[2]", "Opened thyristor conductance [S]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_p.Goff[3]", "Opened thyristor conductance [S]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_p.Vknee[1]", "Threshold voltage [V]", 0, \
0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_p.Vknee[2]", "Threshold voltage [V]", 0, \
0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_p.Vknee[3]", "Threshold voltage [V]", 0, \
0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_p.mh", "Number of heatPorts=number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("inverter1.transistor_p.useHeatPort", "=true, if all heat ports are enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("inverter1.transistor_p.T[1]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter1.transistor_p.T[2]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter1.transistor_p.T[3]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter1.transistor_p.fire[1]", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,642)
DeclareVariable("inverter1.transistor_p.fire[2]", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,642)
DeclareVariable("inverter1.transistor_p.fire[3]", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,642)
DeclareVariable("inverter1.transistor_p.idealGTOThyristor[1].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter1.transistor_p.idealGTOThyristor[1].i", "Current flowing from pin p to pin n [A]",\
 "inverter1.transistor_p.i[1]", 1, 5, 778, 0)
DeclareAlias2("inverter1.transistor_p.idealGTOThyristor[1].p.v", \
"Potential at the pin [V]", "inverter1.dc_p.v", 1, 5, 755, 4)
DeclareAlias2("inverter1.transistor_p.idealGTOThyristor[1].p.i", \
"Current flowing into the pin [A]", "inverter1.transistor_p.i[1]", 1, 5, 778, 132)
DeclareAlias2("inverter1.transistor_p.idealGTOThyristor[1].n.v", \
"Potential at the pin [V]", "inverter1.ac.pin[1].v", 1, 5, 760, 4)
DeclareAlias2("inverter1.transistor_p.idealGTOThyristor[1].n.i", \
"Current flowing into the pin [A]", "inverter1.transistor_p.i[1]", -1, 5, 778, 132)
DeclareVariable("inverter1.transistor_p.idealGTOThyristor[1].Ron", \
"Forward state-on differential resistance (closed resistance) [Ohm]", 0.0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_p.idealGTOThyristor[1].Goff", \
"Backward state-off conductance (opened conductance) [S]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_p.idealGTOThyristor[1].Vknee", \
"Forward threshold voltage [V]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_p.idealGTOThyristor[1].useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter1.transistor_p.idealGTOThyristor[1].T", \
"Fixed device temperature if useHeatPort = false [K|degC]", 89, 293.15, 0.0,\
1E+100,300.0,0,560)
DeclareVariable("inverter1.transistor_p.idealGTOThyristor[1].LossPower", \
"Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter1.transistor_p.idealGTOThyristor[1].T_heatPort", \
"Temperature of heatPort [K|degC]", "inverter1.transistor_p.idealGTOThyristor[1].T", 1,\
 7, 89, 0)
DeclareVariable("inverter1.transistor_p.idealGTOThyristor[1].off", \
"Switching state [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter1.transistor_p.idealGTOThyristor[1].s", \
"Auxiliary variable for actual position on the ideal diode characteristic [1]", 0,\
 0.0,0.0,0.0,0,2560)
DeclareVariable("inverter1.transistor_p.idealGTOThyristor[1].unitVoltage", "[V]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("inverter1.transistor_p.idealGTOThyristor[1].unitCurrent", "[A]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("inverter1.transistor_p.idealGTOThyristor[1].fire", \
"[:#(type=Boolean)]", "inverter1.transistor_p.fire[1]", 1, 5, 797, 65)
DeclareVariable("inverter1.transistor_p.idealGTOThyristor[2].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter1.transistor_p.idealGTOThyristor[2].i", "Current flowing from pin p to pin n [A]",\
 "inverter1.transistor_p.i[2]", 1, 5, 779, 0)
DeclareAlias2("inverter1.transistor_p.idealGTOThyristor[2].p.v", \
"Potential at the pin [V]", "inverter1.dc_p.v", 1, 5, 755, 4)
DeclareAlias2("inverter1.transistor_p.idealGTOThyristor[2].p.i", \
"Current flowing into the pin [A]", "inverter1.transistor_p.i[2]", 1, 5, 779, 132)
DeclareAlias2("inverter1.transistor_p.idealGTOThyristor[2].n.v", \
"Potential at the pin [V]", "inverter1.ac.pin[2].v", 1, 5, 762, 4)
DeclareAlias2("inverter1.transistor_p.idealGTOThyristor[2].n.i", \
"Current flowing into the pin [A]", "inverter1.transistor_p.i[2]", -1, 5, 779, 132)
DeclareVariable("inverter1.transistor_p.idealGTOThyristor[2].Ron", \
"Forward state-on differential resistance (closed resistance) [Ohm]", 0.0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_p.idealGTOThyristor[2].Goff", \
"Backward state-off conductance (opened conductance) [S]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_p.idealGTOThyristor[2].Vknee", \
"Forward threshold voltage [V]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_p.idealGTOThyristor[2].useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter1.transistor_p.idealGTOThyristor[2].T", \
"Fixed device temperature if useHeatPort = false [K|degC]", 90, 293.15, 0.0,\
1E+100,300.0,0,560)
DeclareVariable("inverter1.transistor_p.idealGTOThyristor[2].LossPower", \
"Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter1.transistor_p.idealGTOThyristor[2].T_heatPort", \
"Temperature of heatPort [K|degC]", "inverter1.transistor_p.idealGTOThyristor[2].T", 1,\
 7, 90, 0)
DeclareVariable("inverter1.transistor_p.idealGTOThyristor[2].off", \
"Switching state [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter1.transistor_p.idealGTOThyristor[2].s", \
"Auxiliary variable for actual position on the ideal diode characteristic [1]", 0,\
 0.0,0.0,0.0,0,2560)
DeclareVariable("inverter1.transistor_p.idealGTOThyristor[2].unitVoltage", "[V]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("inverter1.transistor_p.idealGTOThyristor[2].unitCurrent", "[A]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("inverter1.transistor_p.idealGTOThyristor[2].fire", \
"[:#(type=Boolean)]", "inverter1.transistor_p.fire[2]", 1, 5, 798, 65)
DeclareVariable("inverter1.transistor_p.idealGTOThyristor[3].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter1.transistor_p.idealGTOThyristor[3].i", "Current flowing from pin p to pin n [A]",\
 "inverter1.transistor_p.i[3]", 1, 5, 780, 0)
DeclareAlias2("inverter1.transistor_p.idealGTOThyristor[3].p.v", \
"Potential at the pin [V]", "inverter1.dc_p.v", 1, 5, 755, 4)
DeclareAlias2("inverter1.transistor_p.idealGTOThyristor[3].p.i", \
"Current flowing into the pin [A]", "inverter1.transistor_p.i[3]", 1, 5, 780, 132)
DeclareAlias2("inverter1.transistor_p.idealGTOThyristor[3].n.v", \
"Potential at the pin [V]", "inverter1.ac.pin[3].v", 1, 5, 764, 4)
DeclareAlias2("inverter1.transistor_p.idealGTOThyristor[3].n.i", \
"Current flowing into the pin [A]", "inverter1.transistor_p.i[3]", -1, 5, 780, 132)
DeclareVariable("inverter1.transistor_p.idealGTOThyristor[3].Ron", \
"Forward state-on differential resistance (closed resistance) [Ohm]", 0.0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_p.idealGTOThyristor[3].Goff", \
"Backward state-off conductance (opened conductance) [S]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_p.idealGTOThyristor[3].Vknee", \
"Forward threshold voltage [V]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_p.idealGTOThyristor[3].useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter1.transistor_p.idealGTOThyristor[3].T", \
"Fixed device temperature if useHeatPort = false [K|degC]", 91, 293.15, 0.0,\
1E+100,300.0,0,560)
DeclareVariable("inverter1.transistor_p.idealGTOThyristor[3].LossPower", \
"Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter1.transistor_p.idealGTOThyristor[3].T_heatPort", \
"Temperature of heatPort [K|degC]", "inverter1.transistor_p.idealGTOThyristor[3].T", 1,\
 7, 91, 0)
DeclareVariable("inverter1.transistor_p.idealGTOThyristor[3].off", \
"Switching state [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter1.transistor_p.idealGTOThyristor[3].s", \
"Auxiliary variable for actual position on the ideal diode characteristic [1]", 0,\
 0.0,0.0,0.0,0,2560)
DeclareVariable("inverter1.transistor_p.idealGTOThyristor[3].unitVoltage", "[V]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("inverter1.transistor_p.idealGTOThyristor[3].unitCurrent", "[A]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("inverter1.transistor_p.idealGTOThyristor[3].fire", \
"[:#(type=Boolean)]", "inverter1.transistor_p.fire[3]", 1, 5, 799, 65)
DeclareVariable("inverter1.diode_p.m", "Number of phases [:#(type=Integer)]", 3,\
 1.0,1E+100,0.0,0,517)
DeclareVariable("inverter1.diode_p.v[1]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter1.diode_p.v[2]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter1.diode_p.v[3]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter1.diode_p.i[1]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter1.diode_p.i[2]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter1.diode_p.i[3]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter1.diode_p.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("inverter1.diode_p.plug_p.pin[1].v", "Potential at the pin [V]", \
"inverter1.ac.pin[1].v", 1, 5, 760, 4)
DeclareAlias2("inverter1.diode_p.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 "inverter1.diode_p.i[1]", 1, 5, 834, 132)
DeclareAlias2("inverter1.diode_p.plug_p.pin[2].v", "Potential at the pin [V]", \
"inverter1.ac.pin[2].v", 1, 5, 762, 4)
DeclareAlias2("inverter1.diode_p.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 "inverter1.diode_p.i[2]", 1, 5, 835, 132)
DeclareAlias2("inverter1.diode_p.plug_p.pin[3].v", "Potential at the pin [V]", \
"inverter1.ac.pin[3].v", 1, 5, 764, 4)
DeclareAlias2("inverter1.diode_p.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 "inverter1.diode_p.i[3]", 1, 5, 836, 132)
DeclareVariable("inverter1.diode_p.plug_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("inverter1.diode_p.plug_n.pin[1].v", "Potential at the pin [V]", \
"inverter1.dc_p.v", 1, 5, 755, 4)
DeclareAlias2("inverter1.diode_p.plug_n.pin[1].i", "Current flowing into the pin [A]",\
 "inverter1.diode_p.i[1]", -1, 5, 834, 132)
DeclareAlias2("inverter1.diode_p.plug_n.pin[2].v", "Potential at the pin [V]", \
"inverter1.dc_p.v", 1, 5, 755, 4)
DeclareAlias2("inverter1.diode_p.plug_n.pin[2].i", "Current flowing into the pin [A]",\
 "inverter1.diode_p.i[2]", -1, 5, 835, 132)
DeclareAlias2("inverter1.diode_p.plug_n.pin[3].v", "Potential at the pin [V]", \
"inverter1.dc_p.v", 1, 5, 755, 4)
DeclareAlias2("inverter1.diode_p.plug_n.pin[3].i", "Current flowing into the pin [A]",\
 "inverter1.diode_p.i[3]", -1, 5, 836, 132)
DeclareVariable("inverter1.diode_p.Ron[1]", "Closed diode resistance [Ohm]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_p.Ron[2]", "Closed diode resistance [Ohm]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_p.Ron[3]", "Closed diode resistance [Ohm]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_p.Goff[1]", "Opened diode conductance [S]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_p.Goff[2]", "Opened diode conductance [S]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_p.Goff[3]", "Opened diode conductance [S]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_p.Vknee[1]", "Threshold voltage [V]", 0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_p.Vknee[2]", "Threshold voltage [V]", 0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_p.Vknee[3]", "Threshold voltage [V]", 0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_p.mh", "Number of heatPorts=number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("inverter1.diode_p.useHeatPort", "=true, if all heat ports are enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("inverter1.diode_p.T[1]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter1.diode_p.T[2]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter1.diode_p.T[3]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter1.diode_p.idealDiode[1].v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter1.diode_p.idealDiode[1].i", "Current flowing from pin p to pin n [A]",\
 "inverter1.diode_p.i[1]", 1, 5, 834, 0)
DeclareAlias2("inverter1.diode_p.idealDiode[1].p.v", "Potential at the pin [V]",\
 "inverter1.ac.pin[1].v", 1, 5, 760, 4)
DeclareAlias2("inverter1.diode_p.idealDiode[1].p.i", "Current flowing into the pin [A]",\
 "inverter1.diode_p.i[1]", 1, 5, 834, 132)
DeclareAlias2("inverter1.diode_p.idealDiode[1].n.v", "Potential at the pin [V]",\
 "inverter1.dc_p.v", 1, 5, 755, 4)
DeclareAlias2("inverter1.diode_p.idealDiode[1].n.i", "Current flowing into the pin [A]",\
 "inverter1.diode_p.i[1]", -1, 5, 834, 132)
DeclareVariable("inverter1.diode_p.idealDiode[1].Ron", "Forward state-on differential resistance (closed resistance) [Ohm]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_p.idealDiode[1].Goff", "Backward state-off conductance (opened conductance) [S]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_p.idealDiode[1].Vknee", "Forward threshold voltage [V]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_p.idealDiode[1].useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter1.diode_p.idealDiode[1].T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 92, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("inverter1.diode_p.idealDiode[1].LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter1.diode_p.idealDiode[1].T_heatPort", "Temperature of heatPort [K|degC]",\
 "inverter1.diode_p.idealDiode[1].T", 1, 7, 92, 0)
DeclareVariable("inverter1.diode_p.idealDiode[1].off", "Switching state [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter1.diode_p.idealDiode[1].s", "Auxiliary variable for actual position on the ideal diode characteristic [1]",\
 0, 0.0,0.0,0.0,0,2560)
DeclareVariable("inverter1.diode_p.idealDiode[1].unitVoltage", "[V]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter1.diode_p.idealDiode[1].unitCurrent", "[A]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter1.diode_p.idealDiode[2].v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter1.diode_p.idealDiode[2].i", "Current flowing from pin p to pin n [A]",\
 "inverter1.diode_p.i[2]", 1, 5, 835, 0)
DeclareAlias2("inverter1.diode_p.idealDiode[2].p.v", "Potential at the pin [V]",\
 "inverter1.ac.pin[2].v", 1, 5, 762, 4)
DeclareAlias2("inverter1.diode_p.idealDiode[2].p.i", "Current flowing into the pin [A]",\
 "inverter1.diode_p.i[2]", 1, 5, 835, 132)
DeclareAlias2("inverter1.diode_p.idealDiode[2].n.v", "Potential at the pin [V]",\
 "inverter1.dc_p.v", 1, 5, 755, 4)
DeclareAlias2("inverter1.diode_p.idealDiode[2].n.i", "Current flowing into the pin [A]",\
 "inverter1.diode_p.i[2]", -1, 5, 835, 132)
DeclareVariable("inverter1.diode_p.idealDiode[2].Ron", "Forward state-on differential resistance (closed resistance) [Ohm]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_p.idealDiode[2].Goff", "Backward state-off conductance (opened conductance) [S]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_p.idealDiode[2].Vknee", "Forward threshold voltage [V]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_p.idealDiode[2].useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter1.diode_p.idealDiode[2].T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 93, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("inverter1.diode_p.idealDiode[2].LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter1.diode_p.idealDiode[2].T_heatPort", "Temperature of heatPort [K|degC]",\
 "inverter1.diode_p.idealDiode[2].T", 1, 7, 93, 0)
DeclareVariable("inverter1.diode_p.idealDiode[2].off", "Switching state [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter1.diode_p.idealDiode[2].s", "Auxiliary variable for actual position on the ideal diode characteristic [1]",\
 0, 0.0,0.0,0.0,0,2560)
DeclareVariable("inverter1.diode_p.idealDiode[2].unitVoltage", "[V]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter1.diode_p.idealDiode[2].unitCurrent", "[A]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter1.diode_p.idealDiode[3].v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter1.diode_p.idealDiode[3].i", "Current flowing from pin p to pin n [A]",\
 "inverter1.diode_p.i[3]", 1, 5, 836, 0)
DeclareAlias2("inverter1.diode_p.idealDiode[3].p.v", "Potential at the pin [V]",\
 "inverter1.ac.pin[3].v", 1, 5, 764, 4)
DeclareAlias2("inverter1.diode_p.idealDiode[3].p.i", "Current flowing into the pin [A]",\
 "inverter1.diode_p.i[3]", 1, 5, 836, 132)
DeclareAlias2("inverter1.diode_p.idealDiode[3].n.v", "Potential at the pin [V]",\
 "inverter1.dc_p.v", 1, 5, 755, 4)
DeclareAlias2("inverter1.diode_p.idealDiode[3].n.i", "Current flowing into the pin [A]",\
 "inverter1.diode_p.i[3]", -1, 5, 836, 132)
DeclareVariable("inverter1.diode_p.idealDiode[3].Ron", "Forward state-on differential resistance (closed resistance) [Ohm]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_p.idealDiode[3].Goff", "Backward state-off conductance (opened conductance) [S]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_p.idealDiode[3].Vknee", "Forward threshold voltage [V]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_p.idealDiode[3].useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter1.diode_p.idealDiode[3].T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 94, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("inverter1.diode_p.idealDiode[3].LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter1.diode_p.idealDiode[3].T_heatPort", "Temperature of heatPort [K|degC]",\
 "inverter1.diode_p.idealDiode[3].T", 1, 7, 94, 0)
DeclareVariable("inverter1.diode_p.idealDiode[3].off", "Switching state [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter1.diode_p.idealDiode[3].s", "Auxiliary variable for actual position on the ideal diode characteristic [1]",\
 0, 0.0,0.0,0.0,0,2560)
DeclareVariable("inverter1.diode_p.idealDiode[3].unitVoltage", "[V]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter1.diode_p.idealDiode[3].unitCurrent", "[A]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter1.star_p.m", "Number of phases [:#(type=Integer)]", 3, \
1.0,1E+100,0.0,0,517)
DeclareVariable("inverter1.star_p.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("inverter1.star_p.plug_p.pin[1].v", "Potential at the pin [V]", \
"inverter1.dc_p.v", 1, 5, 755, 4)
DeclareVariable("inverter1.star_p.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("inverter1.star_p.plug_p.pin[2].v", "Potential at the pin [V]", \
"inverter1.dc_p.v", 1, 5, 755, 4)
DeclareVariable("inverter1.star_p.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("inverter1.star_p.plug_p.pin[3].v", "Potential at the pin [V]", \
"inverter1.dc_p.v", 1, 5, 755, 4)
DeclareVariable("inverter1.star_p.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("inverter1.star_p.pin_n.v", "Potential at the pin [V]", \
"inverter1.dc_p.v", 1, 5, 755, 4)
DeclareAlias2("inverter1.star_p.pin_n.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", 1, 1, 16, 132)
DeclareVariable("inverter1.transistor_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("inverter1.transistor_n.v[1]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter1.transistor_n.v[2]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter1.transistor_n.v[3]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter1.transistor_n.i[1]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter1.transistor_n.i[2]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter1.transistor_n.i[3]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter1.transistor_n.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("inverter1.transistor_n.plug_p.pin[1].v", "Potential at the pin [V]",\
 "inverter1.ac.pin[1].v", 1, 5, 760, 4)
DeclareAlias2("inverter1.transistor_n.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 "inverter1.transistor_n.i[1]", 1, 5, 892, 132)
DeclareAlias2("inverter1.transistor_n.plug_p.pin[2].v", "Potential at the pin [V]",\
 "inverter1.ac.pin[2].v", 1, 5, 762, 4)
DeclareAlias2("inverter1.transistor_n.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 "inverter1.transistor_n.i[2]", 1, 5, 893, 132)
DeclareAlias2("inverter1.transistor_n.plug_p.pin[3].v", "Potential at the pin [V]",\
 "inverter1.ac.pin[3].v", 1, 5, 764, 4)
DeclareAlias2("inverter1.transistor_n.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 "inverter1.transistor_n.i[3]", 1, 5, 894, 132)
DeclareVariable("inverter1.transistor_n.plug_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("inverter1.transistor_n.plug_n.pin[1].v", "Potential at the pin [V]",\
 "inverter1.dc_n.v", 1, 5, 756, 4)
DeclareAlias2("inverter1.transistor_n.plug_n.pin[1].i", "Current flowing into the pin [A]",\
 "inverter1.transistor_n.i[1]", -1, 5, 892, 132)
DeclareAlias2("inverter1.transistor_n.plug_n.pin[2].v", "Potential at the pin [V]",\
 "inverter1.dc_n.v", 1, 5, 756, 4)
DeclareAlias2("inverter1.transistor_n.plug_n.pin[2].i", "Current flowing into the pin [A]",\
 "inverter1.transistor_n.i[2]", -1, 5, 893, 132)
DeclareAlias2("inverter1.transistor_n.plug_n.pin[3].v", "Potential at the pin [V]",\
 "inverter1.dc_n.v", 1, 5, 756, 4)
DeclareAlias2("inverter1.transistor_n.plug_n.pin[3].i", "Current flowing into the pin [A]",\
 "inverter1.transistor_n.i[3]", -1, 5, 894, 132)
DeclareVariable("inverter1.transistor_n.Ron[1]", "Closed thyristor resistance [Ohm]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_n.Ron[2]", "Closed thyristor resistance [Ohm]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_n.Ron[3]", "Closed thyristor resistance [Ohm]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_n.Goff[1]", "Opened thyristor conductance [S]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_n.Goff[2]", "Opened thyristor conductance [S]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_n.Goff[3]", "Opened thyristor conductance [S]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_n.Vknee[1]", "Threshold voltage [V]", 0, \
0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_n.Vknee[2]", "Threshold voltage [V]", 0, \
0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_n.Vknee[3]", "Threshold voltage [V]", 0, \
0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_n.mh", "Number of heatPorts=number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("inverter1.transistor_n.useHeatPort", "=true, if all heat ports are enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("inverter1.transistor_n.T[1]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter1.transistor_n.T[2]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter1.transistor_n.T[3]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter1.transistor_n.fire[1]", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,642)
DeclareVariable("inverter1.transistor_n.fire[2]", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,642)
DeclareVariable("inverter1.transistor_n.fire[3]", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,642)
DeclareVariable("inverter1.transistor_n.idealGTOThyristor[1].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter1.transistor_n.idealGTOThyristor[1].i", "Current flowing from pin p to pin n [A]",\
 "inverter1.transistor_n.i[1]", 1, 5, 892, 0)
DeclareAlias2("inverter1.transistor_n.idealGTOThyristor[1].p.v", \
"Potential at the pin [V]", "inverter1.ac.pin[1].v", 1, 5, 760, 4)
DeclareAlias2("inverter1.transistor_n.idealGTOThyristor[1].p.i", \
"Current flowing into the pin [A]", "inverter1.transistor_n.i[1]", 1, 5, 892, 132)
DeclareAlias2("inverter1.transistor_n.idealGTOThyristor[1].n.v", \
"Potential at the pin [V]", "inverter1.dc_n.v", 1, 5, 756, 4)
DeclareAlias2("inverter1.transistor_n.idealGTOThyristor[1].n.i", \
"Current flowing into the pin [A]", "inverter1.transistor_n.i[1]", -1, 5, 892, 132)
DeclareVariable("inverter1.transistor_n.idealGTOThyristor[1].Ron", \
"Forward state-on differential resistance (closed resistance) [Ohm]", 0.0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_n.idealGTOThyristor[1].Goff", \
"Backward state-off conductance (opened conductance) [S]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_n.idealGTOThyristor[1].Vknee", \
"Forward threshold voltage [V]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_n.idealGTOThyristor[1].useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter1.transistor_n.idealGTOThyristor[1].T", \
"Fixed device temperature if useHeatPort = false [K|degC]", 95, 293.15, 0.0,\
1E+100,300.0,0,560)
DeclareVariable("inverter1.transistor_n.idealGTOThyristor[1].LossPower", \
"Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter1.transistor_n.idealGTOThyristor[1].T_heatPort", \
"Temperature of heatPort [K|degC]", "inverter1.transistor_n.idealGTOThyristor[1].T", 1,\
 7, 95, 0)
DeclareVariable("inverter1.transistor_n.idealGTOThyristor[1].off", \
"Switching state [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter1.transistor_n.idealGTOThyristor[1].s", \
"Auxiliary variable for actual position on the ideal diode characteristic [1]", 0,\
 0.0,0.0,0.0,0,2560)
DeclareVariable("inverter1.transistor_n.idealGTOThyristor[1].unitVoltage", "[V]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("inverter1.transistor_n.idealGTOThyristor[1].unitCurrent", "[A]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("inverter1.transistor_n.idealGTOThyristor[1].fire", \
"[:#(type=Boolean)]", "inverter1.transistor_n.fire[1]", 1, 5, 911, 65)
DeclareVariable("inverter1.transistor_n.idealGTOThyristor[2].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter1.transistor_n.idealGTOThyristor[2].i", "Current flowing from pin p to pin n [A]",\
 "inverter1.transistor_n.i[2]", 1, 5, 893, 0)
DeclareAlias2("inverter1.transistor_n.idealGTOThyristor[2].p.v", \
"Potential at the pin [V]", "inverter1.ac.pin[2].v", 1, 5, 762, 4)
DeclareAlias2("inverter1.transistor_n.idealGTOThyristor[2].p.i", \
"Current flowing into the pin [A]", "inverter1.transistor_n.i[2]", 1, 5, 893, 132)
DeclareAlias2("inverter1.transistor_n.idealGTOThyristor[2].n.v", \
"Potential at the pin [V]", "inverter1.dc_n.v", 1, 5, 756, 4)
DeclareAlias2("inverter1.transistor_n.idealGTOThyristor[2].n.i", \
"Current flowing into the pin [A]", "inverter1.transistor_n.i[2]", -1, 5, 893, 132)
DeclareVariable("inverter1.transistor_n.idealGTOThyristor[2].Ron", \
"Forward state-on differential resistance (closed resistance) [Ohm]", 0.0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_n.idealGTOThyristor[2].Goff", \
"Backward state-off conductance (opened conductance) [S]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_n.idealGTOThyristor[2].Vknee", \
"Forward threshold voltage [V]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_n.idealGTOThyristor[2].useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter1.transistor_n.idealGTOThyristor[2].T", \
"Fixed device temperature if useHeatPort = false [K|degC]", 96, 293.15, 0.0,\
1E+100,300.0,0,560)
DeclareVariable("inverter1.transistor_n.idealGTOThyristor[2].LossPower", \
"Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter1.transistor_n.idealGTOThyristor[2].T_heatPort", \
"Temperature of heatPort [K|degC]", "inverter1.transistor_n.idealGTOThyristor[2].T", 1,\
 7, 96, 0)
DeclareVariable("inverter1.transistor_n.idealGTOThyristor[2].off", \
"Switching state [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter1.transistor_n.idealGTOThyristor[2].s", \
"Auxiliary variable for actual position on the ideal diode characteristic [1]", 0,\
 0.0,0.0,0.0,0,2560)
DeclareVariable("inverter1.transistor_n.idealGTOThyristor[2].unitVoltage", "[V]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("inverter1.transistor_n.idealGTOThyristor[2].unitCurrent", "[A]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("inverter1.transistor_n.idealGTOThyristor[2].fire", \
"[:#(type=Boolean)]", "inverter1.transistor_n.fire[2]", 1, 5, 912, 65)
DeclareVariable("inverter1.transistor_n.idealGTOThyristor[3].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter1.transistor_n.idealGTOThyristor[3].i", "Current flowing from pin p to pin n [A]",\
 "inverter1.transistor_n.i[3]", 1, 5, 894, 0)
DeclareAlias2("inverter1.transistor_n.idealGTOThyristor[3].p.v", \
"Potential at the pin [V]", "inverter1.ac.pin[3].v", 1, 5, 764, 4)
DeclareAlias2("inverter1.transistor_n.idealGTOThyristor[3].p.i", \
"Current flowing into the pin [A]", "inverter1.transistor_n.i[3]", 1, 5, 894, 132)
DeclareAlias2("inverter1.transistor_n.idealGTOThyristor[3].n.v", \
"Potential at the pin [V]", "inverter1.dc_n.v", 1, 5, 756, 4)
DeclareAlias2("inverter1.transistor_n.idealGTOThyristor[3].n.i", \
"Current flowing into the pin [A]", "inverter1.transistor_n.i[3]", -1, 5, 894, 132)
DeclareVariable("inverter1.transistor_n.idealGTOThyristor[3].Ron", \
"Forward state-on differential resistance (closed resistance) [Ohm]", 0.0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_n.idealGTOThyristor[3].Goff", \
"Backward state-off conductance (opened conductance) [S]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_n.idealGTOThyristor[3].Vknee", \
"Forward threshold voltage [V]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.transistor_n.idealGTOThyristor[3].useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter1.transistor_n.idealGTOThyristor[3].T", \
"Fixed device temperature if useHeatPort = false [K|degC]", 97, 293.15, 0.0,\
1E+100,300.0,0,560)
DeclareVariable("inverter1.transistor_n.idealGTOThyristor[3].LossPower", \
"Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter1.transistor_n.idealGTOThyristor[3].T_heatPort", \
"Temperature of heatPort [K|degC]", "inverter1.transistor_n.idealGTOThyristor[3].T", 1,\
 7, 97, 0)
DeclareVariable("inverter1.transistor_n.idealGTOThyristor[3].off", \
"Switching state [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter1.transistor_n.idealGTOThyristor[3].s", \
"Auxiliary variable for actual position on the ideal diode characteristic [1]", 0,\
 0.0,0.0,0.0,0,2560)
DeclareVariable("inverter1.transistor_n.idealGTOThyristor[3].unitVoltage", "[V]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("inverter1.transistor_n.idealGTOThyristor[3].unitCurrent", "[A]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("inverter1.transistor_n.idealGTOThyristor[3].fire", \
"[:#(type=Boolean)]", "inverter1.transistor_n.fire[3]", 1, 5, 913, 65)
DeclareVariable("inverter1.diode_n.m", "Number of phases [:#(type=Integer)]", 3,\
 1.0,1E+100,0.0,0,517)
DeclareVariable("inverter1.diode_n.v[1]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter1.diode_n.v[2]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter1.diode_n.v[3]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter1.diode_n.i[1]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter1.diode_n.i[2]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter1.diode_n.i[3]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter1.diode_n.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("inverter1.diode_n.plug_p.pin[1].v", "Potential at the pin [V]", \
"inverter1.dc_n.v", 1, 5, 756, 4)
DeclareAlias2("inverter1.diode_n.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 "inverter1.diode_n.i[1]", 1, 5, 948, 132)
DeclareAlias2("inverter1.diode_n.plug_p.pin[2].v", "Potential at the pin [V]", \
"inverter1.dc_n.v", 1, 5, 756, 4)
DeclareAlias2("inverter1.diode_n.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 "inverter1.diode_n.i[2]", 1, 5, 949, 132)
DeclareAlias2("inverter1.diode_n.plug_p.pin[3].v", "Potential at the pin [V]", \
"inverter1.dc_n.v", 1, 5, 756, 4)
DeclareAlias2("inverter1.diode_n.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 "inverter1.diode_n.i[3]", 1, 5, 950, 132)
DeclareVariable("inverter1.diode_n.plug_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("inverter1.diode_n.plug_n.pin[1].v", "Potential at the pin [V]", \
"inverter1.ac.pin[1].v", 1, 5, 760, 4)
DeclareAlias2("inverter1.diode_n.plug_n.pin[1].i", "Current flowing into the pin [A]",\
 "inverter1.diode_n.i[1]", -1, 5, 948, 132)
DeclareAlias2("inverter1.diode_n.plug_n.pin[2].v", "Potential at the pin [V]", \
"inverter1.ac.pin[2].v", 1, 5, 762, 4)
DeclareAlias2("inverter1.diode_n.plug_n.pin[2].i", "Current flowing into the pin [A]",\
 "inverter1.diode_n.i[2]", -1, 5, 949, 132)
DeclareAlias2("inverter1.diode_n.plug_n.pin[3].v", "Potential at the pin [V]", \
"inverter1.ac.pin[3].v", 1, 5, 764, 4)
DeclareAlias2("inverter1.diode_n.plug_n.pin[3].i", "Current flowing into the pin [A]",\
 "inverter1.diode_n.i[3]", -1, 5, 950, 132)
DeclareVariable("inverter1.diode_n.Ron[1]", "Closed diode resistance [Ohm]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_n.Ron[2]", "Closed diode resistance [Ohm]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_n.Ron[3]", "Closed diode resistance [Ohm]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_n.Goff[1]", "Opened diode conductance [S]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_n.Goff[2]", "Opened diode conductance [S]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_n.Goff[3]", "Opened diode conductance [S]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_n.Vknee[1]", "Threshold voltage [V]", 0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_n.Vknee[2]", "Threshold voltage [V]", 0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_n.Vknee[3]", "Threshold voltage [V]", 0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_n.mh", "Number of heatPorts=number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("inverter1.diode_n.useHeatPort", "=true, if all heat ports are enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("inverter1.diode_n.T[1]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter1.diode_n.T[2]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter1.diode_n.T[3]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter1.diode_n.idealDiode[1].v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter1.diode_n.idealDiode[1].i", "Current flowing from pin p to pin n [A]",\
 "inverter1.diode_n.i[1]", 1, 5, 948, 0)
DeclareAlias2("inverter1.diode_n.idealDiode[1].p.v", "Potential at the pin [V]",\
 "inverter1.dc_n.v", 1, 5, 756, 4)
DeclareAlias2("inverter1.diode_n.idealDiode[1].p.i", "Current flowing into the pin [A]",\
 "inverter1.diode_n.i[1]", 1, 5, 948, 132)
DeclareAlias2("inverter1.diode_n.idealDiode[1].n.v", "Potential at the pin [V]",\
 "inverter1.ac.pin[1].v", 1, 5, 760, 4)
DeclareAlias2("inverter1.diode_n.idealDiode[1].n.i", "Current flowing into the pin [A]",\
 "inverter1.diode_n.i[1]", -1, 5, 948, 132)
DeclareVariable("inverter1.diode_n.idealDiode[1].Ron", "Forward state-on differential resistance (closed resistance) [Ohm]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_n.idealDiode[1].Goff", "Backward state-off conductance (opened conductance) [S]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_n.idealDiode[1].Vknee", "Forward threshold voltage [V]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_n.idealDiode[1].useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter1.diode_n.idealDiode[1].T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 98, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("inverter1.diode_n.idealDiode[1].LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter1.diode_n.idealDiode[1].T_heatPort", "Temperature of heatPort [K|degC]",\
 "inverter1.diode_n.idealDiode[1].T", 1, 7, 98, 0)
DeclareVariable("inverter1.diode_n.idealDiode[1].off", "Switching state [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter1.diode_n.idealDiode[1].s", "Auxiliary variable for actual position on the ideal diode characteristic [1]",\
 0, 0.0,0.0,0.0,0,2560)
DeclareVariable("inverter1.diode_n.idealDiode[1].unitVoltage", "[V]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter1.diode_n.idealDiode[1].unitCurrent", "[A]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter1.diode_n.idealDiode[2].v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter1.diode_n.idealDiode[2].i", "Current flowing from pin p to pin n [A]",\
 "inverter1.diode_n.i[2]", 1, 5, 949, 0)
DeclareAlias2("inverter1.diode_n.idealDiode[2].p.v", "Potential at the pin [V]",\
 "inverter1.dc_n.v", 1, 5, 756, 4)
DeclareAlias2("inverter1.diode_n.idealDiode[2].p.i", "Current flowing into the pin [A]",\
 "inverter1.diode_n.i[2]", 1, 5, 949, 132)
DeclareAlias2("inverter1.diode_n.idealDiode[2].n.v", "Potential at the pin [V]",\
 "inverter1.ac.pin[2].v", 1, 5, 762, 4)
DeclareAlias2("inverter1.diode_n.idealDiode[2].n.i", "Current flowing into the pin [A]",\
 "inverter1.diode_n.i[2]", -1, 5, 949, 132)
DeclareVariable("inverter1.diode_n.idealDiode[2].Ron", "Forward state-on differential resistance (closed resistance) [Ohm]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_n.idealDiode[2].Goff", "Backward state-off conductance (opened conductance) [S]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_n.idealDiode[2].Vknee", "Forward threshold voltage [V]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_n.idealDiode[2].useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter1.diode_n.idealDiode[2].T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 99, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("inverter1.diode_n.idealDiode[2].LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter1.diode_n.idealDiode[2].T_heatPort", "Temperature of heatPort [K|degC]",\
 "inverter1.diode_n.idealDiode[2].T", 1, 7, 99, 0)
DeclareVariable("inverter1.diode_n.idealDiode[2].off", "Switching state [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter1.diode_n.idealDiode[2].s", "Auxiliary variable for actual position on the ideal diode characteristic [1]",\
 0, 0.0,0.0,0.0,0,2560)
DeclareVariable("inverter1.diode_n.idealDiode[2].unitVoltage", "[V]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter1.diode_n.idealDiode[2].unitCurrent", "[A]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter1.diode_n.idealDiode[3].v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter1.diode_n.idealDiode[3].i", "Current flowing from pin p to pin n [A]",\
 "inverter1.diode_n.i[3]", 1, 5, 950, 0)
DeclareAlias2("inverter1.diode_n.idealDiode[3].p.v", "Potential at the pin [V]",\
 "inverter1.dc_n.v", 1, 5, 756, 4)
DeclareAlias2("inverter1.diode_n.idealDiode[3].p.i", "Current flowing into the pin [A]",\
 "inverter1.diode_n.i[3]", 1, 5, 950, 132)
DeclareAlias2("inverter1.diode_n.idealDiode[3].n.v", "Potential at the pin [V]",\
 "inverter1.ac.pin[3].v", 1, 5, 764, 4)
DeclareAlias2("inverter1.diode_n.idealDiode[3].n.i", "Current flowing into the pin [A]",\
 "inverter1.diode_n.i[3]", -1, 5, 950, 132)
DeclareVariable("inverter1.diode_n.idealDiode[3].Ron", "Forward state-on differential resistance (closed resistance) [Ohm]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_n.idealDiode[3].Goff", "Backward state-off conductance (opened conductance) [S]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_n.idealDiode[3].Vknee", "Forward threshold voltage [V]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter1.diode_n.idealDiode[3].useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter1.diode_n.idealDiode[3].T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 100, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("inverter1.diode_n.idealDiode[3].LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter1.diode_n.idealDiode[3].T_heatPort", "Temperature of heatPort [K|degC]",\
 "inverter1.diode_n.idealDiode[3].T", 1, 7, 100, 0)
DeclareVariable("inverter1.diode_n.idealDiode[3].off", "Switching state [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter1.diode_n.idealDiode[3].s", "Auxiliary variable for actual position on the ideal diode characteristic [1]",\
 0, 0.0,0.0,0.0,0,2560)
DeclareVariable("inverter1.diode_n.idealDiode[3].unitVoltage", "[V]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter1.diode_n.idealDiode[3].unitCurrent", "[A]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter1.star_n.m", "Number of phases [:#(type=Integer)]", 3, \
1.0,1E+100,0.0,0,517)
DeclareVariable("inverter1.star_n.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("inverter1.star_n.plug_p.pin[1].v", "Potential at the pin [V]", \
"inverter1.dc_n.v", 1, 5, 756, 4)
DeclareVariable("inverter1.star_n.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("inverter1.star_n.plug_p.pin[2].v", "Potential at the pin [V]", \
"inverter1.dc_n.v", 1, 5, 756, 4)
DeclareVariable("inverter1.star_n.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("inverter1.star_n.plug_p.pin[3].v", "Potential at the pin [V]", \
"inverter1.dc_n.v", 1, 5, 756, 4)
DeclareVariable("inverter1.star_n.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("inverter1.star_n.pin_n.v", "Potential at the pin [V]", \
"inverter1.dc_n.v", 1, 5, 756, 4)
DeclareAlias2("inverter1.star_n.pin_n.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", -1, 1, 16, 132)
DeclareParameter("dcdc1.RonTransistor", "Transistor closed resistance [Ohm]", 101,\
 1E-05, 0.0,0.0,0.0,0,560)
DeclareParameter("dcdc1.GoffTransistor", "Transistor opened conductance [S]", 102,\
 1E-05, 0.0,0.0,0.0,0,560)
DeclareParameter("dcdc1.VkneeTransistor", "Transistor threshold voltage [V]", 103,\
 0, 0.0,0.0,0.0,0,560)
DeclareParameter("dcdc1.RonDiode", "Closed diode resistance [Ohm]", 104, 1E-05, \
0.0,1E+100,0.0,0,560)
DeclareParameter("dcdc1.GoffDiode", "Opened diode conductance [S]", 105, 1E-05, \
0.0,1E+100,0.0,0,560)
DeclareParameter("dcdc1.VkneeDiode", "Diode forward threshold voltage [V]", 106,\
 0, 0.0,1E+100,0.0,0,560)
DeclareVariable("dcdc1.dc_p1.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareVariable("dcdc1.dc_p1.i", "Current flowing into the pin [A]", 0.0, \
0.0,0.0,0.0,0,777)
DeclareVariable("dcdc1.dc_n1.v", "Potential at the pin [V]", 0, 0.0,0.0,0.0,0,521)
DeclareVariable("dcdc1.dc_n1.i", "Current flowing into the pin [A]", 0.0, \
0.0,0.0,0.0,0,777)
DeclareAlias2("dcdc1.vDC1", "DC voltage side 1 [V]", "dcdc1.dc_p1.v", 1, 5, 1002,\
 0)
DeclareVariable("dcdc1.iDC1", "DC current side 1 [A]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("dcdc1.powerDC1", "DC power side 1 [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("dcdc1.dc_p2.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("dcdc1.dc_p2.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", -1, 1, 16, 132)
DeclareVariable("dcdc1.dc_n2.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("dcdc1.dc_n2.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", 1, 1, 16, 132)
DeclareAlias2("dcdc1.vDC2", "DC voltages side 2 [V]", "dcdc1.dc_p2.v", 1, 5, 1008,\
 0)
DeclareAlias2("dcdc1.iDC2", "DC current side 2 [A]", "simpleLine2.inductor.i", -1,\
 1, 16, 0)
DeclareVariable("dcdc1.powerDC2", "DC power side 2 [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("dcdc1.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("dcdc1.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("dcdc1.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("dcdc1.T_heatPort", "Temperature of heatPort [K|degC]", 293.15, \
0.0,1E+100,300.0,0,513)
DeclareVariable("dcdc1.useConstantEnable", "true = disabled boolean input, use constantEnable [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("dcdc1.constantEnable", "Constant enabling of firing signals [:#(type=Boolean)]",\
 107, true, 0.0,0.0,0.0,0,562)
DeclareVariable("dcdc1.m", "Number of phases [:#(type=Integer)]", 1, 1.0,1E+100,\
0.0,0,517)
DeclareVariable("dcdc1.enableLogic.useConstantEnable", "true = disabled boolean input, use constantEnable [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("dcdc1.enableLogic.constantEnable", "Constant enabling of firing signals [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("dcdc1.enableLogic.m", "Number of phases [:#(type=Integer)]", 1,\
 1.0,1E+100,0.0,0,517)
DeclareVariable("dcdc1.enableLogic.enableConstantSource.k", "Constant output value [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("dcdc1.enableLogic.enableConstantSource.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "dcdc1.enableLogic.enableConstantSource.k", 1, 5, 1020, 65)
DeclareVariable("dcdc1.enableLogic.booleanReplicator.nout", "Number of outputs [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,517)
DeclareAlias2("dcdc1.enableLogic.booleanReplicator.u", "Connector of Boolean input signal [:#(type=Boolean)]",\
 "dcdc1.enableLogic.enableConstantSource.k", 1, 5, 1020, 65)
DeclareAlias2("dcdc1.enableLogic.booleanReplicator.y[1]", "Connector of Boolean output signals [:#(type=Boolean)]",\
 "dcdc1.enableLogic.enableConstantSource.k", 1, 5, 1020, 65)
DeclareAlias2("dcdc1.enableLogic.internalEnable[1]", "m replicated enable signals [:#(type=Boolean)]",\
 "dcdc1.enableLogic.enableConstantSource.k", 1, 5, 1020, 65)
DeclareAlias2("dcdc1.andCondition_p.u1", "Connector of first Boolean input signal [:#(type=Boolean)]",\
 "dcdc1.fire_p", 1, 5, 1023, 65)
DeclareAlias2("dcdc1.andCondition_p.u2", "Connector of second Boolean input signal [:#(type=Boolean)]",\
 "dcdc1.enableLogic.enableConstantSource.k", 1, 5, 1020, 65)
DeclareVariable("dcdc1.andCondition_p.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,642)
DeclareVariable("dcdc1.fire_p", "Firing signal of positive potential transistor [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,642)
DeclareAlias2("dcdc1.transistor.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 "dcdc1.dc_p1.v", 1, 5, 1002, 0)
DeclareAlias2("dcdc1.transistor.i", "Current flowing from pin p to pin n [A]", \
"simpleLine2.inductor.i", -1, 1, 16, 0)
DeclareAlias2("dcdc1.transistor.p.v", "Potential at the pin [V]", \
"dcdc1.dc_p1.v", 1, 5, 1002, 4)
DeclareAlias2("dcdc1.transistor.p.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", -1, 1, 16, 132)
DeclareVariable("dcdc1.transistor.n.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,521)
DeclareAlias2("dcdc1.transistor.n.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", 1, 1, 16, 132)
DeclareVariable("dcdc1.transistor.Ron", "Forward state-on differential resistance (closed resistance) [Ohm]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("dcdc1.transistor.Goff", "Backward state-off conductance (opened conductance) [S]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("dcdc1.transistor.Vknee", "Forward threshold voltage [V]", 0.0, \
0.0,1E+100,0.0,0,513)
DeclareVariable("dcdc1.transistor.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("dcdc1.transistor.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 108, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("dcdc1.transistor.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dcdc1.transistor.T_heatPort", "Temperature of heatPort [K|degC]",\
 "dcdc1.transistor.T", 1, 7, 108, 0)
DeclareVariable("dcdc1.transistor.off", "Switching state [:#(type=Boolean)]", \
true, 0.0,0.0,0.0,0,706)
DeclareVariable("dcdc1.transistor.s", "Auxiliary variable for actual position on the ideal diode characteristic [1]",\
 0, 0.0,0.0,0.0,0,2560)
DeclareVariable("dcdc1.transistor.unitVoltage", "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("dcdc1.transistor.unitCurrent", "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("dcdc1.transistor.fire", "[:#(type=Boolean)]", "dcdc1.andCondition_p.y", 1,\
 5, 1022, 65)
DeclareVariable("dcdc1.diode.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dcdc1.diode.i", "Current flowing from pin p to pin n [A]", \
"simpleLine2.inductor.i", 1, 1, 16, 0)
DeclareAlias2("dcdc1.diode.p.v", "Potential at the pin [V]", "dcdc1.dc_p1.v", 1,\
 5, 1002, 4)
DeclareAlias2("dcdc1.diode.p.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", 1, 1, 16, 132)
DeclareAlias2("dcdc1.diode.n.v", "Potential at the pin [V]", "dcdc1.dc_p2.v", 1,\
 5, 1008, 4)
DeclareAlias2("dcdc1.diode.n.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", -1, 1, 16, 132)
DeclareVariable("dcdc1.diode.Ron", "Forward state-on differential resistance (closed resistance) [Ohm]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("dcdc1.diode.Goff", "Backward state-off conductance (opened conductance) [S]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("dcdc1.diode.Vknee", "Forward threshold voltage [V]", 0.0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("dcdc1.diode.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("dcdc1.diode.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 109, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("dcdc1.diode.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dcdc1.diode.T_heatPort", "Temperature of heatPort [K|degC]", \
"dcdc1.diode.T", 1, 7, 109, 0)
DeclareVariable("dcdc1.diode.off", "Switching state [:#(type=Boolean)]", true, \
0.0,0.0,0.0,0,706)
DeclareVariable("dcdc1.diode.s", "Auxiliary variable for actual position on the ideal diode characteristic [1]",\
 0, 0.0,0.0,0.0,0,2560)
DeclareVariable("dcdc1.diode.unitVoltage", "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("dcdc1.diode.unitCurrent", "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("signalPWM1.useConstantDutyCycle", "Enables constant duty cycle [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("signalPWM1.constantDutyCycle", "Constant duty cycle", 110, 0.6,\
 0.0,0.0,0.0,0,560)
DeclareParameter("signalPWM1.f", "Switching frequency [Hz]", 111, 100, 0.0,0.0,\
0.0,0,560)
DeclareParameter("signalPWM1.startTime", "Start time [s]", 112, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("signalPWM1.fire", "Firing PWM signal [:#(type=Boolean)]", \
"dcdc1.fire_p", 1, 5, 1023, 65)
DeclareVariable("signalPWM1.notFire", "Firing PWM signal [:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,642)
DeclareVariable("signalPWM1.const.k", "Constant output value", 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("signalPWM1.const.y", "Connector of Real output signal", \
"signalPWM1.const.k", 1, 5, 1046, 0)
DeclareParameter("signalPWM1.limiter.uMax", "Upper limits of input signals", 113,\
 1, 0.0,0.0,0.0,0,560)
DeclareParameter("signalPWM1.limiter.uMin", "Lower limits of input signals", 114,\
 0, 0.0,0.0,0.0,0,560)
DeclareVariable("signalPWM1.limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("signalPWM1.limiter.homotopyType", "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("signalPWM1.limiter.limitsAtInit", "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("signalPWM1.limiter.u", "Connector of Real input signal", \
"signalPWM1.const.k", 1, 5, 1046, 0)
DeclareVariable("signalPWM1.limiter.y", "Connector of Real output signal", 0.0, \
0.0,0.0,0.0,0,513)
DeclareAlias2("signalPWM1.limiter.simplifiedExpr", "Simplified expression for homotopy-based initialization",\
 "signalPWM1.const.k", 1, 5, 1046, 1024)
DeclareVariable("signalPWM1.greaterEqual.u1", "Connector of first Real input signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("signalPWM1.greaterEqual.u2", "Connector of second Real input signal",\
 0.0, 0.0,0.0,0.0,0,640)
DeclareAlias2("signalPWM1.greaterEqual.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "dcdc1.fire_p", 1, 5, 1023, 65)
DeclareVariable("signalPWM1.zeroOrderHold.samplePeriod", "Sample period of component [s]",\
 0.1, 1E-13,1E+100,0.0,0,513)
DeclareVariable("signalPWM1.zeroOrderHold.startTime", "First sample time instant [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM1.zeroOrderHold.sampleTrigger", "True, if sample time instant [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2690)
DeclareVariable("signalPWM1.zeroOrderHold.firstTrigger", "Rising edge signals first sample instant [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2706)
DeclareAlias2("signalPWM1.zeroOrderHold.u", "Connector of Real input signal", \
"signalPWM1.limiter.y", 1, 5, 1050, 0)
DeclareAlias2("signalPWM1.zeroOrderHold.y", "Connector of Real output signal", \
"signalPWM1.greaterEqual.u2", 1, 5, 1052, 0)
DeclareVariable("signalPWM1.zeroOrderHold.ySample", "", 0, 0.0,0.0,0.0,0,656)
DeclareVariable("signalPWM1.sawtooth.amplitude", "Amplitude of saw tooth", 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM1.sawtooth.period", "Time for one period [s]", 1, \
1E-60,1E+100,0.0,0,513)
DeclareVariable("signalPWM1.sawtooth.nperiod", "Number of periods (< 0 means infinite number of periods) [:#(type=Integer)]",\
 -1, 0.0,0.0,0.0,0,517)
DeclareAlias2("signalPWM1.sawtooth.y", "Connector of Real output signal", \
"signalPWM1.greaterEqual.u1", 1, 5, 1051, 0)
DeclareVariable("signalPWM1.sawtooth.offset", "Offset of output signal y", 0, \
0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM1.sawtooth.startTime", "Output y = offset for time < startTime [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM1.sawtooth.T_start", "Start time of current period [s]",\
 0.0, 0.0,0.0,0.0,0,2688)
DeclareVariable("signalPWM1.sawtooth.count", "Period count [:#(type=Integer)]", 0,\
 0.0,0.0,0.0,0,2692)
DeclareAlias2("signalPWM1.inverse.u", "Connector of Boolean input signal [:#(type=Boolean)]",\
 "dcdc1.fire_p", 1, 5, 1023, 65)
DeclareAlias2("signalPWM1.inverse.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "signalPWM1.notFire", 1, 5, 1045, 65)
DeclareParameter("threePhaseMotor1.m", "Number of phases [:#(type=Integer)]", 115,\
 3, 0.0,0.0,0.0,0,564)
DeclareParameter("threePhaseMotor1.wref", "[rev/min]", 116, 4000, 0.0,0.0,0.0,0,560)
DeclareVariable("threePhaseMotor1.aimc.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("threePhaseMotor1.aimc.p", "Number of pole pairs (Integer) [:#(type=Integer)]",\
 2, 1.0,1E+100,0.0,0,517)
DeclareVariable("threePhaseMotor1.aimc.fsNominal", "Nominal frequency [Hz]", 50,\
 0.0,0.0,0.0,0,513)
DeclareParameter("threePhaseMotor1.aimc.TsOperational", "Operational temperature of stator resistance [K|degC]",\
 117, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("threePhaseMotor1.aimc.Rs", "Stator resistance per phase at TRef [Ohm]",\
 0.03, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.TsRef", "Reference temperature of stator resistance [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.alpha20s", "Temperature coefficient of stator resistance at 20 degC [1/K|1/K]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.Lszero", "Stator zero sequence inductance [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.Lssigma", "Stator stray inductance per phase [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.Jr", "Rotor's moment of inertia [kg.m2]",\
 0.29, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.useSupport", "Enable / disable (=fixed stator) support [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("threePhaseMotor1.aimc.Js", "Stator's moment of inertia [kg.m2]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.useThermalPort", "Enable / disable (=fixed temperatures) thermal port [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("threePhaseMotor1.aimc.frictionParameters.PRef", \
"Reference friction losses at wRef [W]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.frictionParameters.wRef", \
"Reference angular velocity that the PRef refer to [rad/s|rev/min]", 1E-60, \
1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.frictionParameters.power_w", \
"Exponent of friction torque w.r.t. angular velocity", 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.frictionParameters.tauRef", \
"Reference friction torque at reference angular velocity [N.m]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.frictionParameters.linear", \
"Linear angular velocity range with respect to reference angular velocity", \
0.001, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.frictionParameters.wLinear", \
"Linear angular velocity range [rad/s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.frictionParameters.tauLinear", \
"Torque corresponding with linear angular velocity range [N.m]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.phiMechanical", "Mechanical angle of rotor against stator [rad|deg]",\
 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor1.aimc.der(phiMechanical)", "der(Mechanical angle of rotor against stator) [rad/s]",\
 "fan1.inertia.w", 1, 1, 13, 0)
DeclareAlias2("threePhaseMotor1.aimc.wMechanical", "Mechanical angular velocity of rotor against stator [rad/s|rev/min]",\
 "fan1.inertia.w", 1, 1, 13, 0)
DeclareVariable("threePhaseMotor1.aimc.tauElectrical", "Electromagnetic torque [N.m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor1.aimc.tauShaft", "Shaft torque [N.m]", \
"threePhaseMotor1.flange1.tau", -1, 5, 1370, 0)
DeclareAlias2("threePhaseMotor1.aimc.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "variableSpeedDrive_ThreePhase1.speedSensor.flange.phi", 1, 1, 11, 4)
DeclareAlias2("threePhaseMotor1.aimc.flange.tau", "Cut torque in the flange [N.m]",\
 "threePhaseMotor1.flange1.tau", 1, 5, 1370, 132)
DeclareAlias2("threePhaseMotor1.aimc.inertiaRotor.flange_a.phi", \
"Absolute rotation angle of flange [rad|deg]", "variableSpeedDrive_ThreePhase1.speedSensor.flange.phi", 1,\
 1, 11, 4)
DeclareAlias2("threePhaseMotor1.aimc.inertiaRotor.flange_a.tau", \
"Cut torque in the flange [N.m]", "threePhaseMotor1.aimc.tauElectrical", 1, 5, 1085,\
 132)
DeclareAlias2("threePhaseMotor1.aimc.inertiaRotor.flange_b.phi", \
"Absolute rotation angle of flange [rad|deg]", "variableSpeedDrive_ThreePhase1.speedSensor.flange.phi", 1,\
 1, 11, 4)
DeclareAlias2("threePhaseMotor1.aimc.inertiaRotor.flange_b.tau", \
"Cut torque in the flange [N.m]", "threePhaseMotor1.flange1.tau", 1, 5, 1370, 132)
DeclareVariable("threePhaseMotor1.aimc.inertiaRotor.J", "Moment of inertia [kg.m2]",\
 1, 0.0,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.inertiaRotor.stateSelect", \
"Priority to use phi and w as states [:#(type=StateSelect)]", 3, 1.0,5.0,0.0,0,1541)
DeclareAlias2("threePhaseMotor1.aimc.inertiaRotor.phi", "Absolute rotation angle of component [rad|deg]",\
 "variableSpeedDrive_ThreePhase1.speedSensor.flange.phi", 1, 1, 11, 0)
DeclareAlias2("threePhaseMotor1.aimc.inertiaRotor.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 "fan1.inertia.w", 1, 1, 13, 0)
DeclareAlias2("threePhaseMotor1.aimc.inertiaRotor.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 "fan1.inertia.w", 1, 1, 13, 0)
DeclareAlias2("threePhaseMotor1.aimc.inertiaRotor.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 "fan1.inertia.der(w)", 1, 6, 13, 0)
DeclareAlias2("threePhaseMotor1.aimc.inertiaRotor.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "fan1.inertia.der(w)", 1, 6, 13, 0)
DeclareAlias2("threePhaseMotor1.aimc.inertiaStator.flange_a.phi", \
"Absolute rotation angle of flange [rad|deg]", "threePhaseMotor1.aimc.fixed.phi0", 1,\
 7, 118, 4)
DeclareVariable("threePhaseMotor1.aimc.inertiaStator.flange_a.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("threePhaseMotor1.aimc.inertiaStator.flange_b.phi", \
"Absolute rotation angle of flange [rad|deg]", "threePhaseMotor1.aimc.fixed.phi0", 1,\
 7, 118, 4)
DeclareVariable("threePhaseMotor1.aimc.inertiaStator.flange_b.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor1.aimc.inertiaStator.J", "Moment of inertia [kg.m2]",\
 1, 0.0,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.inertiaStator.stateSelect", \
"Priority to use phi and w as states [:#(type=StateSelect)]", 3, 1.0,5.0,0.0,0,1541)
DeclareAlias2("threePhaseMotor1.aimc.inertiaStator.phi", "Absolute rotation angle of component [rad|deg]",\
 "threePhaseMotor1.aimc.fixed.phi0", 1, 7, 118, 0)
DeclareVariable("threePhaseMotor1.aimc.inertiaStator.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.inertiaStator.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.inertiaStator.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.inertiaStator.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("threePhaseMotor1.aimc.fixed.phi0", "Fixed offset angle of housing [rad|deg]",\
 118, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("threePhaseMotor1.aimc.fixed.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "threePhaseMotor1.aimc.fixed.phi0", 1, 7, 118, 4)
DeclareAlias2("threePhaseMotor1.aimc.fixed.flange.tau", "Cut torque in the flange [N.m]",\
 "threePhaseMotor1.aimc.tauElectrical", -1, 5, 1085, 132)
DeclareAlias2("threePhaseMotor1.aimc.friction.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "variableSpeedDrive_ThreePhase1.speedSensor.flange.phi", 1, 1, 11, 4)
DeclareVariable("threePhaseMotor1.aimc.friction.flange.tau", "Cut torque in the flange [N.m]",\
 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("threePhaseMotor1.aimc.friction.support.phi", "Absolute rotation angle of flange [rad|deg]",\
 "threePhaseMotor1.aimc.fixed.phi0", 1, 7, 118, 4)
DeclareVariable("threePhaseMotor1.aimc.friction.support.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor1.aimc.friction.phi", "Angle between shaft and support [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor1.aimc.friction.der(phi)", "der(Angle between shaft and support) [rad/s]",\
 "fan1.inertia.w", 1, 1, 13, 0)
DeclareVariable("threePhaseMotor1.aimc.friction.tau", "Torque [N.m]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareAlias2("threePhaseMotor1.aimc.friction.w", "Relative angular velocity of flange and support [rad/s]",\
 "fan1.inertia.w", 1, 1, 13, 0)
DeclareVariable("threePhaseMotor1.aimc.friction.frictionParameters.PRef", \
"Reference friction losses at wRef [W]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.friction.frictionParameters.wRef", \
"Reference angular velocity that the PRef refer to [rad/s|rev/min]", 1E-60, \
1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.friction.frictionParameters.power_w", \
"Exponent of friction torque w.r.t. angular velocity", 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.friction.frictionParameters.tauRef", \
"Reference friction torque at reference angular velocity [N.m]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.friction.frictionParameters.linear", \
"Linear angular velocity range with respect to reference angular velocity", \
0.001, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.friction.frictionParameters.wLinear", \
"Linear angular velocity range [rad/s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.friction.frictionParameters.tauLinear", \
"Torque corresponding with linear angular velocity range [N.m]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.friction.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("threePhaseMotor1.aimc.friction.heatPort.T", "Port temperature [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("threePhaseMotor1.aimc.friction.heatPort.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor1.aimc.friction.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("threePhaseMotor1.aimc.internalSupport.phi", "Absolute rotation angle of flange [rad|deg]",\
 "threePhaseMotor1.aimc.fixed.phi0", 1, 7, 118, 1028)
DeclareVariable("threePhaseMotor1.aimc.internalSupport.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,2825)
DeclareVariable("threePhaseMotor1.aimc.statorCoreParameters.m", "Number of phases (1 for DC, 3 for induction machines) [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("threePhaseMotor1.aimc.statorCoreParameters.PRef", \
"Reference core losses at reference inner voltage VRef [W]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.statorCoreParameters.VRef", \
"Reference inner RMS voltage that reference core losses PRef refer to [V]", 100,\
 1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.statorCoreParameters.wRef", \
"Reference angular velocity that reference core losses PRef refer to [rad/s]", \
1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.statorCoreParameters.ratioHysteresis", \
"Ratio of hysteresis losses with respect to the total core losses at VRef and fRef",\
 0.0, 0.0,1.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.statorCoreParameters.GcRef", \
"Reference conductance at reference frequency and voltage [S]", 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("threePhaseMotor1.aimc.statorCoreParameters.wMin", "[rad/s]", \
0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.strayLoadParameters.PRef", \
"Reference stray load losses at IRef and wRef [W]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.strayLoadParameters.IRef", \
"Reference RMS current that PRef refers to [A]", 100, 1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.strayLoadParameters.wRef", \
"Reference angular velocity that PRef refers to [rad/s|rev/min]", 1E-60, 1E-60,\
1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.strayLoadParameters.power_w", \
"Exponent of stray load loss torque w.r.t. angular velocity", 1E-60, 1E-60,\
1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.strayLoadParameters.tauRef", \
"Reference stray load torque at reference angular velocity and reference current [N.m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.powerBalance.powerStator", \
"Electrical power (stator) [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.powerBalance.powerMechanical", \
"Mechanical power [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.powerBalance.powerInertiaStator", \
"Stator inertia power [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.powerBalance.powerInertiaRotor", \
"Rotor inertia power [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.powerBalance.lossPowerTotal", \
"Total loss power [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.powerBalance.lossPowerStatorWinding", \
"Stator copper losses [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.powerBalance.lossPowerStatorCore", \
"Stator core losses [W]", 0.0, 0.0,0.0,0.0,0,513)
EndNonAlias(0)
PreNonAliasNew(1)
StartNonAlias(1)
DeclareVariable("threePhaseMotor1.aimc.powerBalance.lossPowerRotorCore", \
"Rotor core losses [W]", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.powerBalance.lossPowerStrayLoad", \
"Stray load losses [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.powerBalance.lossPowerFriction", \
"Friction losses [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.powerBalance.lossPowerRotorWinding", \
"Rotor copper losses [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.vs[1]", "Stator instantaneous voltages [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.vs[2]", "Stator instantaneous voltages [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.vs[3]", "Stator instantaneous voltages [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor1.aimc.is[1]", "Stator instantaneous currents [A]",\
 "inverter1.ac.pin[1].i", -1, 5, 761, 0)
DeclareAlias2("threePhaseMotor1.aimc.is[2]", "Stator instantaneous currents [A]",\
 "inverter1.ac.pin[2].i", -1, 5, 763, 0)
DeclareAlias2("threePhaseMotor1.aimc.is[3]", "Stator instantaneous currents [A]",\
 "inverter1.ac.pin[3].i", -1, 5, 765, 0)
DeclareVariable("threePhaseMotor1.aimc.i_0_s", "Stator zero-sequence current [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.der(i_0_s)", "der(Stator zero-sequence current) [A/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("threePhaseMotor1.aimc.idq_ss[1]", "Stator space phasor current / stator fixed frame [A]",\
 "threePhaseMotor1.aimc.lssigma.i_[1]", 1, 5, 1198, 0)
DeclareAlias2("threePhaseMotor1.aimc.idq_ss[2]", "Stator space phasor current / stator fixed frame [A]",\
 "threePhaseMotor1.aimc.lssigma.i_[2]", 1, 5, 1199, 0)
DeclareState("threePhaseMotor1.aimc.idq_sr[1]", "Stator space phasor current / rotor fixed frame [A]",\
 7, 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("threePhaseMotor1.aimc.der(idq_sr[1])", "der(Stator space phasor current / rotor fixed frame) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("threePhaseMotor1.aimc.idq_sr[2]", "Stator space phasor current / rotor fixed frame [A]",\
 8, 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("threePhaseMotor1.aimc.der(idq_sr[2])", "der(Stator space phasor current / rotor fixed frame) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.idq_rs[1]", "Rotor space phasor current / stator fixed frame [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.idq_rs[2]", "Rotor space phasor current / stator fixed frame [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.der(idq_rs[1])", "der(Rotor space phasor current / stator fixed frame) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.der(idq_rs[2])", "der(Rotor space phasor current / stator fixed frame) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("threePhaseMotor1.aimc.idq_rr[1]", "Rotor space phasor current / rotor fixed frame [A]",\
 9, 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("threePhaseMotor1.aimc.der(idq_rr[1])", "der(Rotor space phasor current / rotor fixed frame) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("threePhaseMotor1.aimc.idq_rr[2]", "Rotor space phasor current / rotor fixed frame [A]",\
 10, 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("threePhaseMotor1.aimc.der(idq_rr[2])", "der(Rotor space phasor current / rotor fixed frame) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.plug_sp.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("threePhaseMotor1.aimc.plug_sp.pin[1].v", "Potential at the pin [V]",\
 "inverter1.ac.pin[1].v", 1, 5, 760, 4)
DeclareAlias2("threePhaseMotor1.aimc.plug_sp.pin[1].i", "Current flowing into the pin [A]",\
 "inverter1.ac.pin[1].i", -1, 5, 761, 132)
DeclareAlias2("threePhaseMotor1.aimc.plug_sp.pin[2].v", "Potential at the pin [V]",\
 "inverter1.ac.pin[2].v", 1, 5, 762, 4)
DeclareAlias2("threePhaseMotor1.aimc.plug_sp.pin[2].i", "Current flowing into the pin [A]",\
 "inverter1.ac.pin[2].i", -1, 5, 763, 132)
DeclareAlias2("threePhaseMotor1.aimc.plug_sp.pin[3].v", "Potential at the pin [V]",\
 "inverter1.ac.pin[3].v", 1, 5, 764, 4)
DeclareAlias2("threePhaseMotor1.aimc.plug_sp.pin[3].i", "Current flowing into the pin [A]",\
 "inverter1.ac.pin[3].i", -1, 5, 765, 132)
DeclareVariable("threePhaseMotor1.aimc.plug_sn.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareVariable("threePhaseMotor1.aimc.plug_sn.pin[1].v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("threePhaseMotor1.aimc.plug_sn.pin[1].i", "Current flowing into the pin [A]",\
 "inverter1.ac.pin[1].i", 1, 5, 761, 132)
DeclareAlias2("threePhaseMotor1.aimc.plug_sn.pin[2].v", "Potential at the pin [V]",\
 "threePhaseMotor1.aimc.plug_sn.pin[1].v", 1, 5, 1146, 4)
DeclareAlias2("threePhaseMotor1.aimc.plug_sn.pin[2].i", "Current flowing into the pin [A]",\
 "inverter1.ac.pin[2].i", 1, 5, 763, 132)
DeclareAlias2("threePhaseMotor1.aimc.plug_sn.pin[3].v", "Potential at the pin [V]",\
 "threePhaseMotor1.aimc.plug_sn.pin[1].v", 1, 5, 1146, 4)
DeclareAlias2("threePhaseMotor1.aimc.plug_sn.pin[3].i", "Current flowing into the pin [A]",\
 "inverter1.ac.pin[3].i", 1, 5, 765, 132)
DeclareVariable("threePhaseMotor1.aimc.rs.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("threePhaseMotor1.aimc.rs.v[1]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.rs.v[2]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.rs.v[3]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor1.aimc.rs.i[1]", "Currents flowing into positive polyphase plugs [A]",\
 "inverter1.ac.pin[1].i", -1, 5, 761, 0)
DeclareAlias2("threePhaseMotor1.aimc.rs.i[2]", "Currents flowing into positive polyphase plugs [A]",\
 "inverter1.ac.pin[2].i", -1, 5, 763, 0)
DeclareAlias2("threePhaseMotor1.aimc.rs.i[3]", "Currents flowing into positive polyphase plugs [A]",\
 "inverter1.ac.pin[3].i", -1, 5, 765, 0)
DeclareVariable("threePhaseMotor1.aimc.rs.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("threePhaseMotor1.aimc.rs.plug_p.pin[1].v", "Potential at the pin [V]",\
 "inverter1.ac.pin[1].v", 1, 5, 760, 4)
DeclareAlias2("threePhaseMotor1.aimc.rs.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 "inverter1.ac.pin[1].i", -1, 5, 761, 132)
DeclareAlias2("threePhaseMotor1.aimc.rs.plug_p.pin[2].v", "Potential at the pin [V]",\
 "inverter1.ac.pin[2].v", 1, 5, 762, 4)
DeclareAlias2("threePhaseMotor1.aimc.rs.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 "inverter1.ac.pin[2].i", -1, 5, 763, 132)
DeclareAlias2("threePhaseMotor1.aimc.rs.plug_p.pin[3].v", "Potential at the pin [V]",\
 "inverter1.ac.pin[3].v", 1, 5, 764, 4)
DeclareAlias2("threePhaseMotor1.aimc.rs.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 "inverter1.ac.pin[3].i", -1, 5, 765, 132)
DeclareVariable("threePhaseMotor1.aimc.rs.plug_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareVariable("threePhaseMotor1.aimc.rs.plug_n.pin[1].v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("threePhaseMotor1.aimc.rs.plug_n.pin[1].i", "Current flowing into the pin [A]",\
 "inverter1.ac.pin[1].i", 1, 5, 761, 132)
DeclareVariable("threePhaseMotor1.aimc.rs.plug_n.pin[2].v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("threePhaseMotor1.aimc.rs.plug_n.pin[2].i", "Current flowing into the pin [A]",\
 "inverter1.ac.pin[2].i", 1, 5, 763, 132)
DeclareVariable("threePhaseMotor1.aimc.rs.plug_n.pin[3].v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("threePhaseMotor1.aimc.rs.plug_n.pin[3].i", "Current flowing into the pin [A]",\
 "inverter1.ac.pin[3].i", 1, 5, 765, 132)
DeclareVariable("threePhaseMotor1.aimc.rs.R[1]", "Resistances R_ref at temperatures T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.rs.R[2]", "Resistances R_ref at temperatures T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.rs.R[3]", "Resistances R_ref at temperatures T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.rs.T_ref[1]", "Reference temperatures [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.rs.T_ref[2]", "Reference temperatures [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.rs.T_ref[3]", "Reference temperatures [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.rs.alpha[1]", "Temperature coefficients of resistances at reference temperatures [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.rs.alpha[2]", "Temperature coefficients of resistances at reference temperatures [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.rs.alpha[3]", "Temperature coefficients of resistances at reference temperatures [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.rs.mh", "Number of heatPorts=number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("threePhaseMotor1.aimc.rs.useHeatPort", "=true, if all heat ports are enabled [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("threePhaseMotor1.aimc.rs.T[1]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.rs.T[2]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.rs.T[3]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("threePhaseMotor1.aimc.rs.heatPort[1].T", "Port temperature [K|degC]",\
 "threePhaseMotor1.aimc.thermalAmbient.constTs.k", 1, 5, 1302, 4)
DeclareAlias2("threePhaseMotor1.aimc.rs.heatPort[1].Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "threePhaseMotor1.aimc.rs.resistor[1].LossPower", -1, 5, 1176, 132)
DeclareAlias2("threePhaseMotor1.aimc.rs.heatPort[2].T", "Port temperature [K|degC]",\
 "threePhaseMotor1.aimc.thermalAmbient.constTs.k", 1, 5, 1302, 4)
DeclareAlias2("threePhaseMotor1.aimc.rs.heatPort[2].Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "threePhaseMotor1.aimc.rs.resistor[2].LossPower", -1, 5, 1184, 132)
DeclareAlias2("threePhaseMotor1.aimc.rs.heatPort[3].T", "Port temperature [K|degC]",\
 "threePhaseMotor1.aimc.thermalAmbient.constTs.k", 1, 5, 1302, 4)
DeclareAlias2("threePhaseMotor1.aimc.rs.heatPort[3].Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "threePhaseMotor1.aimc.rs.resistor[3].LossPower", -1, 5, 1192, 132)
DeclareVariable("threePhaseMotor1.aimc.rs.resistor[1].R", "Resistance at temperature T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.rs.resistor[1].T_ref", "Reference temperature [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.rs.resistor[1].alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.rs.resistor[1].v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor1.aimc.rs.resistor[1].i", "Current flowing from pin p to pin n [A]",\
 "inverter1.ac.pin[1].i", -1, 5, 761, 0)
DeclareAlias2("threePhaseMotor1.aimc.rs.resistor[1].p.v", "Potential at the pin [V]",\
 "inverter1.ac.pin[1].v", 1, 5, 760, 4)
DeclareAlias2("threePhaseMotor1.aimc.rs.resistor[1].p.i", "Current flowing into the pin [A]",\
 "inverter1.ac.pin[1].i", -1, 5, 761, 132)
DeclareAlias2("threePhaseMotor1.aimc.rs.resistor[1].n.v", "Potential at the pin [V]",\
 "threePhaseMotor1.aimc.rs.plug_n.pin[1].v", 1, 5, 1153, 4)
DeclareAlias2("threePhaseMotor1.aimc.rs.resistor[1].n.i", "Current flowing into the pin [A]",\
 "inverter1.ac.pin[1].i", 1, 5, 761, 132)
DeclareVariable("threePhaseMotor1.aimc.rs.resistor[1].useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("threePhaseMotor1.aimc.rs.resistor[1].T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("threePhaseMotor1.aimc.rs.resistor[1].heatPort.T", \
"Port temperature [K|degC]", "threePhaseMotor1.aimc.thermalAmbient.constTs.k", 1,\
 5, 1302, 4)
DeclareAlias2("threePhaseMotor1.aimc.rs.resistor[1].heatPort.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor1.aimc.rs.resistor[1].LossPower", -1, 5, 1176, 132)
DeclareVariable("threePhaseMotor1.aimc.rs.resistor[1].LossPower", \
"Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor1.aimc.rs.resistor[1].T_heatPort", \
"Temperature of heatPort [K|degC]", "threePhaseMotor1.aimc.thermalAmbient.constTs.k", 1,\
 5, 1302, 0)
DeclareVariable("threePhaseMotor1.aimc.rs.resistor[1].R_actual", \
"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]", 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("threePhaseMotor1.aimc.rs.resistor[2].R", "Resistance at temperature T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.rs.resistor[2].T_ref", "Reference temperature [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.rs.resistor[2].alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.rs.resistor[2].v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor1.aimc.rs.resistor[2].i", "Current flowing from pin p to pin n [A]",\
 "inverter1.ac.pin[2].i", -1, 5, 763, 0)
DeclareAlias2("threePhaseMotor1.aimc.rs.resistor[2].p.v", "Potential at the pin [V]",\
 "inverter1.ac.pin[2].v", 1, 5, 762, 4)
DeclareAlias2("threePhaseMotor1.aimc.rs.resistor[2].p.i", "Current flowing into the pin [A]",\
 "inverter1.ac.pin[2].i", -1, 5, 763, 132)
DeclareAlias2("threePhaseMotor1.aimc.rs.resistor[2].n.v", "Potential at the pin [V]",\
 "threePhaseMotor1.aimc.rs.plug_n.pin[2].v", 1, 5, 1154, 4)
DeclareAlias2("threePhaseMotor1.aimc.rs.resistor[2].n.i", "Current flowing into the pin [A]",\
 "inverter1.ac.pin[2].i", 1, 5, 763, 132)
DeclareVariable("threePhaseMotor1.aimc.rs.resistor[2].useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("threePhaseMotor1.aimc.rs.resistor[2].T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("threePhaseMotor1.aimc.rs.resistor[2].heatPort.T", \
"Port temperature [K|degC]", "threePhaseMotor1.aimc.thermalAmbient.constTs.k", 1,\
 5, 1302, 4)
DeclareAlias2("threePhaseMotor1.aimc.rs.resistor[2].heatPort.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor1.aimc.rs.resistor[2].LossPower", -1, 5, 1184, 132)
DeclareVariable("threePhaseMotor1.aimc.rs.resistor[2].LossPower", \
"Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor1.aimc.rs.resistor[2].T_heatPort", \
"Temperature of heatPort [K|degC]", "threePhaseMotor1.aimc.thermalAmbient.constTs.k", 1,\
 5, 1302, 0)
DeclareVariable("threePhaseMotor1.aimc.rs.resistor[2].R_actual", \
"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]", 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("threePhaseMotor1.aimc.rs.resistor[3].R", "Resistance at temperature T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.rs.resistor[3].T_ref", "Reference temperature [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.rs.resistor[3].alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.rs.resistor[3].v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor1.aimc.rs.resistor[3].i", "Current flowing from pin p to pin n [A]",\
 "inverter1.ac.pin[3].i", -1, 5, 765, 0)
DeclareAlias2("threePhaseMotor1.aimc.rs.resistor[3].p.v", "Potential at the pin [V]",\
 "inverter1.ac.pin[3].v", 1, 5, 764, 4)
DeclareAlias2("threePhaseMotor1.aimc.rs.resistor[3].p.i", "Current flowing into the pin [A]",\
 "inverter1.ac.pin[3].i", -1, 5, 765, 132)
DeclareAlias2("threePhaseMotor1.aimc.rs.resistor[3].n.v", "Potential at the pin [V]",\
 "threePhaseMotor1.aimc.rs.plug_n.pin[3].v", 1, 5, 1155, 4)
DeclareAlias2("threePhaseMotor1.aimc.rs.resistor[3].n.i", "Current flowing into the pin [A]",\
 "inverter1.ac.pin[3].i", 1, 5, 765, 132)
DeclareVariable("threePhaseMotor1.aimc.rs.resistor[3].useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("threePhaseMotor1.aimc.rs.resistor[3].T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("threePhaseMotor1.aimc.rs.resistor[3].heatPort.T", \
"Port temperature [K|degC]", "threePhaseMotor1.aimc.thermalAmbient.constTs.k", 1,\
 5, 1302, 4)
DeclareAlias2("threePhaseMotor1.aimc.rs.resistor[3].heatPort.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor1.aimc.rs.resistor[3].LossPower", -1, 5, 1192, 132)
DeclareVariable("threePhaseMotor1.aimc.rs.resistor[3].LossPower", \
"Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor1.aimc.rs.resistor[3].T_heatPort", \
"Temperature of heatPort [K|degC]", "threePhaseMotor1.aimc.thermalAmbient.constTs.k", 1,\
 5, 1302, 0)
DeclareVariable("threePhaseMotor1.aimc.rs.resistor[3].R_actual", \
"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]", 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("threePhaseMotor1.aimc.lssigma.L[1]", "Inductance of both axes [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.lssigma.L[2]", "Inductance of both axes [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.lssigma.v_[1]", "[V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.lssigma.v_[2]", "[V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.lssigma.i_[1]", "[A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.lssigma.i_[2]", "[A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.lssigma.der(i_[1])", "[A/s]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.lssigma.der(i_[2])", "[A/s]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.lssigma.spacePhasor_a.v_[1]", \
"1=real, 2=imaginary part [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareVariable("threePhaseMotor1.aimc.lssigma.spacePhasor_a.v_[2]", \
"1=real, 2=imaginary part [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("threePhaseMotor1.aimc.lssigma.spacePhasor_a.i_[1]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor1.aimc.lssigma.i_[1]", 1, 5, 1198,\
 132)
DeclareAlias2("threePhaseMotor1.aimc.lssigma.spacePhasor_a.i_[2]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor1.aimc.lssigma.i_[2]", 1, 5, 1199,\
 132)
DeclareAlias2("threePhaseMotor1.aimc.lssigma.spacePhasor_b.v_[1]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor1.aimc.airGapS.der(psi_ms[1])", 1,\
 5, 1328, 4)
DeclareAlias2("threePhaseMotor1.aimc.lssigma.spacePhasor_b.v_[2]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor1.aimc.airGapS.der(psi_ms[2])", 1,\
 5, 1329, 4)
DeclareAlias2("threePhaseMotor1.aimc.lssigma.spacePhasor_b.i_[1]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor1.aimc.lssigma.i_[1]", -1, 5, 1198,\
 132)
DeclareAlias2("threePhaseMotor1.aimc.lssigma.spacePhasor_b.i_[2]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor1.aimc.lssigma.i_[2]", -1, 5, 1199,\
 132)
DeclareVariable("threePhaseMotor1.aimc.lszero.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.lszero.i", "Current flowing from pin p to pin n [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.lszero.der(i)", "der(Current flowing from pin p to pin n) [A/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.lszero.p.v", "Potential at the pin [V]", \
0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("threePhaseMotor1.aimc.lszero.p.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor1.aimc.lszero.n.v", "Potential at the pin [V]", 0,\
 0.0,0.0,0.0,0,521)
DeclareVariable("threePhaseMotor1.aimc.lszero.n.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor1.aimc.lszero.L", "Inductance [H]", 1, 0.0,0.0,\
0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.statorCore.coreParameters.m", \
"Number of phases (1 for DC, 3 for induction machines) [:#(type=Integer)]", 3, \
0.0,0.0,0.0,0,517)
DeclareVariable("threePhaseMotor1.aimc.statorCore.coreParameters.PRef", \
"Reference core losses at reference inner voltage VRef [W]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.statorCore.coreParameters.VRef", \
"Reference inner RMS voltage that reference core losses PRef refer to [V]", \
1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.statorCore.coreParameters.wRef", \
"Reference angular velocity that reference core losses PRef refer to [rad/s]", \
1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.statorCore.coreParameters.ratioHysteresis",\
 "Ratio of hysteresis losses with respect to the total core losses at VRef and fRef",\
 0.0, 0.0,1.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.statorCore.coreParameters.GcRef", \
"Reference conductance at reference frequency and voltage [S]", 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("threePhaseMotor1.aimc.statorCore.coreParameters.wMin", \
"[rad/s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.statorCore.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("threePhaseMotor1.aimc.statorCore.turnsRatio", "Effective number of stator turns / effective number of rotor turns (if used as rotor core)",\
 1, 1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.statorCore.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("threePhaseMotor1.aimc.statorCore.heatPort.T", "Port temperature [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("threePhaseMotor1.aimc.statorCore.heatPort.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor1.aimc.statorCore.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("threePhaseMotor1.aimc.statorCore.spacePhasor.v_[1]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor1.aimc.lssigma.spacePhasor_a.v_[1]", 1,\
 5, 1202, 4)
DeclareAlias2("threePhaseMotor1.aimc.statorCore.spacePhasor.v_[2]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor1.aimc.lssigma.spacePhasor_a.v_[2]", 1,\
 5, 1203, 4)
DeclareVariable("threePhaseMotor1.aimc.statorCore.spacePhasor.i_[1]", \
"1=real, 2=imaginary part [A]", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor1.aimc.statorCore.spacePhasor.i_[2]", \
"1=real, 2=imaginary part [A]", 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("threePhaseMotor1.aimc.statorCore.w", "Remagnetization angular velocity [rad/s]",\
 "threePhaseMotor1.aimc.statorCoreParameters.wRef", 1, 5, 1115, 0)
DeclareVariable("threePhaseMotor1.aimc.statorCore.Gc", "Variable core loss conductance [S]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.statorCore.wLimit", "Limited angular velocity [rad/s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor1.aimc.spacePhasorS.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("threePhaseMotor1.aimc.spacePhasorS.turnsRatio", \
"Turns ratio [1]", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.spacePhasorS.v[1]", "Instantaneous phase voltages [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.spacePhasorS.v[2]", "Instantaneous phase voltages [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.spacePhasorS.v[3]", "Instantaneous phase voltages [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor1.aimc.spacePhasorS.i[1]", "Instantaneous phase currents [A]",\
 "inverter1.ac.pin[1].i", -1, 5, 761, 0)
DeclareAlias2("threePhaseMotor1.aimc.spacePhasorS.i[2]", "Instantaneous phase currents [A]",\
 "inverter1.ac.pin[2].i", -1, 5, 763, 0)
DeclareAlias2("threePhaseMotor1.aimc.spacePhasorS.i[3]", "Instantaneous phase currents [A]",\
 "inverter1.ac.pin[3].i", -1, 5, 765, 0)
DeclareVariable("threePhaseMotor1.aimc.spacePhasorS.TransformationMatrix[1, 1]",\
 "[1]", 0.6666666666666666, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor1.aimc.spacePhasorS.TransformationMatrix[1, 2]",\
 "[1]", -0.33333333333333315, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor1.aimc.spacePhasorS.TransformationMatrix[1, 3]",\
 "[1]", -0.3333333333333336, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor1.aimc.spacePhasorS.TransformationMatrix[2, 1]",\
 "[1]", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor1.aimc.spacePhasorS.TransformationMatrix[2, 2]",\
 "[1]", 0.5773502691896257, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor1.aimc.spacePhasorS.TransformationMatrix[2, 3]",\
 "[1]", -0.5773502691896255, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor1.aimc.spacePhasorS.InverseTransformation[1, 1]",\
 "", 1.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor1.aimc.spacePhasorS.InverseTransformation[1, 2]",\
 "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor1.aimc.spacePhasorS.InverseTransformation[2, 1]",\
 "", -0.4999999999999998, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor1.aimc.spacePhasorS.InverseTransformation[2, 2]",\
 "", 0.8660254037844387, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor1.aimc.spacePhasorS.InverseTransformation[3, 1]",\
 "", -0.5000000000000004, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor1.aimc.spacePhasorS.InverseTransformation[3, 2]",\
 "", -0.8660254037844384, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor1.aimc.spacePhasorS.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("threePhaseMotor1.aimc.spacePhasorS.plug_p.pin[1].v", \
"Potential at the pin [V]", "threePhaseMotor1.aimc.rs.plug_n.pin[1].v", 1, 5, 1153,\
 4)
DeclareAlias2("threePhaseMotor1.aimc.spacePhasorS.plug_p.pin[1].i", \
"Current flowing into the pin [A]", "inverter1.ac.pin[1].i", -1, 5, 761, 132)
DeclareAlias2("threePhaseMotor1.aimc.spacePhasorS.plug_p.pin[2].v", \
"Potential at the pin [V]", "threePhaseMotor1.aimc.rs.plug_n.pin[2].v", 1, 5, 1154,\
 4)
DeclareAlias2("threePhaseMotor1.aimc.spacePhasorS.plug_p.pin[2].i", \
"Current flowing into the pin [A]", "inverter1.ac.pin[2].i", -1, 5, 763, 132)
DeclareAlias2("threePhaseMotor1.aimc.spacePhasorS.plug_p.pin[3].v", \
"Potential at the pin [V]", "threePhaseMotor1.aimc.rs.plug_n.pin[3].v", 1, 5, 1155,\
 4)
DeclareAlias2("threePhaseMotor1.aimc.spacePhasorS.plug_p.pin[3].i", \
"Current flowing into the pin [A]", "inverter1.ac.pin[3].i", -1, 5, 765, 132)
DeclareVariable("threePhaseMotor1.aimc.spacePhasorS.plug_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("threePhaseMotor1.aimc.spacePhasorS.plug_n.pin[1].v", \
"Potential at the pin [V]", "threePhaseMotor1.aimc.plug_sn.pin[1].v", 1, 5, 1146,\
 4)
DeclareAlias2("threePhaseMotor1.aimc.spacePhasorS.plug_n.pin[1].i", \
"Current flowing into the pin [A]", "inverter1.ac.pin[1].i", 1, 5, 761, 132)
DeclareAlias2("threePhaseMotor1.aimc.spacePhasorS.plug_n.pin[2].v", \
"Potential at the pin [V]", "threePhaseMotor1.aimc.plug_sn.pin[1].v", 1, 5, 1146,\
 4)
DeclareAlias2("threePhaseMotor1.aimc.spacePhasorS.plug_n.pin[2].i", \
"Current flowing into the pin [A]", "inverter1.ac.pin[2].i", 1, 5, 763, 132)
DeclareAlias2("threePhaseMotor1.aimc.spacePhasorS.plug_n.pin[3].v", \
"Potential at the pin [V]", "threePhaseMotor1.aimc.plug_sn.pin[1].v", 1, 5, 1146,\
 4)
DeclareAlias2("threePhaseMotor1.aimc.spacePhasorS.plug_n.pin[3].i", \
"Current flowing into the pin [A]", "inverter1.ac.pin[3].i", 1, 5, 765, 132)
DeclareVariable("threePhaseMotor1.aimc.spacePhasorS.zero.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("threePhaseMotor1.aimc.spacePhasorS.zero.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor1.aimc.spacePhasorS.ground.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("threePhaseMotor1.aimc.spacePhasorS.ground.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("threePhaseMotor1.aimc.spacePhasorS.spacePhasor.v_[1]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor1.aimc.lssigma.spacePhasor_a.v_[1]", 1,\
 5, 1202, 4)
DeclareAlias2("threePhaseMotor1.aimc.spacePhasorS.spacePhasor.v_[2]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor1.aimc.lssigma.spacePhasor_a.v_[2]", 1,\
 5, 1203, 4)
DeclareAlias2("threePhaseMotor1.aimc.spacePhasorS.spacePhasor.i_[1]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor1.aimc.lssigma.i_[1]", -1, 5, 1198,\
 132)
DeclareAlias2("threePhaseMotor1.aimc.spacePhasorS.spacePhasor.i_[2]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor1.aimc.lssigma.i_[2]", -1, 5, 1199,\
 132)
DeclareVariable("threePhaseMotor1.aimc.strayLoad.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("threePhaseMotor1.aimc.strayLoad.v[1]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.strayLoad.v[2]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.strayLoad.v[3]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("threePhaseMotor1.aimc.strayLoad.i[1]", "Currents flowing into positive polyphase plugs [A]",\
 "inverter1.ac.pin[1].i", -1, 5, 761, 0)
DeclareAlias2("threePhaseMotor1.aimc.strayLoad.i[2]", "Currents flowing into positive polyphase plugs [A]",\
 "inverter1.ac.pin[2].i", -1, 5, 763, 0)
DeclareAlias2("threePhaseMotor1.aimc.strayLoad.i[3]", "Currents flowing into positive polyphase plugs [A]",\
 "inverter1.ac.pin[3].i", -1, 5, 765, 0)
DeclareVariable("threePhaseMotor1.aimc.strayLoad.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("threePhaseMotor1.aimc.strayLoad.plug_p.pin[1].v", \
"Potential at the pin [V]", "inverter1.ac.pin[1].v", 1, 5, 760, 4)
DeclareAlias2("threePhaseMotor1.aimc.strayLoad.plug_p.pin[1].i", \
"Current flowing into the pin [A]", "inverter1.ac.pin[1].i", -1, 5, 761, 132)
DeclareAlias2("threePhaseMotor1.aimc.strayLoad.plug_p.pin[2].v", \
"Potential at the pin [V]", "inverter1.ac.pin[2].v", 1, 5, 762, 4)
DeclareAlias2("threePhaseMotor1.aimc.strayLoad.plug_p.pin[2].i", \
"Current flowing into the pin [A]", "inverter1.ac.pin[2].i", -1, 5, 763, 132)
DeclareAlias2("threePhaseMotor1.aimc.strayLoad.plug_p.pin[3].v", \
"Potential at the pin [V]", "inverter1.ac.pin[3].v", 1, 5, 764, 4)
DeclareAlias2("threePhaseMotor1.aimc.strayLoad.plug_p.pin[3].i", \
"Current flowing into the pin [A]", "inverter1.ac.pin[3].i", -1, 5, 765, 132)
DeclareVariable("threePhaseMotor1.aimc.strayLoad.plug_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("threePhaseMotor1.aimc.strayLoad.plug_n.pin[1].v", \
"Potential at the pin [V]", "inverter1.ac.pin[1].v", 1, 5, 760, 4)
DeclareAlias2("threePhaseMotor1.aimc.strayLoad.plug_n.pin[1].i", \
"Current flowing into the pin [A]", "inverter1.ac.pin[1].i", 1, 5, 761, 132)
DeclareAlias2("threePhaseMotor1.aimc.strayLoad.plug_n.pin[2].v", \
"Potential at the pin [V]", "inverter1.ac.pin[2].v", 1, 5, 762, 4)
DeclareAlias2("threePhaseMotor1.aimc.strayLoad.plug_n.pin[2].i", \
"Current flowing into the pin [A]", "inverter1.ac.pin[2].i", 1, 5, 763, 132)
DeclareAlias2("threePhaseMotor1.aimc.strayLoad.plug_n.pin[3].v", \
"Potential at the pin [V]", "inverter1.ac.pin[3].v", 1, 5, 764, 4)
DeclareAlias2("threePhaseMotor1.aimc.strayLoad.plug_n.pin[3].i", \
"Current flowing into the pin [A]", "inverter1.ac.pin[3].i", 1, 5, 765, 132)
DeclareAlias2("threePhaseMotor1.aimc.strayLoad.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "variableSpeedDrive_ThreePhase1.speedSensor.flange.phi", 1, 1, 11, 4)
DeclareVariable("threePhaseMotor1.aimc.strayLoad.flange.tau", "Cut torque in the flange [N.m]",\
 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("threePhaseMotor1.aimc.strayLoad.support.phi", "Absolute rotation angle of flange [rad|deg]",\
 "threePhaseMotor1.aimc.fixed.phi0", 1, 7, 118, 4)
DeclareVariable("threePhaseMotor1.aimc.strayLoad.support.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor1.aimc.strayLoad.phi", "Angle between shaft and support [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor1.aimc.strayLoad.der(phi)", "der(Angle between shaft and support) [rad/s]",\
 "fan1.inertia.w", 1, 1, 13, 0)
DeclareVariable("threePhaseMotor1.aimc.strayLoad.tau", "Torque [N.m]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareAlias2("threePhaseMotor1.aimc.strayLoad.w", "Relative angular velocity of flange and support [rad/s]",\
 "fan1.inertia.w", 1, 1, 13, 0)
DeclareVariable("threePhaseMotor1.aimc.strayLoad.strayLoadParameters.PRef", \
"Reference stray load losses at IRef and wRef [W]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.strayLoad.strayLoadParameters.IRef", \
"Reference RMS current that PRef refers to [A]", 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.strayLoad.strayLoadParameters.wRef", \
"Reference angular velocity that PRef refers to [rad/s|rev/min]", 1E-60, 1E-60,\
1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.strayLoad.strayLoadParameters.power_w", \
"Exponent of stray load loss torque w.r.t. angular velocity", 1E-60, 1E-60,\
1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.strayLoad.strayLoadParameters.tauRef", \
"Reference stray load torque at reference angular velocity and reference current [N.m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.strayLoad.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("threePhaseMotor1.aimc.strayLoad.heatPort.T", "Port temperature [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("threePhaseMotor1.aimc.strayLoad.heatPort.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor1.aimc.strayLoad.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.strayLoad.iRMS", "[A]", 0.0, 0.0,0.0,0.0,\
0,512)
DeclareVariable("threePhaseMotor1.aimc.thermalAmbient.m", "Number of stator phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("threePhaseMotor1.aimc.thermalAmbient.useTemperatureInputs", \
"If true, temperature inputs are used; else, temperatures are constant [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("threePhaseMotor1.aimc.thermalAmbient.TDefault", \
"Default temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.thermalAmbient.Ts", "Temperature of stator windings [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.thermalAmbient.Q_flowStatorWinding", \
"Heat flow rate of stator windings [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.thermalAmbient.Q_flowStatorCore", \
"Heat flow rate of stator core losses [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.thermalAmbient.Q_flowRotorCore", \
"Heat flow rate of stator core losses [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.thermalAmbient.Q_flowStrayLoad", \
"Heat flow rate of stray load losses [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.thermalAmbient.Q_flowFriction", \
"Heat flow rate of friction losses [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.thermalAmbient.thermalPort.m", \
"Number of stator phases [:#(type=Integer)]", 3, 0.0,0.0,0.0,0,525)
DeclareAlias2("threePhaseMotor1.aimc.thermalAmbient.thermalPort.heatPortStatorWinding[1].T",\
 "Port temperature [K|degC]", "threePhaseMotor1.aimc.thermalAmbient.constTs.k", 1,\
 5, 1302, 4)
DeclareAlias2("threePhaseMotor1.aimc.thermalAmbient.thermalPort.heatPortStatorWinding[1].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor1.aimc.rs.resistor[1].LossPower", 1, 5, 1176, 132)
DeclareAlias2("threePhaseMotor1.aimc.thermalAmbient.thermalPort.heatPortStatorWinding[2].T",\
 "Port temperature [K|degC]", "threePhaseMotor1.aimc.thermalAmbient.constTs.k", 1,\
 5, 1302, 4)
DeclareAlias2("threePhaseMotor1.aimc.thermalAmbient.thermalPort.heatPortStatorWinding[2].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor1.aimc.rs.resistor[2].LossPower", 1, 5, 1184, 132)
DeclareAlias2("threePhaseMotor1.aimc.thermalAmbient.thermalPort.heatPortStatorWinding[3].T",\
 "Port temperature [K|degC]", "threePhaseMotor1.aimc.thermalAmbient.constTs.k", 1,\
 5, 1302, 4)
DeclareAlias2("threePhaseMotor1.aimc.thermalAmbient.thermalPort.heatPortStatorWinding[3].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor1.aimc.rs.resistor[3].LossPower", 1, 5, 1192, 132)
DeclareVariable("threePhaseMotor1.aimc.thermalAmbient.thermalPort.heatPortStatorCore.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("threePhaseMotor1.aimc.thermalAmbient.thermalPort.heatPortStatorCore.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor1.aimc.thermalAmbient.thermalPort.heatPortRotorCore.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("threePhaseMotor1.aimc.thermalAmbient.thermalPort.heatPortRotorCore.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor1.aimc.thermalAmbient.thermalPort.heatPortStrayLoad.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("threePhaseMotor1.aimc.thermalAmbient.thermalPort.heatPortStrayLoad.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor1.aimc.thermalAmbient.thermalPort.heatPortFriction.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("threePhaseMotor1.aimc.thermalAmbient.thermalPort.heatPortFriction.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareAlias2("threePhaseMotor1.aimc.thermalAmbient.thermalPort.heatPortRotorWinding.T",\
 "Port temperature [K|degC]", "threePhaseMotor1.aimc.thermalAmbient.constTr.k", 1,\
 5, 1306, 4)
DeclareAlias2("threePhaseMotor1.aimc.thermalAmbient.thermalPort.heatPortRotorWinding.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor1.aimc.powerBalance.lossPowerRotorWinding", 1, 5, 1134, 132)
DeclareAlias2("threePhaseMotor1.aimc.thermalAmbient.temperatureStatorWinding.port.T",\
 "Port temperature [K|degC]", "threePhaseMotor1.aimc.thermalAmbient.constTs.k", 1,\
 5, 1302, 4)
DeclareAlias2("threePhaseMotor1.aimc.thermalAmbient.temperatureStatorWinding.port.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor1.aimc.thermalAmbient.Q_flowStatorWinding", 1, 5, 1276, 132)
DeclareAlias2("threePhaseMotor1.aimc.thermalAmbient.temperatureStatorWinding.T",\
 "[K]", "threePhaseMotor1.aimc.thermalAmbient.constTs.k", 1, 5, 1302, 0)
DeclareVariable("threePhaseMotor1.aimc.thermalAmbient.temperatureStatorCore.T", \
"Fixed temperature at port [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.thermalAmbient.temperatureStatorCore.port.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("threePhaseMotor1.aimc.thermalAmbient.temperatureStatorCore.port.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor1.aimc.thermalAmbient.temperatureRotorCore.T", \
"Fixed temperature at port [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.thermalAmbient.temperatureRotorCore.port.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("threePhaseMotor1.aimc.thermalAmbient.temperatureRotorCore.port.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor1.aimc.thermalAmbient.temperatureStrayLoad.T", \
"Fixed temperature at port [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.thermalAmbient.temperatureStrayLoad.port.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("threePhaseMotor1.aimc.thermalAmbient.temperatureStrayLoad.port.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor1.aimc.thermalAmbient.temperatureFriction.T", \
"Fixed temperature at port [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.thermalAmbient.temperatureFriction.port.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("threePhaseMotor1.aimc.thermalAmbient.temperatureFriction.port.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor1.aimc.thermalAmbient.constTs.k", \
"Constant output value [K]", 1, 0.0,1E+100,300.0,0,513)
DeclareAlias2("threePhaseMotor1.aimc.thermalAmbient.constTs.y", "Connector of Real output signal [K]",\
 "threePhaseMotor1.aimc.thermalAmbient.constTs.k", 1, 5, 1302, 0)
DeclareVariable("threePhaseMotor1.aimc.thermalAmbient.thermalCollectorStator.m",\
 "Number of collected heat flows [:#(type=Integer)]", 3, 1.0,1E+100,0.0,0,517)
DeclareAlias2("threePhaseMotor1.aimc.thermalAmbient.thermalCollectorStator.port_a[1].T",\
 "Port temperature [K|degC]", "threePhaseMotor1.aimc.thermalAmbient.constTs.k", 1,\
 5, 1302, 4)
DeclareAlias2("threePhaseMotor1.aimc.thermalAmbient.thermalCollectorStator.port_a[1].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor1.aimc.rs.resistor[1].LossPower", 1, 5, 1176, 132)
DeclareAlias2("threePhaseMotor1.aimc.thermalAmbient.thermalCollectorStator.port_a[2].T",\
 "Port temperature [K|degC]", "threePhaseMotor1.aimc.thermalAmbient.constTs.k", 1,\
 5, 1302, 4)
DeclareAlias2("threePhaseMotor1.aimc.thermalAmbient.thermalCollectorStator.port_a[2].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor1.aimc.rs.resistor[2].LossPower", 1, 5, 1184, 132)
DeclareAlias2("threePhaseMotor1.aimc.thermalAmbient.thermalCollectorStator.port_a[3].T",\
 "Port temperature [K|degC]", "threePhaseMotor1.aimc.thermalAmbient.constTs.k", 1,\
 5, 1302, 4)
DeclareAlias2("threePhaseMotor1.aimc.thermalAmbient.thermalCollectorStator.port_a[3].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor1.aimc.rs.resistor[3].LossPower", 1, 5, 1192, 132)
DeclareAlias2("threePhaseMotor1.aimc.thermalAmbient.thermalCollectorStator.port_b.T",\
 "Port temperature [K|degC]", "threePhaseMotor1.aimc.thermalAmbient.constTs.k", 1,\
 5, 1302, 4)
DeclareAlias2("threePhaseMotor1.aimc.thermalAmbient.thermalCollectorStator.port_b.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor1.aimc.thermalAmbient.Q_flowStatorWinding", -1, 5, 1276, 132)
DeclareVariable("threePhaseMotor1.aimc.thermalAmbient.Tr", "Temperature of rotor (squirrel cage) [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("threePhaseMotor1.aimc.thermalAmbient.Q_flowRotorWinding", \
"Heat flow rate of rotor (squirrel cage) [W]", "threePhaseMotor1.aimc.powerBalance.lossPowerRotorWinding", 1,\
 5, 1134, 0)
DeclareVariable("threePhaseMotor1.aimc.thermalAmbient.Q_flowTotal", "[W]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor1.aimc.thermalAmbient.temperatureRotorWinding.port.T",\
 "Port temperature [K|degC]", "threePhaseMotor1.aimc.thermalAmbient.constTr.k", 1,\
 5, 1306, 4)
DeclareAlias2("threePhaseMotor1.aimc.thermalAmbient.temperatureRotorWinding.port.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor1.aimc.powerBalance.lossPowerRotorWinding", 1, 5, 1134, 132)
DeclareAlias2("threePhaseMotor1.aimc.thermalAmbient.temperatureRotorWinding.T", \
"[K]", "threePhaseMotor1.aimc.thermalAmbient.constTr.k", 1, 5, 1306, 0)
DeclareVariable("threePhaseMotor1.aimc.thermalAmbient.constTr.k", \
"Constant output value [K]", 1, 0.0,1E+100,300.0,0,513)
DeclareAlias2("threePhaseMotor1.aimc.thermalAmbient.constTr.y", "Connector of Real output signal [K]",\
 "threePhaseMotor1.aimc.thermalAmbient.constTr.k", 1, 5, 1306, 0)
DeclareVariable("threePhaseMotor1.aimc.pi", "", 3.141592653589793, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor1.aimc.internalThermalPort.m", "Number of stator phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,2573)
DeclareAlias2("threePhaseMotor1.aimc.internalThermalPort.heatPortStatorWinding[1].T",\
 "Port temperature [K|degC]", "threePhaseMotor1.aimc.thermalAmbient.constTs.k", 1,\
 5, 1302, 1028)
DeclareVariable("threePhaseMotor1.aimc.internalThermalPort.heatPortStatorWinding[1].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareAlias2("threePhaseMotor1.aimc.internalThermalPort.heatPortStatorWinding[2].T",\
 "Port temperature [K|degC]", "threePhaseMotor1.aimc.thermalAmbient.constTs.k", 1,\
 5, 1302, 1028)
DeclareVariable("threePhaseMotor1.aimc.internalThermalPort.heatPortStatorWinding[2].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareAlias2("threePhaseMotor1.aimc.internalThermalPort.heatPortStatorWinding[3].T",\
 "Port temperature [K|degC]", "threePhaseMotor1.aimc.thermalAmbient.constTs.k", 1,\
 5, 1302, 1028)
DeclareVariable("threePhaseMotor1.aimc.internalThermalPort.heatPortStatorWinding[3].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareVariable("threePhaseMotor1.aimc.internalThermalPort.heatPortStatorCore.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,2569)
DeclareVariable("threePhaseMotor1.aimc.internalThermalPort.heatPortStatorCore.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareVariable("threePhaseMotor1.aimc.internalThermalPort.heatPortRotorCore.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,2569)
DeclareVariable("threePhaseMotor1.aimc.internalThermalPort.heatPortRotorCore.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareVariable("threePhaseMotor1.aimc.internalThermalPort.heatPortStrayLoad.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,2569)
DeclareVariable("threePhaseMotor1.aimc.internalThermalPort.heatPortStrayLoad.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareVariable("threePhaseMotor1.aimc.internalThermalPort.heatPortFriction.T", \
"Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,2569)
DeclareVariable("threePhaseMotor1.aimc.internalThermalPort.heatPortFriction.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareAlias2("threePhaseMotor1.aimc.internalThermalPort.heatPortRotorWinding.T",\
 "Port temperature [K|degC]", "threePhaseMotor1.aimc.thermalAmbient.constTr.k", 1,\
 5, 1306, 1028)
DeclareVariable("threePhaseMotor1.aimc.internalThermalPort.heatPortRotorWinding.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareAlias2("threePhaseMotor1.aimc.ir[1]", "Rotor cage currents [A]", \
"threePhaseMotor1.aimc.idq_rr[1]", 1, 1, 9, 0)
DeclareAlias2("threePhaseMotor1.aimc.ir[2]", "Rotor cage currents [A]", \
"threePhaseMotor1.aimc.idq_rr[2]", 1, 1, 10, 0)
DeclareVariable("threePhaseMotor1.aimc.airGapS.Lm", "Main field inductance [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.airGapS.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("threePhaseMotor1.aimc.airGapS.p", "Number of pole pairs [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareAlias2("threePhaseMotor1.aimc.airGapS.tauElectrical", "[N.m]", \
"threePhaseMotor1.aimc.tauElectrical", 1, 5, 1085, 0)
DeclareVariable("threePhaseMotor1.aimc.airGapS.gamma", "Rotor displacement angle [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.airGapS.der(gamma)", "der(Rotor displacement angle) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor1.aimc.airGapS.i_ss[1]", "Stator current space phasor with respect to the stator fixed frame [A]",\
 "threePhaseMotor1.aimc.lssigma.i_[1]", 1, 5, 1198, 0)
DeclareAlias2("threePhaseMotor1.aimc.airGapS.i_ss[2]", "Stator current space phasor with respect to the stator fixed frame [A]",\
 "threePhaseMotor1.aimc.lssigma.i_[2]", 1, 5, 1199, 0)
DeclareAlias2("threePhaseMotor1.aimc.airGapS.i_sr[1]", "Stator current space phasor with respect to the rotor fixed frame [A]",\
 "threePhaseMotor1.aimc.idq_sr[1]", 1, 1, 7, 0)
DeclareAlias2("threePhaseMotor1.aimc.airGapS.i_sr[2]", "Stator current space phasor with respect to the rotor fixed frame [A]",\
 "threePhaseMotor1.aimc.idq_sr[2]", 1, 1, 8, 0)
DeclareAlias2("threePhaseMotor1.aimc.airGapS.i_rs[1]", "Rotor current space phasor with respect to the stator fixed frame [A]",\
 "threePhaseMotor1.aimc.idq_rs[1]", 1, 5, 1140, 0)
DeclareAlias2("threePhaseMotor1.aimc.airGapS.i_rs[2]", "Rotor current space phasor with respect to the stator fixed frame [A]",\
 "threePhaseMotor1.aimc.idq_rs[2]", 1, 5, 1141, 0)
DeclareAlias2("threePhaseMotor1.aimc.airGapS.i_rr[1]", "Rotor current space phasor with respect to the rotor fixed frame [A]",\
 "threePhaseMotor1.aimc.idq_rr[1]", 1, 1, 9, 0)
DeclareAlias2("threePhaseMotor1.aimc.airGapS.i_rr[2]", "Rotor current space phasor with respect to the rotor fixed frame [A]",\
 "threePhaseMotor1.aimc.idq_rr[2]", 1, 1, 10, 0)
DeclareVariable("threePhaseMotor1.aimc.airGapS.psi_ms[1]", "Magnetizing flux phasor with respect to the stator fixed frame [Wb]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.airGapS.psi_ms[2]", "Magnetizing flux phasor with respect to the stator fixed frame [Wb]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.airGapS.der(psi_ms[1])", "der(Magnetizing flux phasor with respect to the stator fixed frame) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.airGapS.der(psi_ms[2])", "der(Magnetizing flux phasor with respect to the stator fixed frame) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.airGapS.psi_mr[1]", "Magnetizing flux phasor with respect to the rotor fixed frame [Wb]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.airGapS.psi_mr[2]", "Magnetizing flux phasor with respect to the rotor fixed frame [Wb]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.airGapS.der(psi_mr[1])", "der(Magnetizing flux phasor with respect to the rotor fixed frame) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.airGapS.der(psi_mr[2])", "der(Magnetizing flux phasor with respect to the rotor fixed frame) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.airGapS.RotationMatrix[1, 1]", \
"Matrix of rotation from rotor to stator [1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.airGapS.RotationMatrix[1, 2]", \
"Matrix of rotation from rotor to stator [1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.airGapS.RotationMatrix[2, 1]", \
"Matrix of rotation from rotor to stator [1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.airGapS.RotationMatrix[2, 2]", \
"Matrix of rotation from rotor to stator [1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.airGapS.der(RotationMatrix[1, 1])", \
"der(Matrix of rotation from rotor to stator) [s-1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.airGapS.der(RotationMatrix[1, 2])", \
"der(Matrix of rotation from rotor to stator) [s-1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.airGapS.der(RotationMatrix[2, 1])", \
"der(Matrix of rotation from rotor to stator) [s-1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.airGapS.der(RotationMatrix[2, 2])", \
"der(Matrix of rotation from rotor to stator) [s-1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor1.aimc.airGapS.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "variableSpeedDrive_ThreePhase1.speedSensor.flange.phi", 1, 1, 11, 4)
DeclareAlias2("threePhaseMotor1.aimc.airGapS.flange.tau", "Cut torque in the flange [N.m]",\
 "threePhaseMotor1.aimc.tauElectrical", -1, 5, 1085, 132)
DeclareAlias2("threePhaseMotor1.aimc.airGapS.support.phi", "Absolute rotation angle of flange [rad|deg]",\
 "threePhaseMotor1.aimc.fixed.phi0", 1, 7, 118, 4)
DeclareAlias2("threePhaseMotor1.aimc.airGapS.support.tau", "Cut torque in the flange [N.m]",\
 "threePhaseMotor1.aimc.tauElectrical", 1, 5, 1085, 132)
DeclareAlias2("threePhaseMotor1.aimc.airGapS.spacePhasor_s.v_[1]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor1.aimc.airGapS.der(psi_ms[1])", 1,\
 5, 1328, 4)
DeclareAlias2("threePhaseMotor1.aimc.airGapS.spacePhasor_s.v_[2]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor1.aimc.airGapS.der(psi_ms[2])", 1,\
 5, 1329, 4)
DeclareAlias2("threePhaseMotor1.aimc.airGapS.spacePhasor_s.i_[1]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor1.aimc.lssigma.i_[1]", 1, 5, 1198,\
 132)
DeclareAlias2("threePhaseMotor1.aimc.airGapS.spacePhasor_s.i_[2]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor1.aimc.lssigma.i_[2]", 1, 5, 1199,\
 132)
DeclareAlias2("threePhaseMotor1.aimc.airGapS.spacePhasor_r.v_[1]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor1.aimc.airGapS.der(psi_mr[1])", 1,\
 5, 1332, 4)
DeclareAlias2("threePhaseMotor1.aimc.airGapS.spacePhasor_r.v_[2]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor1.aimc.airGapS.der(psi_mr[2])", 1,\
 5, 1333, 4)
DeclareAlias2("threePhaseMotor1.aimc.airGapS.spacePhasor_r.i_[1]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor1.aimc.idq_rr[1]", 1, 1, 9, 132)
DeclareAlias2("threePhaseMotor1.aimc.airGapS.spacePhasor_r.i_[2]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor1.aimc.idq_rr[2]", 1, 1, 10, 132)
DeclareVariable("threePhaseMotor1.aimc.airGapS.i_ms[1]", "Magnetizing current space phasor with respect to the stator fixed frame [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.airGapS.i_ms[2]", "Magnetizing current space phasor with respect to the stator fixed frame [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.airGapS.der(i_ms[1])", "der(Magnetizing current space phasor with respect to the stator fixed frame) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.airGapS.der(i_ms[2])", "der(Magnetizing current space phasor with respect to the stator fixed frame) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor1.aimc.airGapS.L[1, 1]", "Inductance matrix [H]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor1.aimc.airGapS.L[1, 2]", "Inductance matrix [H]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor1.aimc.airGapS.L[2, 1]", "Inductance matrix [H]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor1.aimc.airGapS.L[2, 2]", "Inductance matrix [H]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor1.aimc.Lm", "Stator main field inductance per phase [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.Lrsigma", "Rotor stray inductance per phase (equivalent three phase winding) [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.Rr", "Rotor resistance per phase (equivalent three phase winding) at TRef [Ohm]",\
 0.04, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.TrRef", "Reference temperature of rotor resistance [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.alpha20r", "Temperature coefficient of rotor resistance at 20 degC [1/K]",\
 0, 0.0,0.0,0.0,0,513)
DeclareParameter("threePhaseMotor1.aimc.TrOperational", "Operational temperature of rotor resistance [K|degC]",\
 119, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("threePhaseMotor1.aimc.squirrelCageR.Lrsigma", "Rotor stray inductance per phase translated to stator [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.squirrelCageR.Rr", "Rotor resistance per phase translated to stator at T_ref [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.squirrelCageR.T_ref", "Reference temperature [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.squirrelCageR.alpha", "Temperature coefficient of resistance at T_ref [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimc.squirrelCageR.useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("threePhaseMotor1.aimc.squirrelCageR.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("threePhaseMotor1.aimc.squirrelCageR.heatPort.T", "Port temperature [K|degC]",\
 "threePhaseMotor1.aimc.thermalAmbient.constTr.k", 1, 5, 1306, 4)
DeclareAlias2("threePhaseMotor1.aimc.squirrelCageR.heatPort.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor1.aimc.powerBalance.lossPowerRotorWinding", -1, 5, 1134, 132)
DeclareAlias2("threePhaseMotor1.aimc.squirrelCageR.LossPower", "Loss power leaving component via heatPort [W]",\
 "threePhaseMotor1.aimc.powerBalance.lossPowerRotorWinding", 1, 5, 1134, 0)
DeclareAlias2("threePhaseMotor1.aimc.squirrelCageR.T_heatPort", "Temperature of heatPort [K|degC]",\
 "threePhaseMotor1.aimc.thermalAmbient.constTr.k", 1, 5, 1306, 0)
DeclareVariable("threePhaseMotor1.aimc.squirrelCageR.Rr_actual", \
"Actual resistance = Rr*(1 + alpha*(T_heatPort - T_ref)) [Ohm]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareAlias2("threePhaseMotor1.aimc.squirrelCageR.spacePhasor_r.v_[1]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor1.aimc.airGapS.der(psi_mr[1])", 1,\
 5, 1332, 4)
DeclareAlias2("threePhaseMotor1.aimc.squirrelCageR.spacePhasor_r.v_[2]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor1.aimc.airGapS.der(psi_mr[2])", 1,\
 5, 1333, 4)
DeclareAlias2("threePhaseMotor1.aimc.squirrelCageR.spacePhasor_r.i_[1]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor1.aimc.idq_rr[1]", -1, 1, 9, 132)
DeclareAlias2("threePhaseMotor1.aimc.squirrelCageR.spacePhasor_r.i_[2]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor1.aimc.idq_rr[2]", -1, 1, 10, 132)
DeclareAlias2("threePhaseMotor1.aimc.squirrelCageR.spacePhasor_r.der(i_[1])", \
"der(1=real, 2=imaginary part) [A/s]", "threePhaseMotor1.aimc.der(idq_rr[1])", -1,\
 6, 9, 4)
DeclareAlias2("threePhaseMotor1.aimc.squirrelCageR.spacePhasor_r.der(i_[2])", \
"der(1=real, 2=imaginary part) [A/s]", "threePhaseMotor1.aimc.der(idq_rr[2])", -1,\
 6, 10, 4)
DeclareAlias2("threePhaseMotor1.aimc.squirrelCageR.i[1]", "Currents out from squirrel cage [A]",\
 "threePhaseMotor1.aimc.idq_rr[1]", 1, 1, 9, 0)
DeclareAlias2("threePhaseMotor1.aimc.squirrelCageR.i[2]", "Currents out from squirrel cage [A]",\
 "threePhaseMotor1.aimc.idq_rr[2]", 1, 1, 10, 0)
DeclareVariable("threePhaseMotor1.terminalBox.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("threePhaseMotor1.terminalBox.plug_sp.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("threePhaseMotor1.terminalBox.plug_sp.pin[1].v", "Potential at the pin [V]",\
 "inverter1.ac.pin[1].v", 1, 5, 760, 4)
DeclareAlias2("threePhaseMotor1.terminalBox.plug_sp.pin[1].i", "Current flowing into the pin [A]",\
 "inverter1.ac.pin[1].i", 1, 5, 761, 132)
DeclareAlias2("threePhaseMotor1.terminalBox.plug_sp.pin[2].v", "Potential at the pin [V]",\
 "inverter1.ac.pin[2].v", 1, 5, 762, 4)
DeclareAlias2("threePhaseMotor1.terminalBox.plug_sp.pin[2].i", "Current flowing into the pin [A]",\
 "inverter1.ac.pin[2].i", 1, 5, 763, 132)
DeclareAlias2("threePhaseMotor1.terminalBox.plug_sp.pin[3].v", "Potential at the pin [V]",\
 "inverter1.ac.pin[3].v", 1, 5, 764, 4)
DeclareAlias2("threePhaseMotor1.terminalBox.plug_sp.pin[3].i", "Current flowing into the pin [A]",\
 "inverter1.ac.pin[3].i", 1, 5, 765, 132)
DeclareVariable("threePhaseMotor1.terminalBox.plug_sn.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("threePhaseMotor1.terminalBox.plug_sn.pin[1].v", "Potential at the pin [V]",\
 "threePhaseMotor1.aimc.plug_sn.pin[1].v", 1, 5, 1146, 4)
DeclareAlias2("threePhaseMotor1.terminalBox.plug_sn.pin[1].i", "Current flowing into the pin [A]",\
 "inverter1.ac.pin[1].i", -1, 5, 761, 132)
DeclareAlias2("threePhaseMotor1.terminalBox.plug_sn.pin[2].v", "Potential at the pin [V]",\
 "threePhaseMotor1.aimc.plug_sn.pin[1].v", 1, 5, 1146, 4)
DeclareAlias2("threePhaseMotor1.terminalBox.plug_sn.pin[2].i", "Current flowing into the pin [A]",\
 "inverter1.ac.pin[2].i", -1, 5, 763, 132)
DeclareAlias2("threePhaseMotor1.terminalBox.plug_sn.pin[3].v", "Potential at the pin [V]",\
 "threePhaseMotor1.aimc.plug_sn.pin[1].v", 1, 5, 1146, 4)
DeclareAlias2("threePhaseMotor1.terminalBox.plug_sn.pin[3].i", "Current flowing into the pin [A]",\
 "inverter1.ac.pin[3].i", -1, 5, 765, 132)
DeclareVariable("threePhaseMotor1.terminalBox.star.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("threePhaseMotor1.terminalBox.star.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("threePhaseMotor1.terminalBox.star.plug_p.pin[1].v", \
"Potential at the pin [V]", "threePhaseMotor1.aimc.plug_sn.pin[1].v", 1, 5, 1146,\
 4)
DeclareAlias2("threePhaseMotor1.terminalBox.star.plug_p.pin[1].i", \
"Current flowing into the pin [A]", "inverter1.ac.pin[1].i", -1, 5, 761, 132)
DeclareAlias2("threePhaseMotor1.terminalBox.star.plug_p.pin[2].v", \
"Potential at the pin [V]", "threePhaseMotor1.aimc.plug_sn.pin[1].v", 1, 5, 1146,\
 4)
DeclareAlias2("threePhaseMotor1.terminalBox.star.plug_p.pin[2].i", \
"Current flowing into the pin [A]", "inverter1.ac.pin[2].i", -1, 5, 763, 132)
DeclareAlias2("threePhaseMotor1.terminalBox.star.plug_p.pin[3].v", \
"Potential at the pin [V]", "threePhaseMotor1.aimc.plug_sn.pin[1].v", 1, 5, 1146,\
 4)
DeclareAlias2("threePhaseMotor1.terminalBox.star.plug_p.pin[3].i", \
"Current flowing into the pin [A]", "inverter1.ac.pin[3].i", -1, 5, 765, 132)
DeclareAlias2("threePhaseMotor1.terminalBox.star.pin_n.v", "Potential at the pin [V]",\
 "threePhaseMotor1.aimc.plug_sn.pin[1].v", 1, 5, 1146, 4)
DeclareVariable("threePhaseMotor1.terminalBox.star.pin_n.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor1.terminalBox.plugSupply.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("threePhaseMotor1.terminalBox.plugSupply.pin[1].v", \
"Potential at the pin [V]", "inverter1.ac.pin[1].v", 1, 5, 760, 4)
DeclareAlias2("threePhaseMotor1.terminalBox.plugSupply.pin[1].i", \
"Current flowing into the pin [A]", "inverter1.ac.pin[1].i", -1, 5, 761, 132)
DeclareAlias2("threePhaseMotor1.terminalBox.plugSupply.pin[2].v", \
"Potential at the pin [V]", "inverter1.ac.pin[2].v", 1, 5, 762, 4)
DeclareAlias2("threePhaseMotor1.terminalBox.plugSupply.pin[2].i", \
"Current flowing into the pin [A]", "inverter1.ac.pin[2].i", -1, 5, 763, 132)
DeclareAlias2("threePhaseMotor1.terminalBox.plugSupply.pin[3].v", \
"Potential at the pin [V]", "inverter1.ac.pin[3].v", 1, 5, 764, 4)
DeclareAlias2("threePhaseMotor1.terminalBox.plugSupply.pin[3].i", \
"Current flowing into the pin [A]", "inverter1.ac.pin[3].i", -1, 5, 765, 132)
DeclareAlias2("threePhaseMotor1.terminalBox.starpoint.v", "Potential at the pin [V]",\
 "threePhaseMotor1.aimc.plug_sn.pin[1].v", 1, 5, 1146, 4)
DeclareVariable("threePhaseMotor1.terminalBox.starpoint.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("threePhaseMotor1.flange1.phi", "Absolute rotation angle of flange [rad|deg]",\
 "variableSpeedDrive_ThreePhase1.speedSensor.flange.phi", 1, 1, 11, 4)
DeclareVariable("threePhaseMotor1.flange1.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("threePhaseMotor1.aimcData.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareParameter("threePhaseMotor1.aimcData.Jr", "Rotor's moment of inertia [kg.m2]",\
 120, 0.29, 0.0,0.0,0.0,0,560)
DeclareVariable("threePhaseMotor1.aimcData.Js", "Stator's moment of inertia [kg.m2]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("threePhaseMotor1.aimcData.p", "Number of pole pairs (Integer) [:#(type=Integer)]",\
 121, 2, 1.0,1E+100,0.0,0,564)
DeclareParameter("threePhaseMotor1.aimcData.fsNominal", "Nominal frequency [Hz]",\
 122, 50, 0.0,0.0,0.0,0,560)
DeclareParameter("threePhaseMotor1.aimcData.Rs", "Stator resistance per phase at TRef [Ohm]",\
 123, 0.03, 0.0,0.0,0.0,0,560)
DeclareParameter("threePhaseMotor1.aimcData.TsRef", "Reference temperature of stator resistance [K|degC]",\
 124, 293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("threePhaseMotor1.aimcData.alpha20s", "Temperature coefficient of stator resistance at 20 degC [1/K]",\
 125, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("threePhaseMotor1.aimcData.effectiveStatorTurns", \
"Effective number of stator turns", 126, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("threePhaseMotor1.aimcData.Lszero", "Stator zero sequence inductance [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimcData.Lssigma", "Stator stray inductance per phase [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimcData.frictionParameters.PRef", \
"Reference friction losses at wRef [W]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimcData.frictionParameters.wRef", \
"Reference angular velocity that the PRef refer to [rad/s|rev/min]", 1E-60, \
1E-60,1E+100,0.0,0,513)
DeclareParameter("threePhaseMotor1.aimcData.frictionParameters.power_w", \
"Exponent of friction torque w.r.t. angular velocity", 127, 2, 1E-60,1E+100,0.0,\
0,560)
DeclareVariable("threePhaseMotor1.aimcData.frictionParameters.tauRef", \
"Reference friction torque at reference angular velocity [N.m]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("threePhaseMotor1.aimcData.frictionParameters.linear", \
"Linear angular velocity range with respect to reference angular velocity [1]", \
0.001, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimcData.frictionParameters.wLinear", \
"Linear angular velocity range [rad/s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimcData.frictionParameters.tauLinear", \
"Torque corresponding with linear angular velocity range [N.m]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("threePhaseMotor1.aimcData.statorCoreParameters.m", \
"Number of phases (1 for DC, 3 for induction machines) [:#(type=Integer)]", 3, \
0.0,0.0,0.0,0,517)
DeclareVariable("threePhaseMotor1.aimcData.statorCoreParameters.PRef", \
"Reference core losses at reference inner voltage VRef [W]", 0, 0.0,1E+100,0.0,0,513)
DeclareParameter("threePhaseMotor1.aimcData.statorCoreParameters.VRef", \
"Reference inner RMS voltage that reference core losses PRef refer to [V]", 128,\
 100, 1E-60,1E+100,0.0,0,560)
DeclareVariable("threePhaseMotor1.aimcData.statorCoreParameters.wRef", \
"Reference angular velocity that reference core losses PRef refer to [rad/s]", \
1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimcData.statorCoreParameters.ratioHysteresis",\
 "Ratio of hysteresis losses with respect to the total core losses at VRef and fRef",\
 0, 0.0,1.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimcData.statorCoreParameters.GcRef", \
"Reference conductance at reference frequency and voltage [S]", 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("threePhaseMotor1.aimcData.statorCoreParameters.wMin", "[rad/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimcData.strayLoadParameters.PRef", \
"Reference stray load losses at IRef and wRef [W]", 0, 0.0,1E+100,0.0,0,513)
DeclareParameter("threePhaseMotor1.aimcData.strayLoadParameters.IRef", \
"Reference RMS current that PRef refers to [A]", 129, 100, 1E-60,1E+100,0.0,0,560)
DeclareVariable("threePhaseMotor1.aimcData.strayLoadParameters.wRef", \
"Reference angular velocity that PRef refers to [rad/s|rev/min]", 1E-60, 1E-60,\
1E+100,0.0,0,513)
DeclareParameter("threePhaseMotor1.aimcData.strayLoadParameters.power_w", \
"Exponent of stray load loss torque w.r.t. angular velocity", 130, 1, 1E-60,\
1E+100,0.0,0,560)
DeclareVariable("threePhaseMotor1.aimcData.strayLoadParameters.tauRef", \
"Reference stray load torque at reference angular velocity and reference current [N.m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimcData.Lm", "Stator main field inductance per phase [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor1.aimcData.Lrsigma", "Rotor stray inductance per phase (equivalent three phase winding) [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("threePhaseMotor1.aimcData.Rr", "Rotor resistance per phase (equivalent three phase winding) at TRef [Ohm]",\
 131, 0.04, 0.0,0.0,0.0,0,560)
DeclareParameter("threePhaseMotor1.aimcData.TrRef", "Reference temperature of rotor resistance [K|degC]",\
 132, 293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("threePhaseMotor1.aimcData.alpha20r", "Temperature coefficient of rotor resistance at 20 degC [1/K]",\
 133, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("threePhaseMotor1.plug_p1.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("threePhaseMotor1.plug_p1.pin[1].v", "Potential at the pin [V]", \
"inverter1.ac.pin[1].v", 1, 5, 760, 4)
DeclareAlias2("threePhaseMotor1.plug_p1.pin[1].i", "Current flowing into the pin [A]",\
 "inverter1.ac.pin[1].i", -1, 5, 761, 132)
DeclareAlias2("threePhaseMotor1.plug_p1.pin[2].v", "Potential at the pin [V]", \
"inverter1.ac.pin[2].v", 1, 5, 762, 4)
DeclareAlias2("threePhaseMotor1.plug_p1.pin[2].i", "Current flowing into the pin [A]",\
 "inverter1.ac.pin[2].i", -1, 5, 763, 132)
DeclareAlias2("threePhaseMotor1.plug_p1.pin[3].v", "Potential at the pin [V]", \
"inverter1.ac.pin[3].v", 1, 5, 764, 4)
DeclareAlias2("threePhaseMotor1.plug_p1.pin[3].i", "Current flowing into the pin [A]",\
 "inverter1.ac.pin[3].i", -1, 5, 765, 132)
DeclareVariable("threePhaseMotor1.rpm", "Reference speed of the generator [rad/s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("signalPWM3[1].useConstantDutyCycle", "Enables constant duty cycle [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("signalPWM3[1].constantDutyCycle", "Constant duty cycle", 134, 0,\
 0.0,0.0,0.0,0,560)
DeclareParameter("signalPWM3[1].f", "Switching frequency [Hz|kHz]", 135, 100000,\
 0.0,0.0,0.0,0,560)
DeclareParameter("signalPWM3[1].startTime", "Start time [s]", 136, 0, 0.0,0.0,\
0.0,0,560)
DeclareAlias2("signalPWM3[1].dutyCycle", "Duty cycle [rad/s]", "variableSpeedDrive_ThreePhase1.y1[1]", 1,\
 5, 1457, 0)
DeclareAlias2("signalPWM3[1].fire", "Firing PWM signal [:#(type=Boolean)]", \
"inverter1.fire_n[1]", 1, 5, 752, 65)
DeclareAlias2("signalPWM3[1].notFire", "Firing PWM signal [:#(type=Boolean)]", \
"inverter1.fire_p[1]", 1, 5, 744, 65)
DeclareParameter("signalPWM3[1].limiter.uMax", "Upper limits of input signals [rad/s]",\
 137, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("signalPWM3[1].limiter.uMin", "Lower limits of input signals [rad/s]",\
 138, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("signalPWM3[1].limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("signalPWM3[1].limiter.homotopyType", "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("signalPWM3[1].limiter.limitsAtInit", "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("signalPWM3[1].limiter.u", "Connector of Real input signal [rad/s]",\
 "variableSpeedDrive_ThreePhase1.y1[1]", 1, 5, 1457, 0)
DeclareVariable("signalPWM3[1].limiter.y", "Connector of Real output signal [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("signalPWM3[1].limiter.simplifiedExpr", "Simplified expression for homotopy-based initialization [rad/s]",\
 "variableSpeedDrive_ThreePhase1.y1[1]", 1, 5, 1457, 1024)
DeclareVariable("signalPWM3[1].greaterEqual.u1", "Connector of first Real input signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("signalPWM3[1].greaterEqual.u2", "Connector of second Real input signal [rad/s]",\
 0.0, 0.0,0.0,0.0,0,640)
DeclareAlias2("signalPWM3[1].greaterEqual.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter1.fire_n[1]", 1, 5, 752, 65)
DeclareVariable("signalPWM3[1].zeroOrderHold.samplePeriod", "Sample period of component [s]",\
 0.1, 1E-13,1E+100,0.0,0,513)
DeclareVariable("signalPWM3[1].zeroOrderHold.startTime", "First sample time instant [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM3[1].zeroOrderHold.sampleTrigger", "True, if sample time instant [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2690)
DeclareVariable("signalPWM3[1].zeroOrderHold.firstTrigger", "Rising edge signals first sample instant [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2706)
DeclareAlias2("signalPWM3[1].zeroOrderHold.u", "Connector of Real input signal [rad/s]",\
 "signalPWM3[1].limiter.y", 1, 5, 1398, 0)
DeclareAlias2("signalPWM3[1].zeroOrderHold.y", "Connector of Real output signal [rad/s]",\
 "signalPWM3[1].greaterEqual.u2", 1, 5, 1400, 0)
DeclareVariable("signalPWM3[1].zeroOrderHold.ySample", "[rad/s]", 0, 0.0,0.0,0.0,\
0,656)
DeclareVariable("signalPWM3[1].sawtooth.amplitude", "Amplitude of saw tooth", 1,\
 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM3[1].sawtooth.period", "Time for one period [s]", 1, \
1E-60,1E+100,0.0,0,513)
DeclareVariable("signalPWM3[1].sawtooth.nperiod", "Number of periods (< 0 means infinite number of periods) [:#(type=Integer)]",\
 -1, 0.0,0.0,0.0,0,517)
DeclareAlias2("signalPWM3[1].sawtooth.y", "Connector of Real output signal", \
"signalPWM3[1].greaterEqual.u1", 1, 5, 1399, 0)
DeclareVariable("signalPWM3[1].sawtooth.offset", "Offset of output signal y", 0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM3[1].sawtooth.startTime", "Output y = offset for time < startTime [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM3[1].sawtooth.T_start", "Start time of current period [s]",\
 0.0, 0.0,0.0,0.0,0,2688)
DeclareVariable("signalPWM3[1].sawtooth.count", "Period count [:#(type=Integer)]",\
 0, 0.0,0.0,0.0,0,2692)
DeclareAlias2("signalPWM3[1].inverse.u", "Connector of Boolean input signal [:#(type=Boolean)]",\
 "inverter1.fire_n[1]", 1, 5, 752, 65)
DeclareAlias2("signalPWM3[1].inverse.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter1.fire_p[1]", 1, 5, 744, 65)
DeclareVariable("signalPWM3[2].useConstantDutyCycle", "Enables constant duty cycle [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("signalPWM3[2].constantDutyCycle", "Constant duty cycle", 139, 0,\
 0.0,0.0,0.0,0,560)
DeclareParameter("signalPWM3[2].f", "Switching frequency [Hz|kHz]", 140, 100000,\
 0.0,0.0,0.0,0,560)
DeclareParameter("signalPWM3[2].startTime", "Start time [s]", 141, 0, 0.0,0.0,\
0.0,0,560)
DeclareAlias2("signalPWM3[2].dutyCycle", "Duty cycle [rad/s]", "variableSpeedDrive_ThreePhase1.y1[1]", 1,\
 5, 1457, 0)
DeclareAlias2("signalPWM3[2].fire", "Firing PWM signal [:#(type=Boolean)]", \
"inverter1.fire_n[2]", 1, 5, 753, 65)
DeclareAlias2("signalPWM3[2].notFire", "Firing PWM signal [:#(type=Boolean)]", \
"inverter1.fire_p[2]", 1, 5, 745, 65)
DeclareParameter("signalPWM3[2].limiter.uMax", "Upper limits of input signals [rad/s]",\
 142, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("signalPWM3[2].limiter.uMin", "Lower limits of input signals [rad/s]",\
 143, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("signalPWM3[2].limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("signalPWM3[2].limiter.homotopyType", "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("signalPWM3[2].limiter.limitsAtInit", "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("signalPWM3[2].limiter.u", "Connector of Real input signal [rad/s]",\
 "variableSpeedDrive_ThreePhase1.y1[1]", 1, 5, 1457, 0)
DeclareVariable("signalPWM3[2].limiter.y", "Connector of Real output signal [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("signalPWM3[2].limiter.simplifiedExpr", "Simplified expression for homotopy-based initialization [rad/s]",\
 "variableSpeedDrive_ThreePhase1.y1[1]", 1, 5, 1457, 1024)
DeclareVariable("signalPWM3[2].greaterEqual.u1", "Connector of first Real input signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("signalPWM3[2].greaterEqual.u2", "Connector of second Real input signal [rad/s]",\
 0.0, 0.0,0.0,0.0,0,640)
DeclareAlias2("signalPWM3[2].greaterEqual.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter1.fire_n[2]", 1, 5, 753, 65)
DeclareVariable("signalPWM3[2].zeroOrderHold.samplePeriod", "Sample period of component [s]",\
 0.1, 1E-13,1E+100,0.0,0,513)
DeclareVariable("signalPWM3[2].zeroOrderHold.startTime", "First sample time instant [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM3[2].zeroOrderHold.sampleTrigger", "True, if sample time instant [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2690)
DeclareVariable("signalPWM3[2].zeroOrderHold.firstTrigger", "Rising edge signals first sample instant [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2706)
DeclareAlias2("signalPWM3[2].zeroOrderHold.u", "Connector of Real input signal [rad/s]",\
 "signalPWM3[2].limiter.y", 1, 5, 1417, 0)
DeclareAlias2("signalPWM3[2].zeroOrderHold.y", "Connector of Real output signal [rad/s]",\
 "signalPWM3[2].greaterEqual.u2", 1, 5, 1419, 0)
DeclareVariable("signalPWM3[2].zeroOrderHold.ySample", "[rad/s]", 0, 0.0,0.0,0.0,\
0,656)
DeclareVariable("signalPWM3[2].sawtooth.amplitude", "Amplitude of saw tooth", 1,\
 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM3[2].sawtooth.period", "Time for one period [s]", 1, \
1E-60,1E+100,0.0,0,513)
DeclareVariable("signalPWM3[2].sawtooth.nperiod", "Number of periods (< 0 means infinite number of periods) [:#(type=Integer)]",\
 -1, 0.0,0.0,0.0,0,517)
DeclareAlias2("signalPWM3[2].sawtooth.y", "Connector of Real output signal", \
"signalPWM3[2].greaterEqual.u1", 1, 5, 1418, 0)
DeclareVariable("signalPWM3[2].sawtooth.offset", "Offset of output signal y", 0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM3[2].sawtooth.startTime", "Output y = offset for time < startTime [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM3[2].sawtooth.T_start", "Start time of current period [s]",\
 0.0, 0.0,0.0,0.0,0,2688)
DeclareVariable("signalPWM3[2].sawtooth.count", "Period count [:#(type=Integer)]",\
 0, 0.0,0.0,0.0,0,2692)
DeclareAlias2("signalPWM3[2].inverse.u", "Connector of Boolean input signal [:#(type=Boolean)]",\
 "inverter1.fire_n[2]", 1, 5, 753, 65)
DeclareAlias2("signalPWM3[2].inverse.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter1.fire_p[2]", 1, 5, 745, 65)
DeclareVariable("signalPWM3[3].useConstantDutyCycle", "Enables constant duty cycle [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("signalPWM3[3].constantDutyCycle", "Constant duty cycle", 144, 0,\
 0.0,0.0,0.0,0,560)
DeclareParameter("signalPWM3[3].f", "Switching frequency [Hz|kHz]", 145, 100000,\
 0.0,0.0,0.0,0,560)
DeclareParameter("signalPWM3[3].startTime", "Start time [s]", 146, 0, 0.0,0.0,\
0.0,0,560)
DeclareAlias2("signalPWM3[3].dutyCycle", "Duty cycle [rad/s]", "variableSpeedDrive_ThreePhase1.y1[1]", 1,\
 5, 1457, 0)
DeclareAlias2("signalPWM3[3].fire", "Firing PWM signal [:#(type=Boolean)]", \
"inverter1.fire_n[3]", 1, 5, 754, 65)
DeclareAlias2("signalPWM3[3].notFire", "Firing PWM signal [:#(type=Boolean)]", \
"inverter1.fire_p[3]", 1, 5, 746, 65)
DeclareParameter("signalPWM3[3].limiter.uMax", "Upper limits of input signals [rad/s]",\
 147, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("signalPWM3[3].limiter.uMin", "Lower limits of input signals [rad/s]",\
 148, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("signalPWM3[3].limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("signalPWM3[3].limiter.homotopyType", "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("signalPWM3[3].limiter.limitsAtInit", "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("signalPWM3[3].limiter.u", "Connector of Real input signal [rad/s]",\
 "variableSpeedDrive_ThreePhase1.y1[1]", 1, 5, 1457, 0)
DeclareVariable("signalPWM3[3].limiter.y", "Connector of Real output signal [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("signalPWM3[3].limiter.simplifiedExpr", "Simplified expression for homotopy-based initialization [rad/s]",\
 "variableSpeedDrive_ThreePhase1.y1[1]", 1, 5, 1457, 1024)
DeclareVariable("signalPWM3[3].greaterEqual.u1", "Connector of first Real input signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("signalPWM3[3].greaterEqual.u2", "Connector of second Real input signal [rad/s]",\
 0.0, 0.0,0.0,0.0,0,640)
DeclareAlias2("signalPWM3[3].greaterEqual.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter1.fire_n[3]", 1, 5, 754, 65)
DeclareVariable("signalPWM3[3].zeroOrderHold.samplePeriod", "Sample period of component [s]",\
 0.1, 1E-13,1E+100,0.0,0,513)
DeclareVariable("signalPWM3[3].zeroOrderHold.startTime", "First sample time instant [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM3[3].zeroOrderHold.sampleTrigger", "True, if sample time instant [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2690)
DeclareVariable("signalPWM3[3].zeroOrderHold.firstTrigger", "Rising edge signals first sample instant [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2706)
DeclareAlias2("signalPWM3[3].zeroOrderHold.u", "Connector of Real input signal [rad/s]",\
 "signalPWM3[3].limiter.y", 1, 5, 1436, 0)
DeclareAlias2("signalPWM3[3].zeroOrderHold.y", "Connector of Real output signal [rad/s]",\
 "signalPWM3[3].greaterEqual.u2", 1, 5, 1438, 0)
DeclareVariable("signalPWM3[3].zeroOrderHold.ySample", "[rad/s]", 0, 0.0,0.0,0.0,\
0,656)
DeclareVariable("signalPWM3[3].sawtooth.amplitude", "Amplitude of saw tooth", 1,\
 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM3[3].sawtooth.period", "Time for one period [s]", 1, \
1E-60,1E+100,0.0,0,513)
DeclareVariable("signalPWM3[3].sawtooth.nperiod", "Number of periods (< 0 means infinite number of periods) [:#(type=Integer)]",\
 -1, 0.0,0.0,0.0,0,517)
DeclareAlias2("signalPWM3[3].sawtooth.y", "Connector of Real output signal", \
"signalPWM3[3].greaterEqual.u1", 1, 5, 1437, 0)
DeclareVariable("signalPWM3[3].sawtooth.offset", "Offset of output signal y", 0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM3[3].sawtooth.startTime", "Output y = offset for time < startTime [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM3[3].sawtooth.T_start", "Start time of current period [s]",\
 0.0, 0.0,0.0,0.0,0,2688)
DeclareVariable("signalPWM3[3].sawtooth.count", "Period count [:#(type=Integer)]",\
 0, 0.0,0.0,0.0,0,2692)
DeclareAlias2("signalPWM3[3].inverse.u", "Connector of Boolean input signal [:#(type=Boolean)]",\
 "inverter1.fire_n[3]", 1, 5, 754, 65)
DeclareAlias2("signalPWM3[3].inverse.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter1.fire_p[3]", 1, 5, 746, 65)
DeclareState("variableSpeedDrive_ThreePhase1.speedSensor.flange.phi", \
"Absolute rotation angle of flange [rad|deg]", 11, 0.0, 0.0,0.0,0.0,0,568)
DeclareDerivative("variableSpeedDrive_ThreePhase1.speedSensor.flange.der(phi)", \
"der(Absolute rotation angle of flange) [rad/s]", 0.0, 0.0,0.0,0.0,0,520)
DeclareVariable("variableSpeedDrive_ThreePhase1.speedSensor.flange.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("variableSpeedDrive_ThreePhase1.speedSensor.w", "Absolute angular velocity of flange as output signal [rad/s]",\
 "variableSpeedDrive_ThreePhase1.speedSensor.flange.der(phi)", 1, 6, 11, 0)
DeclareVariable("variableSpeedDrive_ThreePhase1.currentController.k", "Gain [1]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("variableSpeedDrive_ThreePhase1.currentController.T", \
"Time Constant (T>0 required) [s]", 1, 1E-60,1E+100,0.0,0,513)
DeclareVariable("variableSpeedDrive_ThreePhase1.currentController.initType", \
"Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareParameter("variableSpeedDrive_ThreePhase1.currentController.x_start", \
"Initial or guess value of state [rad/s]", 149, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("variableSpeedDrive_ThreePhase1.currentController.y_start", \
"Initial value of output [rad/s]", 150, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("variableSpeedDrive_ThreePhase1.currentController.u", \
"Connector of Real input signal [rad/s]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("variableSpeedDrive_ThreePhase1.currentController.y", \
"Connector of Real output signal [rad/s]", "variableSpeedDrive_ThreePhase1.y1[1]", 1,\
 5, 1457, 0)
DeclareState("variableSpeedDrive_ThreePhase1.currentController.x", \
"State of block [rad/s]", 12, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("variableSpeedDrive_ThreePhase1.currentController.der(x)", \
"der(State of block) [rad/s2]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("variableSpeedDrive_ThreePhase1.flange1.phi", "Absolute rotation angle of flange [rad|deg]",\
 "variableSpeedDrive_ThreePhase1.speedSensor.flange.phi", 1, 1, 11, 4)
DeclareVariable("variableSpeedDrive_ThreePhase1.flange1.tau", "Cut torque in the flange [N.m]",\
 0, 0.0,0.0,0.0,0,777)
DeclareVariable("variableSpeedDrive_ThreePhase1.y1[1]", "Connector of Real output signal [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("variableSpeedDrive_ThreePhase1.y1[2]", "Connector of Real output signal [rad/s]",\
 "variableSpeedDrive_ThreePhase1.y1[1]", 1, 5, 1457, 0)
DeclareAlias2("variableSpeedDrive_ThreePhase1.y1[3]", "Connector of Real output signal [rad/s]",\
 "variableSpeedDrive_ThreePhase1.y1[1]", 1, 5, 1457, 0)
DeclareVariable("variableSpeedDrive_ThreePhase1.const.k", "Constant output value [rad/s]",\
 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("variableSpeedDrive_ThreePhase1.const.y", "Connector of Real output signal [rad/s]",\
 "variableSpeedDrive_ThreePhase1.const.k", 1, 5, 1458, 0)
DeclareParameter("variableSpeedDrive_ThreePhase1.wref", "Constant output value [rad/s]",\
 151, 41000, 0.0,0.0,0.0,0,560)
DeclareAlias2("variableSpeedDrive_ThreePhase1.feedback.u1", "[rad/s]", \
"variableSpeedDrive_ThreePhase1.speedSensor.flange.der(phi)", 1, 6, 11, 0)
DeclareAlias2("variableSpeedDrive_ThreePhase1.feedback.u2", "[rad/s]", \
"variableSpeedDrive_ThreePhase1.const.k", 1, 5, 1458, 0)
DeclareAlias2("variableSpeedDrive_ThreePhase1.feedback.y", "[rad/s]", \
"variableSpeedDrive_ThreePhase1.currentController.u", 1, 5, 1455, 0)
DeclareParameter("variableSpeedDrive_ThreePhase1.T", "Time Constant (T>0 required) [s]",\
 152, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("variableSpeedDrive_ThreePhase1.k", "Gain [1]", 153, 1, \
0.0,0.0,0.0,0,560)
DeclareAlias2("variableSpeedDrive_ThreePhase1.realExtend.u", "[rad/s]", \
"variableSpeedDrive_ThreePhase1.y1[1]", 1, 5, 1457, 0)
DeclareAlias2("variableSpeedDrive_ThreePhase1.realExtend.y[1]", "[rad/s]", \
"variableSpeedDrive_ThreePhase1.y1[1]", 1, 5, 1457, 0)
DeclareAlias2("variableSpeedDrive_ThreePhase1.realExtend.y[2]", "[rad/s]", \
"variableSpeedDrive_ThreePhase1.y1[1]", 1, 5, 1457, 0)
DeclareAlias2("variableSpeedDrive_ThreePhase1.realExtend.y[3]", "[rad/s]", \
"variableSpeedDrive_ThreePhase1.y1[1]", 1, 5, 1457, 0)
DeclareAlias2("fan1.inertia.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "variableSpeedDrive_ThreePhase1.speedSensor.flange.phi", 1, 1, 11, 4)
DeclareAlias2("fan1.inertia.flange_a.tau", "Cut torque in the flange [N.m]", \
"threePhaseMotor1.flange1.tau", -1, 5, 1370, 132)
DeclareAlias2("fan1.inertia.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "variableSpeedDrive_ThreePhase1.speedSensor.flange.phi", 1, 1, 11, 4)
DeclareVariable("fan1.inertia.flange_b.tau", "Cut torque in the flange [N.m]", \
0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("fan1.inertia.J", "Moment of inertia [kg.m2]", 1, 0.0,1E+100,0.0,\
0,513)
DeclareVariable("fan1.inertia.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 3, 1.0,5.0,0.0,0,1541)
DeclareAlias2("fan1.inertia.phi", "Absolute rotation angle of component [rad|deg]",\
 "variableSpeedDrive_ThreePhase1.speedSensor.flange.phi", 1, 1, 11, 0)
DeclareAlias2("fan1.inertia.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 "fan1.inertia.w", 1, 1, 13, 0)
DeclareState("fan1.inertia.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 13, 0, 0.0,0.0,0.0,0,544)
DeclareDerivative("fan1.inertia.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("fan1.inertia.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "fan1.inertia.der(w)", 1, 6, 13, 0)
DeclareAlias2("fan1.flange_a1.phi", "Absolute rotation angle of flange [rad|deg]",\
 "variableSpeedDrive_ThreePhase1.speedSensor.flange.phi", 1, 1, 11, 4)
DeclareAlias2("fan1.flange_a1.tau", "Cut torque in the flange [N.m]", \
"threePhaseMotor1.flange1.tau", -1, 5, 1370, 132)
DeclareParameter("fan1.J", "Moment of inertia of the fan blades [kg.m2]", 154, 1,\
 0.0,0.0,0.0,0,560)
DeclareParameter("fan1.deltaPhi", "Fixed rotation of left flange with respect to right flange [rad|deg]",\
 155, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("splitterHVDC.plug_a.p.v", "Potential at the pin [V]", \
"dcdc1.dc_p1.v", 1, 5, 1002, 4)
DeclareVariable("splitterHVDC.plug_a.p.i", "Current flowing into the pin [A]", \
0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("splitterHVDC.plug_a.n.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,521)
DeclareVariable("splitterHVDC.plug_a.n.i", "Current flowing into the pin [A]", \
0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("splitterHVDC.p.v", "Potential at the pin [V]", "dcdc1.dc_p1.v", 1,\
 5, 1002, 4)
DeclareVariable("splitterHVDC.p.i", "Current flowing into the pin [A]", 0.0, \
0.0,0.0,0.0,0,777)
DeclareVariable("splitterHVDC.n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,\
0,521)
DeclareVariable("splitterHVDC.n.i", "Current flowing into the pin [A]", 0.0, \
0.0,0.0,0.0,0,777)
DeclareVariable("batteryPack.enable_thermal_port", "=true, if heat is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("batteryPack.internal_ground", "Enable internal reference to electrical ground [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("batteryPack.display_name", "Display the component name in the diagram layer [:#(type=Boolean)]",\
 156, false, 0.0,0.0,0.0,0,562)
DeclareParameter("batteryPack.id", "Component identifier on the control system bus [:#(type=Integer)]",\
 157, 1, 0.0,0.0,0.0,0,564)
DeclareAlias2("batteryPack.plug_a.p.v", "Potential at the pin [V]", \
"batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 4)
DeclareVariable("batteryPack.plug_a.p.i", "Current flowing into the pin [A]", \
0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("batteryPack.plug_a.n.v", "Potential at the pin [V]", 0, \
0.0,0.0,0.0,0,521)
DeclareVariable("batteryPack.plug_a.n.i", "Current flowing into the pin [A]", \
0.0, 0.0,0.0,0.0,0,777)
DeclareParameter("batteryPack.hide_interface_icon", "[:#(type=Boolean)]", 158, \
false, 0.0,0.0,0.0,0,562)
DeclareParameter("batteryPack.ns", "Number of cells connected in series [:#(type=Integer)]",\
 159, 100, 1.0,1E+100,0.0,0,564)
DeclareParameter("batteryPack.np", "Number of cells connected in parallel [:#(type=Integer)]",\
 160, 2, 1.0,1E+100,0.0,0,564)
DeclareVariable("batteryPack.gs", "Lumped grouping of cells in series (size of the array in the model only) [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.gp", "Lumped grouping of cells in parallel (size of the array in the model only) [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.ngs", "Number of cells per lumped group in series [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.ngp", "Number of cells per lumped group in parallel [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.cellGroups", "Lumped pack, individual cells, or custom group [:#(type=Electrification.Batteries.Utilities.Types.VirtualPackSize)]",\
 1, 1.0,3.0,0.0,0,517)
DeclareParameter("batteryPack.gs_custom", "Number of cell groups (cores) in series [:#(type=Integer)]",\
 161, 1, 1.0,1E+100,0.0,0,564)
DeclareParameter("batteryPack.gp_custom", "Number of cell groups (cores) in parallel [:#(type=Integer)]",\
 162, 1, 1.0,1E+100,0.0,0,564)
DeclareVariable("batteryPack.is_lumped", "[:#(type=Boolean)]", true, 0.0,0.0,0.0,\
0,2563)
DeclareVariable("batteryPack.is_custom", "[:#(type=Boolean)]", false, 0.0,0.0,\
0.0,0,2563)
DeclareVariable("batteryPack.Q_cap_all_nom", "Nominal Battery capacity [C]", 0.0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.initialize_with_OCV", "Initialize SoC from OCV_start [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("batteryPack.SOC_start", "Initial state of charge (SoC) [0..1] [1]",\
 163, 0.6, 0.0,0.0,0.0,0,560)
DeclareVariable("batteryPack.OCV_start", "Initial open circuit voltage (OCV) [V]",\
 300, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.limitActionSoC", "SoC [:#(type=Electrification.Utilities.Types.FaultAction)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("batteryPack.limitActionV", "Voltage [:#(type=Electrification.Utilities.Types.FaultAction)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("batteryPack.limitActionI", "Current [:#(type=Electrification.Utilities.Types.FaultAction)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareVariable("batteryPack.limitActionP", "Power [:#(type=Electrification.Utilities.Types.FaultAction)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareVariable("batteryPack.limitActionDch", "Discharge power [:#(type=Electrification.Utilities.Types.FaultAction)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareParameter("batteryPack.limitStartSoC", "SoC [s]", 164, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("batteryPack.limitStartV", "Voltage [s]", 165, 1E-15, 0.0,0.0,\
0.0,0,560)
DeclareParameter("batteryPack.limitStartI", "Current [s]", 166, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("batteryPack.limitStartP", "Power [s]", 167, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("batteryPack.limitStartDch", "Discharge power [s]", 168, 0, \
0.0,0.0,0.0,0,560)
DeclareParameter("batteryPack.iTolDch", "Tolerance on discharge current (power limit) [A]",\
 169, 1E-15, 0.0,1E+100,0.0,0,560)
DeclareVariable("batteryPack.summary.ns", "Number of cells connected in series [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.summary.np", "Number of cells connected in parallel [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.summary.gs", "Lumped grouping of cells in series (size of the array in the model only) [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.summary.gp", "Lumped grouping of cells in parallel (size of the array in the model only) [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.summary.ngs", "Number of cells per lumped group in series [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.summary.ngp", "Number of cells per lumped group in parallel [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareAlias2("batteryPack.summary.v", "Voltage accross pack terminals [V]", \
"batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 0)
DeclareVariable("batteryPack.summary.i", "Current into positive pack terminal [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.summary.p_in", "Power into pack terminals (charging > 0) [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.summary.p_out", "Power out of pack terminals (discharging > 0) [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("batteryPack.summary.pack_v", "Internal pack voltage [V]", \
"batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 0)
DeclareVariable("batteryPack.summary.pack_i", "Internal pack current (charging > 0) [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.summary.pack_i_dch", "Internal pack current (discharging > 0) [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.summary.pack_ocv", "Pack open circuit voltage [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("batteryPack.summary.pack_p_in", "Internal pack power (charging > 0) [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.summary.pack_p_out", "Internal pack power (discharging > 0) [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.summary.pack_i_max_dch", "Current at maximum discharge power (steady) [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("batteryPack.summary.pack_p_max_dch", "Maximum (steady) discharge power [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("batteryPack.summary.pack_Q_cap_nom", "Pack nominal charge capacity [C]",\
 "batteryPack.Q_cap_all_nom", 1, 5, 1480, 0)
DeclareVariable("batteryPack.summary.pack_Q_cap_aged", "Pack actual charge capacity [C]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.summary.pack_Q", "Pack charge content [C]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("batteryPack.summary.pack_T", "Pack temperature [K|degC]", \
"batteryPack.thermal.internalMass.T", 1, 1, 15, 0)
DeclareVariable("batteryPack.summary.pack_heat_flow", "Heat flow rate from the core battery (excluding pack heat) [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("batteryPack.summary.core_v[1, 1]", "Core voltage [V]", \
"batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 0)
DeclareVariable("batteryPack.summary.core_i[1, 1]", "Core current [A]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.summary.core_ocv[1, 1]", "Core open circuit voltage [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("batteryPack.summary.core_v_drop[1, 1]", "Core impedance voltage drop [V]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.summary.core_R_max_dch[1, 1]", "Core maximum discharge resistance (steady) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("batteryPack.summary.core_Q[1, 1]", "Core charge content [C]", \
0.0, 0.0,1E+100,0.0,0,512)
DeclareAlias2("batteryPack.summary.core_SoC[1, 1]", "Core state of charge (SoC) [1]",\
 "batteryPack.core.capacity.limitSoC.x", 1, 5, 1597, 0)
DeclareVariable("batteryPack.summary.core_Q_cap_aged[1, 1]", "Core capacity [C]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.summary.core_i_self[1, 1]", "Core self discharge current [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("batteryPack.summary.core_T[1, 1]", "Core temperature [K|degC]", \
"batteryPack.thermal.internalMass.T", 1, 1, 15, 0)
DeclareAlias2("batteryPack.summary.core_heat_flow[1, 1]", "Core heat flow rate [W]",\
 "batteryPack.summary.pack_heat_flow", 1, 5, 1506, 0)
DeclareAlias2("batteryPack.summary.pack_SoC_min", "Pack minimum SoC [1]", \
"batteryPack.core.capacity.limitSoC.x", 1, 5, 1597, 0)
DeclareAlias2("batteryPack.summary.pack_SoC_max", "Pack maximum SoC [1]", \
"batteryPack.core.capacity.limitSoC.x", 1, 5, 1597, 0)
DeclareVariable("batteryPack.summary.pack_SoC", "Pack SoC [1]", 0.0, 0.0,0.0,0.0,\
0,512)
DeclareVariable("batteryPack.summary.pack_SoC_nom", "Pack nominal SoC [1]", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareVariable("batteryPack.geometry.ns", "Number of cells connected in series [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.geometry.np", "Number of cells connected in parallel [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.geometry.gs", "Lumped grouping of cells in series (size of the array in the model only) [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.geometry.gp", "Lumped grouping of cells in parallel (size of the array in the model only) [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.geometry.ngs", "Number of cells per lumped group in series [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.geometry.ngp", "Number of cells per lumped group in parallel [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.geometry.thermal.cell.discretization[1]", \
"Thermal discretization of individual cell [:#(type=Integer)]", 0, 0.0,0.0,0.0,0,517)
DeclareVariable("batteryPack.geometry.thermal.cell.discretization[2]", \
"Thermal discretization of individual cell [:#(type=Integer)]", 0, 0.0,0.0,0.0,0,517)
DeclareVariable("batteryPack.geometry.thermal.cell.discretization[3]", \
"Thermal discretization of individual cell [:#(type=Integer)]", 0, 0.0,0.0,0.0,0,517)
DeclareVariable("batteryPack.core.ns", "Number of cells connected in series [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.np", "Number of cells connected in parallel [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.gs", "Lumped grouping of cells in series (size of the array in the model only) [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.gp", "Lumped grouping of cells in parallel (size of the array in the model only) [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.ngs", "Number of cells per lumped group in series [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.ngp", "Number of cells per lumped group in parallel [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.enable_heatport", "true to enable port for heat losses and external temperature [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("batteryPack.core.T0", "Internal fixed temperature [K|degC]", 170,\
 300, 0.0,1E+100,300.0,0,560)
DeclareVariable("batteryPack.core.initialize_with_OCV", "Initialize state of charge (SoC) based on OCV_start [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("batteryPack.core.SOC_start", "Initial SoC [0..1] [1]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.OCV_start", "Initial OCV [V]", 300.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("batteryPack.core.Q_cap_all_nom", "Nominal battery capacity [C]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.limitActionSoC", "Action when violating SoC limits [:#(type=Electrification.Utilities.Types.FaultAction)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareParameter("batteryPack.core.SoC_max", "Maximum SoC", 171, 1, 0.0,0.0,0.0,\
0,560)
DeclareParameter("batteryPack.core.SoC_min", "Minimum SoC", 172, 0, 0.0,0.0,0.0,\
0,560)
DeclareParameter("batteryPack.core.SoC_tol", "Epsilon tolerance on SoC level", 173,\
 0, 0.0,1E+100,0.0,0,560)
DeclareVariable("batteryPack.core.limitStartSoC", "Start monitoring SoC level at this time [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.limitActionV", "Action when violating voltage limits [:#(type=Electrification.Utilities.Types.FaultAction)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareParameter("batteryPack.core.vCellMax", "Maximum cell voltage [V]", 174, \
1E+60, 0.0,0.0,0.0,0,560)
DeclareParameter("batteryPack.core.vCellMin", "Minimum cell voltage [V]", 175, 0,\
 0.0,0.0,0.0,0,560)
DeclareParameter("batteryPack.core.vTol", "Epsilon tolerance on cell voltage [V]",\
 176, 1E-15, 0.0,1E+100,0.0,0,560)
DeclareVariable("batteryPack.core.limitStartV", "Start monitoring voltage level at this time [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.limitActionI", "Action when violating the current limits [:#(type=Electrification.Utilities.Types.FaultAction)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareParameter("batteryPack.core.iCellMaxDch", "Maximum cell discharging current [A]",\
 177, 1E+60, 0.0,0.0,0.0,0,560)
DeclareParameter("batteryPack.core.iCellMaxCh", "Maximum cell charging current [A]",\
 178, 1E+60, 0.0,0.0,0.0,0,560)
DeclareParameter("batteryPack.core.iTol", "Epsilon tolerance on cell current [A]",\
 179, 0, 0.0,1E+100,0.0,0,560)
DeclareVariable("batteryPack.core.limitStartI", "Start monitoring cell current at this time [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.limitActionP", "Action when violating the power limits [:#(type=Electrification.Utilities.Types.FaultAction)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareParameter("batteryPack.core.pCellMaxDch", "Maximum cell discharging power [W]",\
 180, 1E+60, 0.0,0.0,0.0,0,560)
DeclareParameter("batteryPack.core.pCellMaxCh", "Maximum cell charging power [W]",\
 181, 1E+60, 0.0,0.0,0.0,0,560)
DeclareParameter("batteryPack.core.pTol", "Epsilon tolerance on cell power [W]",\
 182, 0, 0.0,1E+100,0.0,0,560)
DeclareVariable("batteryPack.core.limitStartP", "Start monitoring cell power at this time [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.pin_n.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,521)
DeclareVariable("batteryPack.core.pin_n.i", "Current flowing into the pin [A]", \
0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("batteryPack.core.pin_p.v", "Potential at the pin [V]", \
"batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 4)
DeclareVariable("batteryPack.core.pin_p.i", "Current flowing into the pin [A]", \
0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("batteryPack.core.heatPort.T", "Port temperature [K|degC]", \
"batteryPack.thermal.internalMass.T", 1, 1, 15, 4)
DeclareAlias2("batteryPack.core.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "batteryPack.summary.pack_heat_flow", -1, 5, 1506, 132)
DeclareVariable("batteryPack.core.summary.ns", "Number of cells connected in series [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.summary.np", "Number of cells connected in parallel [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.summary.gs", "Lumped grouping of cells in series (size of the array in the model only) [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.summary.gp", "Lumped grouping of cells in parallel (size of the array in the model only) [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.summary.ngs", "Number of cells per lumped group in series [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.summary.ngp", "Number of cells per lumped group in parallel [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareAlias2("batteryPack.core.summary.v", "Voltage [V]", "batteryPack.core.voltage.limitCellOCV.x", 1,\
 5, 1622, 0)
DeclareVariable("batteryPack.core.summary.i", "Current [A]", 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("batteryPack.core.summary.ocv", "Open circuit voltage [V]", \
"batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 0)
DeclareVariable("batteryPack.core.summary.v_drop", "Impedance voltage drop [V]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("batteryPack.core.summary.R_max_dch", "Maximum discharge resistance (steady) [Ohm]",\
 "batteryPack.summary.core_R_max_dch[1, 1]", 1, 5, 1510, 0)
DeclareAlias2("batteryPack.core.summary.R_max_ch", "Maximum charge resistance (steady) [Ohm]",\
 "batteryPack.summary.core_R_max_dch[1, 1]", 1, 5, 1510, 0)
DeclareVariable("batteryPack.core.summary.i_self", "Self discharge current [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("batteryPack.core.summary.Q", "Instantaneous core charge content [C]",\
 "batteryPack.core.capacity.Q", 1, 1, 14, 0)
DeclareAlias2("batteryPack.core.summary.Q_cap_all_aged", "Combined charge capacity [C]",\
 "batteryPack.summary.core_Q_cap_aged[1, 1]", 1, 5, 1512, 0)
DeclareAlias2("batteryPack.core.summary.SoC", "State of charge (SoC) [0-1] [1]",\
 "batteryPack.core.capacity.limitSoC.x", 1, 5, 1597, 0)
DeclareAlias2("batteryPack.core.summary.cell_v", "Cell voltage [V]", \
"batteryPack.core.limitVoltage.x", 1, 5, 1699, 0)
DeclareVariable("batteryPack.core.summary.cell_i", "Cell current [A]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.summary.cell_ocv", "Cell open circuit voltage [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("batteryPack.core.summary.cell_v_drop", "Cell impedance voltage drop [V]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.summary.cell_i_self", "Cell self discharge current [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.summary.cell_Q", "Cell instantaneous charge content [C]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("batteryPack.core.summary.cell_Q_cap_aged", "Cell charge capacity aged [C]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.summary.cell_R_max_dch", "Maximum cell discharge resistance (steady) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("batteryPack.core.summary.cell_R_max_ch", "Maximum cell charge resistance (steady) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("batteryPack.core.capacity.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0, 0.0,0.0,0.0,0,513)
DeclareAlias2("batteryPack.core.capacity.i", "Current flowing from pin p to pin n [A]",\
 "batteryPack.core.capacity.der(Q)", 1, 6, 14, 0)
DeclareVariable("batteryPack.core.capacity.p.v", "Potential at the pin [V]", 0.0,\
 0.0,0.0,0.0,0,521)
DeclareAlias2("batteryPack.core.capacity.p.i", "Current flowing into the pin [A]",\
 "batteryPack.core.capacity.der(Q)", 1, 6, 14, 132)
DeclareVariable("batteryPack.core.capacity.n.v", "Potential at the pin [V]", 0.0,\
 0.0,0.0,0.0,0,521)
DeclareAlias2("batteryPack.core.capacity.n.i", "Current flowing into the pin [A]",\
 "batteryPack.core.capacity.der(Q)", -1, 6, 14, 132)
DeclareVariable("batteryPack.core.capacity.ns", "Number of cells connected in series [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.capacity.np", "Number of cells connected in parallel [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.capacity.gs", "Lumped grouping of cells in series (size of the array in the model only) [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.capacity.gp", "Lumped grouping of cells in parallel (size of the array in the model only) [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.capacity.ngs", "Number of cells per lumped group in series [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.capacity.ngp", "Number of cells per lumped group in parallel [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.capacity.initialize_charge", "True to initialize based on state of charge or charge content [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("batteryPack.core.capacity.initialize_with_SOC", \
"True to initialize charge as SoC (% of charge capacity) [:#(type=Boolean)]", \
true, 0.0,0.0,0.0,0,515)
DeclareVariable("batteryPack.core.capacity.initialize_with_aging", \
"Initialize charge with aged capacity instead of nominal capacity [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("batteryPack.core.capacity.SOC_start", "Initial SoC [0..1] [1]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.capacity.Q_start", "Initial charge content [C]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.capacity.enable_heatport", "True if heat port is enabled, otherwize the internal temperature is assumed to be contant TO [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("batteryPack.core.capacity.T0", "Internal fixed temperature [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareParameter("batteryPack.core.capacity.Q_cap_cell_nom", "Nominal capacity of a single cell [C|Ah]",\
 183, 360000, 0.0,0.0,0.0,0,560)
DeclareParameter("batteryPack.core.capacity.k_Q_cap_cell_nom", "Scaling factor for cell capacity [1]",\
 184, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("batteryPack.core.capacity.Q_cap_all_nom", "Combined nominal capacity (all cells in the virtual group) [C]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.capacity.limitAction", "Action when violating SoC limits [:#(type=Electrification.Utilities.Types.FaultAction)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("batteryPack.core.capacity.SoC_max", "Maximum SoC", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.capacity.SoC_min", "Minimum SoC", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.capacity.SoC_tol", "Epsilon tolerance on SoC level",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("batteryPack.core.capacity.limitStart", "Start checking SoC level at this time [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.capacity.Q_cap_cell", "Un-aged, instantaneous capacity of a single cell [C]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.capacity.Q_cap_all", "Un-aged, instantaneous combined capacity of all cells (sum of all cells) [C]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("batteryPack.core.capacity.Q_cap_cell_aged", "Aged, instantaneous capacity of a single cell (Q_cap_cell with aging factor) [C]",\
 "batteryPack.core.summary.cell_Q_cap_aged", 1, 5, 1561, 0)
DeclareAlias2("batteryPack.core.capacity.Q_cap_all_aged", "Aged, instantaneous combined capacity of all cells (Q_cap_all with aging factor) [C]",\
 "batteryPack.summary.core_Q_cap_aged[1, 1]", 1, 5, 1512, 0)
DeclareAlias2("batteryPack.core.capacity.SoC", "Instantaneous State of Charge [1]",\
 "batteryPack.core.capacity.limitSoC.x", 1, 5, 1597, 0)
DeclareAlias2("batteryPack.core.capacity.heatPort.T", "Port temperature [K|degC]",\
 "batteryPack.thermal.internalMass.T", 1, 1, 15, 4)
DeclareVariable("batteryPack.core.capacity.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0, 0.0,0.0,0.0,0,777)
DeclareState("batteryPack.core.capacity.Q", "Instantaneous, combined charge content (stored by all cells) [C]",\
 14, 0.0, 0.0,1E+100,0.0,0,544)
DeclareDerivative("batteryPack.core.capacity.der(Q)", "der(Instantaneous, combined charge content (stored by all cells)) [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("batteryPack.core.capacity.C_rate", "Charge/discharge rate, no including aging",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("batteryPack.core.capacity.cellState.SoC", "State of charge [1]", \
"batteryPack.core.capacity.limitSoC.x", 1, 5, 1597, 4)
DeclareVariable("batteryPack.core.capacity.cellState.C_rate", "discharge rate", \
0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("batteryPack.core.capacity.cellState.f_C1", "factor for capacitance in R-C circuit [1]",\
 0.0, 0.0,1E+100,0.0,0,521)
DeclareVariable("batteryPack.core.capacity.cellState.f_R1", "factor for resistance in R-C circuit [1]",\
 0.0, 0.0,1E+100,0.0,0,521)
DeclareVariable("batteryPack.core.capacity.cellState.f_Rser", "factor for series resistance [1]",\
 0.0, 0.0,1E+100,0.0,0,521)
DeclareVariable("batteryPack.core.capacity.cellState.f_capacity", \
"capacity loss factor [1]", 0.0, 0.0,1E+100,0.0,0,521)
DeclareVariable("batteryPack.core.capacity.cellState.f_Rself", "factor for self discharge resistance [1]",\
 0.0, 0.0,1E+100,0.0,0,521)
DeclareAlias2("batteryPack.core.capacity.SoC_set.y", "Value of Real output [1]",\
 "batteryPack.core.capacity.limitSoC.x", 1, 5, 1597, 0)
DeclareVariable("batteryPack.core.capacity.Crate_set.y", "Value of Real output",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.capacity.limitSoC.x", "Monitor limits for variable x [1]",\
 0.0, 0.0,1.0,0.0,0,512)
DeclareVariable("batteryPack.core.capacity.limitSoC.xMax", "Upper limit of x", \
0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.capacity.limitSoC.xMin", "Lower limit of x", \
0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.capacity.limitSoC.action", "Action when violating the condition [:#(type=Electrification.Utilities.Types.FaultAction)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareParameter("batteryPack.core.capacity.limitSoC.use_explicit_checking_time",\
 "Use an explicit checking time (else use simulation start time) [:#(type=Boolean)]",\
 185, false, 0.0,0.0,0.0,0,562)
DeclareParameter("batteryPack.core.capacity.limitSoC.t0", "Initial time to start checking limits [s]",\
 186, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("batteryPack.core.capacity.limitSoC.t_start", "Checking time [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("batteryPack.core.capacity.limitSoC.enable_checking_latch", \
"Wait to start checking until the variable is within limits (else allow checking after t0)) [:#(type=Boolean)]",\
 187, false, 0.0,0.0,0.0,0,562)
DeclareVariable("batteryPack.core.capacity.limitSoC.upper_limit_active", \
"Status flag of upper limit checking [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,658)
DeclareVariable("batteryPack.core.capacity.limitSoC.lower_limit_active", \
"Status flag of lower limit checking [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,658)
DeclareVariable("batteryPack.core.capacity.limitSoC.assert_level", \
"[:#(type=AssertionLevel)]", 1, 1.0,2.0,0.0,0,2565)
DeclareAlias2("batteryPack.core.capacity.noHeatFlow.heat.T", "Port temperature [K|degC]",\
 "batteryPack.thermal.internalMass.T", 1, 1, 15, 1028)
DeclareVariable("batteryPack.core.capacity.noHeatFlow.heat.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareAlias2("batteryPack.core.capacity.f_capacity", "[1]", "batteryPack.core.capacity.cellState.f_capacity", 1,\
 5, 1594, 1024)
DeclareAlias2("batteryPack.core.voltage.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 "batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 0)
DeclareAlias2("batteryPack.core.voltage.i", "Current flowing from pin p to pin n [A]",\
 "batteryPack.core.capacity.der(Q)", 1, 6, 14, 0)
DeclareAlias2("batteryPack.core.voltage.p.v", "Potential at the pin [V]", \
"batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 4)
DeclareAlias2("batteryPack.core.voltage.p.i", "Current flowing into the pin [A]",\
 "batteryPack.core.capacity.der(Q)", 1, 6, 14, 132)
DeclareVariable("batteryPack.core.voltage.n.v", "Potential at the pin [V]", 0.0,\
 0.0,0.0,0.0,0,521)
DeclareAlias2("batteryPack.core.voltage.n.i", "Current flowing into the pin [A]",\
 "batteryPack.core.capacity.der(Q)", -1, 6, 14, 132)
DeclareVariable("batteryPack.core.voltage.ns", "Number of cells connected in series [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.voltage.np", "Number of cells connected in parallel [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.voltage.gs", "Lumped grouping of cells in series (size of the array in the model only) [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.voltage.gp", "Lumped grouping of cells in parallel (size of the array in the model only) [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.voltage.ngs", "Number of cells per lumped group in series [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.voltage.ngp", "Number of cells per lumped group in parallel [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.voltage.enable_heatport", "True if heat port is enabled, otherwize the internal temperature is assumed to be contant TO [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("batteryPack.core.voltage.T0", "Internal fixed temperature [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("batteryPack.core.voltage.initialize_with_OCV", "True to initialize charge (SoC) based on voltage [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("batteryPack.core.voltage.v_start", "Initial voltage (OCV) [V]",\
 300.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.voltage.limitAction", "Action when violating voltage limits [:#(type=Electrification.Utilities.Types.FaultAction)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareParameter("batteryPack.core.voltage.vCellMax", "Maximum cell voltage [V]",\
 188, 1E+60, 0.0,0.0,0.0,0,560)
DeclareParameter("batteryPack.core.voltage.vCellMin", "Minimum cell voltage [V]",\
 189, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("batteryPack.core.voltage.vTol", "Epsilon tolerance on voltage level [V]",\
 190, 0, 0.0,1E+100,0.0,0,560)
DeclareParameter("batteryPack.core.voltage.limitStart", "Start checking voltage level at this time [s]",\
 191, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("batteryPack.core.voltage.k_OCV", "Voltage factor (scale voltage value) [1]",\
 192, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("batteryPack.core.voltage.vCell", "OCV of a single cell [V]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("batteryPack.core.voltage.T", "Temperature [degC]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("batteryPack.core.voltage.heatPort.T", "Port temperature [K|degC]",\
 "batteryPack.thermal.internalMass.T", 1, 1, 15, 4)
DeclareVariable("batteryPack.core.voltage.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("batteryPack.core.voltage.cellState.SoC", "State of charge [1]", \
"batteryPack.core.capacity.limitSoC.x", 1, 5, 1597, 4)
DeclareVariable("batteryPack.core.voltage.cellState.C_rate", "discharge rate", \
0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("batteryPack.core.voltage.cellState.f_C1", "factor for capacitance in R-C circuit [1]",\
 "batteryPack.core.capacity.cellState.f_C1", 1, 5, 1591, 4)
DeclareAlias2("batteryPack.core.voltage.cellState.f_R1", "factor for resistance in R-C circuit [1]",\
 "batteryPack.core.capacity.cellState.f_R1", 1, 5, 1592, 4)
DeclareAlias2("batteryPack.core.voltage.cellState.f_Rser", "factor for series resistance [1]",\
 "batteryPack.core.capacity.cellState.f_Rser", 1, 5, 1593, 4)
DeclareAlias2("batteryPack.core.voltage.cellState.f_capacity", "capacity loss factor [1]",\
 "batteryPack.core.capacity.cellState.f_capacity", 1, 5, 1594, 4)
DeclareAlias2("batteryPack.core.voltage.cellState.f_Rself", "factor for self discharge resistance [1]",\
 "batteryPack.core.capacity.cellState.f_Rself", 1, 5, 1595, 4)
DeclareVariable("batteryPack.core.voltage.limitCellOCV.x", "Monitor limits for variable x [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("batteryPack.core.voltage.limitCellOCV.xMax", "Upper limit of x [V]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.voltage.limitCellOCV.xMin", "Lower limit of x [V]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.voltage.limitCellOCV.action", "Action when violating the condition [:#(type=Electrification.Utilities.Types.FaultAction)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareParameter("batteryPack.core.voltage.limitCellOCV.use_explicit_checking_time",\
 "Use an explicit checking time (else use simulation start time) [:#(type=Boolean)]",\
 193, false, 0.0,0.0,0.0,0,562)
DeclareVariable("batteryPack.core.voltage.limitCellOCV.t0", "Initial time to start checking limits [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.voltage.limitCellOCV.t_start", \
"Checking time [s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("batteryPack.core.voltage.limitCellOCV.enable_checking_latch", \
"Wait to start checking until the variable is within limits (else allow checking after t0)) [:#(type=Boolean)]",\
 194, false, 0.0,0.0,0.0,0,562)
DeclareVariable("batteryPack.core.voltage.limitCellOCV.upper_limit_active", \
"Status flag of upper limit checking [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,658)
DeclareVariable("batteryPack.core.voltage.limitCellOCV.lower_limit_active", \
"Status flag of lower limit checking [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,658)
DeclareVariable("batteryPack.core.voltage.limitCellOCV.assert_level", \
"[:#(type=AssertionLevel)]", 1, 1.0,2.0,0.0,0,2565)
DeclareAlias2("batteryPack.core.voltage.noHeatFlow.heat.T", "Port temperature [K|degC]",\
 "batteryPack.thermal.internalMass.T", 1, 1, 15, 1028)
DeclareVariable("batteryPack.core.voltage.noHeatFlow.heat.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0, \
0.0,0.0,0.0,0,2825)
DeclareAlias2("batteryPack.core.voltage.SoC", "[1]", "batteryPack.core.capacity.limitSoC.x", 1,\
 5, 1597, 1024)
DeclareVariable("batteryPack.core.voltage.vCell_start", "Initial cell voltage [V]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("batteryPack.core.voltage.temperatureSensor.T", "Absolute temperature in degree Celsius as output signal [degC]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("batteryPack.core.voltage.temperatureSensor.port.T", \
"Port temperature [K|degC]", "batteryPack.thermal.internalMass.T", 1, 1, 15, 1028)
DeclareVariable("batteryPack.core.voltage.temperatureSensor.port.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0, \
0.0,0.0,0.0,0,2825)
DeclareParameter("batteryPack.core.voltage.V_cell_max", "Maximum voltage (100 % SoC) [V]",\
 195, 4, 0.0,0.0,0.0,0,560)
DeclareParameter("batteryPack.core.voltage.V_cell_min", "Minimum voltage (0 % SoC) [V]",\
 196, 2, 0.0,0.0,0.0,0,560)
DeclareVariable("batteryPack.core.voltage.V_cell_diff", "[V]", 0.0, 0.0,0.0,0.0,\
0,2561)
DeclareVariable("batteryPack.core.impedance.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("batteryPack.core.impedance.p.v", "Potential at the pin [V]", \
"batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 4)
DeclareVariable("batteryPack.core.impedance.p.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("batteryPack.core.impedance.n.v", "Potential at the pin [V]", \
"batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 4)
DeclareVariable("batteryPack.core.impedance.n.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("batteryPack.core.impedance.ns", "Number of cells connected in series [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.impedance.np", "Number of cells connected in parallel [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.impedance.gs", "Lumped grouping of cells in series (size of the array in the model only) [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.impedance.gp", "Lumped grouping of cells in parallel (size of the array in the model only) [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.impedance.ngs", "Number of cells per lumped group in series [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.impedance.ngp", "Number of cells per lumped group in parallel [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.impedance.enable_heatport", "True if heat port is enabled, otherwize the internal temperature is assumed to be contant TO [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("batteryPack.core.impedance.T0", "Internal fixed temperature if not enable_heatport [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("batteryPack.core.impedance.heatPort.T", "Port temperature [K|degC]",\
 "batteryPack.thermal.internalMass.T", 1, 1, 15, 4)
DeclareVariable("batteryPack.core.impedance.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("batteryPack.core.impedance.cellState.SoC", "State of charge [1]",\
 "batteryPack.core.capacity.limitSoC.x", 1, 5, 1597, 4)
DeclareVariable("batteryPack.core.impedance.cellState.C_rate", "discharge rate",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("batteryPack.core.impedance.cellState.f_C1", "factor for capacitance in R-C circuit [1]",\
 "batteryPack.core.capacity.cellState.f_C1", 1, 5, 1591, 4)
DeclareAlias2("batteryPack.core.impedance.cellState.f_R1", "factor for resistance in R-C circuit [1]",\
 "batteryPack.core.capacity.cellState.f_R1", 1, 5, 1592, 4)
DeclareAlias2("batteryPack.core.impedance.cellState.f_Rser", "factor for series resistance [1]",\
 "batteryPack.core.capacity.cellState.f_Rser", 1, 5, 1593, 4)
DeclareAlias2("batteryPack.core.impedance.cellState.f_capacity", \
"capacity loss factor [1]", "batteryPack.core.capacity.cellState.f_capacity", 1,\
 5, 1594, 4)
DeclareAlias2("batteryPack.core.impedance.cellState.f_Rself", "factor for self discharge resistance [1]",\
 "batteryPack.core.capacity.cellState.f_Rself", 1, 5, 1595, 4)
DeclareVariable("batteryPack.core.impedance.i", "current through the battery [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.impedance.power", "power into the battery impedance [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("batteryPack.core.impedance.R_max_dch.y", "Value of Real output [Ohm]",\
 "batteryPack.summary.core_R_max_dch[1, 1]", 1, 5, 1510, 0)
DeclareAlias2("batteryPack.core.impedance.R_max_ch.y", "Value of Real output [Ohm]",\
 "batteryPack.summary.core_R_max_dch[1, 1]", 1, 5, 1510, 0)
DeclareAlias2("batteryPack.core.impedance.SoC", "[1]", "batteryPack.core.capacity.limitSoC.x", 1,\
 5, 1597, 1024)
DeclareAlias2("batteryPack.core.impedance.f_Rser", "[1]", "batteryPack.core.capacity.cellState.f_Rser", 1,\
 5, 1593, 1024)
DeclareAlias2("batteryPack.core.impedance.f_R1", "[1]", "batteryPack.core.capacity.cellState.f_R1", 1,\
 5, 1592, 1024)
DeclareAlias2("batteryPack.core.impedance.f_C1", "[1]", "batteryPack.core.capacity.cellState.f_C1", 1,\
 5, 1591, 1024)
DeclareVariable("batteryPack.core.impedance.r0.T_ref", "Reference temperature [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("batteryPack.core.impedance.r0.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.impedance.r0.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.impedance.r0.i", "Current flowing from pin p to pin n [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("batteryPack.core.impedance.r0.p.v", "Potential at the pin [V]", \
"batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 4)
DeclareVariable("batteryPack.core.impedance.r0.p.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("batteryPack.core.impedance.r0.n.v", "Potential at the pin [V]", \
"batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 4)
DeclareVariable("batteryPack.core.impedance.r0.n.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("batteryPack.core.impedance.r0.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("batteryPack.core.impedance.r0.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("batteryPack.core.impedance.r0.heatPort.T", "Port temperature [K|degC]",\
 "batteryPack.thermal.internalMass.T", 1, 1, 15, 4)
DeclareVariable("batteryPack.core.impedance.r0.heatPort.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("batteryPack.core.impedance.r0.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("batteryPack.core.impedance.r0.T_heatPort", "Temperature of heatPort [K|degC]",\
 "batteryPack.thermal.internalMass.T", 1, 1, 15, 0)
DeclareAlias2("batteryPack.core.impedance.r0.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 "batteryPack.summary.core_R_max_dch[1, 1]", 1, 5, 1510, 0)
DeclareVariable("batteryPack.core.impedance.r0.R", "[Ohm]", 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("batteryPack.core.impedance.R0", "Series resistance (single cell) at temperature T_ref [Ohm]",\
 197, 0.001, 0.0,0.0,0.0,0,560)
DeclareParameter("batteryPack.core.impedance.k_R", "Resistance factor (scale series resistance)",\
 198, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("batteryPack.core.impedance.T_ref", "Reference temperature [K|degC]",\
 199, 300.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("batteryPack.core.impedance.alpha", "Temperature coefficient of resistance (R_actual = R * (1 + alpha*(T_heatPort - T_ref)) * k_R * ns / np [1/K]",\
 200, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("batteryPack.core.impedance.R_set.k", "Gain value multiplied with input signal [1]",\
 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("batteryPack.core.impedance.R_set.u", "Input signal connector [1]",\
 "batteryPack.core.capacity.cellState.f_Rser", 1, 5, 1593, 0)
DeclareAlias2("batteryPack.core.impedance.R_set.y", "Output signal connector [Ohm]",\
 "batteryPack.core.impedance.r0.R", 1, 5, 1661, 0)
DeclareAlias2("batteryPack.core.selfDischarge.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 "batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 0)
DeclareAlias2("batteryPack.core.selfDischarge.p.v", "Potential at the pin [V]", \
"batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 4)
DeclareVariable("batteryPack.core.selfDischarge.p.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("batteryPack.core.selfDischarge.n.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("batteryPack.core.selfDischarge.n.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("batteryPack.core.selfDischarge.ns", "Number of cells connected in series [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.selfDischarge.np", "Number of cells connected in parallel [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.selfDischarge.gs", "Lumped grouping of cells in series (size of the array in the model only) [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.selfDischarge.gp", "Lumped grouping of cells in parallel (size of the array in the model only) [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.selfDischarge.ngs", "Number of cells per lumped group in series [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.selfDischarge.ngp", "Number of cells per lumped group in parallel [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.selfDischarge.enable_heatport", \
"True if heat port is enabled, otherwize the internal temperature is assumed to be contant TO [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("batteryPack.core.selfDischarge.T0", "Internal fixed temperature [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("batteryPack.core.selfDischarge.i", "Current flowing into pin p [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("batteryPack.core.selfDischarge.heatPort.T", "Port temperature [K|degC]",\
 "batteryPack.thermal.internalMass.T", 1, 1, 15, 4)
DeclareAlias2("batteryPack.core.selfDischarge.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "batteryPack.summary.pack_heat_flow", -1, 5, 1506, 132)
DeclareAlias2("batteryPack.core.selfDischarge.cellState.SoC", "State of charge [1]",\
 "batteryPack.core.capacity.limitSoC.x", 1, 5, 1597, 4)
DeclareVariable("batteryPack.core.selfDischarge.cellState.C_rate", \
"discharge rate", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("batteryPack.core.selfDischarge.cellState.f_C1", "factor for capacitance in R-C circuit [1]",\
 "batteryPack.core.capacity.cellState.f_C1", 1, 5, 1591, 4)
DeclareAlias2("batteryPack.core.selfDischarge.cellState.f_R1", "factor for resistance in R-C circuit [1]",\
 "batteryPack.core.capacity.cellState.f_R1", 1, 5, 1592, 4)
DeclareAlias2("batteryPack.core.selfDischarge.cellState.f_Rser", \
"factor for series resistance [1]", "batteryPack.core.capacity.cellState.f_Rser", 1,\
 5, 1593, 4)
DeclareAlias2("batteryPack.core.selfDischarge.cellState.f_capacity", \
"capacity loss factor [1]", "batteryPack.core.capacity.cellState.f_capacity", 1,\
 5, 1594, 4)
DeclareAlias2("batteryPack.core.selfDischarge.cellState.f_Rself", \
"factor for self discharge resistance [1]", "batteryPack.core.capacity.cellState.f_Rself", 1,\
 5, 1595, 4)
DeclareAlias2("batteryPack.core.selfDischarge.f_Rself", "self discharge aging factor [1]",\
 "batteryPack.core.capacity.cellState.f_Rself", 1, 5, 1595, 1024)
DeclareAlias2("batteryPack.core.selfDischarge.SoC", "State of charge [1]", \
"batteryPack.core.capacity.limitSoC.x", 1, 5, 1597, 1024)
DeclareAlias2("batteryPack.core.selfDischarge.idle.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 "batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 0)
DeclareVariable("batteryPack.core.selfDischarge.idle.i", "Current flowing from pin p to pin n [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("batteryPack.core.selfDischarge.idle.p.v", "Potential at the pin [V]",\
 "batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 4)
DeclareVariable("batteryPack.core.selfDischarge.idle.p.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("batteryPack.core.selfDischarge.idle.n.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("batteryPack.core.selfDischarge.idle.n.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareParameter("batteryPack.core.selfDischarge.fixedHeatFlow.Q_flow", \
"Fixed heat flow rate at port [W]", 201, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("batteryPack.core.selfDischarge.fixedHeatFlow.T_ref", \
"Reference temperature [K|degC]", 202, 293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("batteryPack.core.selfDischarge.fixedHeatFlow.alpha", \
"Temperature coefficient of heat flow rate [1/K]", 203, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("batteryPack.core.selfDischarge.fixedHeatFlow.port.T", \
"Port temperature [K|degC]", "batteryPack.thermal.internalMass.T", 1, 1, 15, 4)
DeclareAlias2("batteryPack.core.selfDischarge.fixedHeatFlow.port.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"batteryPack.summary.pack_heat_flow", -1, 5, 1506, 132)
DeclareVariable("batteryPack.core.aging.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0, 0.0,0.0,0.0,0,513)
DeclareAlias2("batteryPack.core.aging.i", "Current flowing from pin p to pin n [A]",\
 "batteryPack.core.capacity.der(Q)", 1, 6, 14, 0)
DeclareVariable("batteryPack.core.aging.p.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,521)
DeclareAlias2("batteryPack.core.aging.p.i", "Current flowing into the pin [A]", \
"batteryPack.core.capacity.der(Q)", 1, 6, 14, 132)
DeclareVariable("batteryPack.core.aging.n.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,521)
DeclareAlias2("batteryPack.core.aging.n.i", "Current flowing into the pin [A]", \
"batteryPack.core.capacity.der(Q)", -1, 6, 14, 132)
DeclareVariable("batteryPack.core.aging.ns", "Number of cells connected in series [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.aging.np", "Number of cells connected in parallel [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.aging.gs", "Lumped grouping of cells in series (size of the array in the model only) [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.aging.gp", "Lumped grouping of cells in parallel (size of the array in the model only) [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.aging.ngs", "Number of cells per lumped group in series [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.aging.ngp", "Number of cells per lumped group in parallel [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.aging.enable_heatport", "True if heat port is enabled, otherwise the internal temperature is assumed to be contant TO [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("batteryPack.core.aging.T0", "Internal fixed temperature [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareParameter("batteryPack.core.aging.capacity_aging", "True if capacity aging should be used [:#(type=Boolean)]",\
 204, true, 0.0,0.0,0.0,0,562)
DeclareParameter("batteryPack.core.aging.Rser_aging", "True if series resistance aging should be used [:#(type=Boolean)]",\
 205, true, 0.0,0.0,0.0,0,562)
DeclareParameter("batteryPack.core.aging.R1_aging", "True if dynamic resistance aging should be used [:#(type=Boolean)]",\
 206, true, 0.0,0.0,0.0,0,562)
DeclareParameter("batteryPack.core.aging.C1_aging", "True if dynamic capacitance aging should be used [:#(type=Boolean)]",\
 207, true, 0.0,0.0,0.0,0,562)
DeclareParameter("batteryPack.core.aging.Rself_aging", "True if self discharge resistance aging should be used [:#(type=Boolean)]",\
 208, true, 0.0,0.0,0.0,0,562)
DeclareAlias2("batteryPack.core.aging.heatPort.T", "Port temperature [K|degC]", \
"batteryPack.thermal.internalMass.T", 1, 1, 15, 4)
DeclareVariable("batteryPack.core.aging.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("batteryPack.core.aging.cellState.SoC", "State of charge [1]", \
"batteryPack.core.capacity.limitSoC.x", 1, 5, 1597, 4)
DeclareVariable("batteryPack.core.aging.cellState.C_rate", "discharge rate", 0.0,\
 0.0,0.0,0.0,0,521)
DeclareAlias2("batteryPack.core.aging.cellState.f_C1", "factor for capacitance in R-C circuit [1]",\
 "batteryPack.core.capacity.cellState.f_C1", 1, 5, 1591, 4)
DeclareAlias2("batteryPack.core.aging.cellState.f_R1", "factor for resistance in R-C circuit [1]",\
 "batteryPack.core.capacity.cellState.f_R1", 1, 5, 1592, 4)
DeclareAlias2("batteryPack.core.aging.cellState.f_Rser", "factor for series resistance [1]",\
 "batteryPack.core.capacity.cellState.f_Rser", 1, 5, 1593, 4)
DeclareAlias2("batteryPack.core.aging.cellState.f_capacity", "capacity loss factor [1]",\
 "batteryPack.core.capacity.cellState.f_capacity", 1, 5, 1594, 4)
DeclareAlias2("batteryPack.core.aging.cellState.f_Rself", "factor for self discharge resistance [1]",\
 "batteryPack.core.capacity.cellState.f_Rself", 1, 5, 1595, 4)
DeclareAlias2("batteryPack.core.aging.noHeatFlow.heat.T", "Port temperature [K|degC]",\
 "batteryPack.thermal.internalMass.T", 1, 1, 15, 1028)
DeclareVariable("batteryPack.core.aging.noHeatFlow.heat.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0, \
0.0,0.0,0.0,0,2825)
DeclareVariable("batteryPack.core.aging.C_rate", "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("batteryPack.core.aging.calendar.f_capacity", "capacity loss factor [1]",\
 "batteryPack.core.aging.calendar.const.k", 1, 7, 209, 0)
DeclareAlias2("batteryPack.core.aging.calendar.f_Rser", "factor for series resistance [1]",\
 "batteryPack.core.aging.calendar.const.k", 1, 7, 209, 0)
DeclareAlias2("batteryPack.core.aging.calendar.f_R1", "factor for resistance in R-C circuit [1]",\
 "batteryPack.core.aging.calendar.const.k", 1, 7, 209, 0)
DeclareAlias2("batteryPack.core.aging.calendar.f_C1", "factor for capacitance in R-C circuit [1]",\
 "batteryPack.core.aging.calendar.const.k", 1, 7, 209, 0)
DeclareAlias2("batteryPack.core.aging.calendar.f_Rself", "factor for self discharge resistance [1]",\
 "batteryPack.core.aging.calendar.const.k", 1, 7, 209, 0)
DeclareParameter("batteryPack.core.aging.calendar.const.k", "Constant output value [1]",\
 209, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("batteryPack.core.aging.calendar.const.y", "Connector of Real output signal [1]",\
 "batteryPack.core.aging.calendar.const.k", 1, 7, 209, 0)
DeclareAlias2("batteryPack.core.aging.cyclic.f_capacity", "capacity loss factor [1]",\
 "batteryPack.core.aging.cyclic.const.k", 1, 7, 210, 0)
DeclareAlias2("batteryPack.core.aging.cyclic.f_Rser", "factor for series resistance [1]",\
 "batteryPack.core.aging.cyclic.const.k", 1, 7, 210, 0)
DeclareAlias2("batteryPack.core.aging.cyclic.f_R1", "factor for resistance in R-C circuit [1]",\
 "batteryPack.core.aging.cyclic.const.k", 1, 7, 210, 0)
DeclareAlias2("batteryPack.core.aging.cyclic.f_C1", "factor for capacitance in R-C circuit [1]",\
 "batteryPack.core.aging.cyclic.const.k", 1, 7, 210, 0)
DeclareAlias2("batteryPack.core.aging.cyclic.f_Rself", "factor for self discharge resistance [1]",\
 "batteryPack.core.aging.cyclic.const.k", 1, 7, 210, 0)
DeclareAlias2("batteryPack.core.aging.cyclic.T", "temperature [K]", \
"batteryPack.thermal.internalMass.T", 1, 1, 15, 0)
DeclareVariable("batteryPack.core.aging.cyclic.i", "current [A]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("batteryPack.core.aging.cyclic.C_rate", "discharge rate", 0.0, \
0.0,0.0,0.0,0,513)
DeclareParameter("batteryPack.core.aging.cyclic.const.k", "Constant output value [1]",\
 210, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("batteryPack.core.aging.cyclic.const.y", "Connector of Real output signal [1]",\
 "batteryPack.core.aging.cyclic.const.k", 1, 7, 210, 0)
DeclareAlias2("batteryPack.core.aging.capacity_set.y", "Value of Real output [1]",\
 "batteryPack.core.capacity.cellState.f_capacity", 1, 5, 1594, 0)
DeclareAlias2("batteryPack.core.aging.Rser_set.y", "Value of Real output [1]", \
"batteryPack.core.capacity.cellState.f_Rser", 1, 5, 1593, 0)
DeclareAlias2("batteryPack.core.aging.R1_set.y", "Value of Real output [1]", \
"batteryPack.core.capacity.cellState.f_R1", 1, 5, 1592, 0)
DeclareAlias2("batteryPack.core.aging.C1_set.y", "Value of Real output [1]", \
"batteryPack.core.capacity.cellState.f_C1", 1, 5, 1591, 0)
DeclareAlias2("batteryPack.core.aging.Rself_set.y", "Value of Real output [1]", \
"batteryPack.core.capacity.cellState.f_Rself", 1, 5, 1595, 0)
DeclareVariable("batteryPack.core.aging.i_set.y", "Value of Real output [A]", \
0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("batteryPack.core.aging.temperatureSensor.T", "Absolute temperature as output signal [K]",\
 "batteryPack.thermal.internalMass.T", 1, 1, 15, 1024)
DeclareAlias2("batteryPack.core.aging.temperatureSensor.port.T", \
"Port temperature [K|degC]", "batteryPack.thermal.internalMass.T", 1, 1, 15, 1028)
DeclareVariable("batteryPack.core.aging.temperatureSensor.port.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0, \
0.0,0.0,0.0,0,2825)
DeclareVariable("batteryPack.core.limitVoltage.x", "Monitor limits for variable x [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("batteryPack.core.limitVoltage.xMax", "Upper limit of x [V]", \
0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.limitVoltage.xMin", "Lower limit of x [V]", \
0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.limitVoltage.action", "Action when violating the condition [:#(type=Electrification.Utilities.Types.FaultAction)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareParameter("batteryPack.core.limitVoltage.use_explicit_checking_time", \
"Use an explicit checking time (else use simulation start time) [:#(type=Boolean)]",\
 211, false, 0.0,0.0,0.0,0,562)
DeclareVariable("batteryPack.core.limitVoltage.t0", "Initial time to start checking limits [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.limitVoltage.t_start", "Checking time [s]", \
0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("batteryPack.core.limitVoltage.enable_checking_latch", \
"Wait to start checking until the variable is within limits (else allow checking after t0)) [:#(type=Boolean)]",\
 212, false, 0.0,0.0,0.0,0,562)
DeclareVariable("batteryPack.core.limitVoltage.upper_limit_active", \
"Status flag of upper limit checking [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,658)
DeclareVariable("batteryPack.core.limitVoltage.lower_limit_active", \
"Status flag of lower limit checking [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,658)
DeclareVariable("batteryPack.core.limitVoltage.assert_level", "[:#(type=AssertionLevel)]",\
 1, 1.0,2.0,0.0,0,2565)
DeclareVariable("batteryPack.core.sensors.ns", "Number of cells connected in series [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.sensors.np", "Number of cells connected in parallel [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.sensors.gs", "Lumped grouping of cells in series (size of the array in the model only) [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.sensors.gp", "Lumped grouping of cells in parallel (size of the array in the model only) [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.sensors.ngs", "Number of cells per lumped group in series [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.sensors.ngp", "Number of cells per lumped group in parallel [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.core.sensors.enable_heatport", "True if heat port is enabled, otherwize the internal temperature is assumed to be contant TO [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("batteryPack.core.sensors.T0", "Internal fixed temperature [K|degC]",\
 213, 300, 0.0,1E+100,300.0,0,560)
DeclareAlias2("batteryPack.core.sensors.heatPort.T", "Port temperature [K|degC]",\
 "batteryPack.thermal.internalMass.T", 1, 1, 15, 4)
DeclareVariable("batteryPack.core.sensors.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("batteryPack.core.sensors.cellState.SoC", "State of charge [1]", \
"batteryPack.core.capacity.limitSoC.x", 1, 5, 1597, 4)
DeclareVariable("batteryPack.core.sensors.cellState.C_rate", "discharge rate", \
0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("batteryPack.core.sensors.cellState.f_C1", "factor for capacitance in R-C circuit [1]",\
 "batteryPack.core.capacity.cellState.f_C1", 1, 5, 1591, 4)
DeclareAlias2("batteryPack.core.sensors.cellState.f_R1", "factor for resistance in R-C circuit [1]",\
 "batteryPack.core.capacity.cellState.f_R1", 1, 5, 1592, 4)
DeclareAlias2("batteryPack.core.sensors.cellState.f_Rser", "factor for series resistance [1]",\
 "batteryPack.core.capacity.cellState.f_Rser", 1, 5, 1593, 4)
DeclareAlias2("batteryPack.core.sensors.cellState.f_capacity", "capacity loss factor [1]",\
 "batteryPack.core.capacity.cellState.f_capacity", 1, 5, 1594, 4)
DeclareAlias2("batteryPack.core.sensors.cellState.f_Rself", "factor for self discharge resistance [1]",\
 "batteryPack.core.capacity.cellState.f_Rself", 1, 5, 1595, 4)
DeclareAlias2("batteryPack.core.sensors.v_sns", "Core voltage [V]", \
"batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 0)
DeclareAlias2("batteryPack.core.sensors.ocv_sns", "Core open circuit voltage [V]",\
 "batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 0)
DeclareVariable("batteryPack.core.sensors.i_sns", "Core current [A]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareAlias2("batteryPack.core.sensors.R_max_dch_sns", "Maximum discharge resistance (steady) [Ohm]",\
 "batteryPack.summary.core_R_max_dch[1, 1]", 1, 5, 1510, 0)
DeclareVariable("batteryPack.core.sensors.cell_v_sns", "Cell voltage [V]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("batteryPack.core.sensors.cell_ocv_sns", "Cell open circuit voltage [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("batteryPack.core.sensors.cell_i_sns", "Cell current [A]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.sensors.cell_R_max_dch_sns", "Cell maximum discharge resistance (steady) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("batteryPack.core.sensors.SoC_sns", "SoC [1]", "batteryPack.core.capacity.limitSoC.x", 1,\
 5, 1597, 0)
DeclareAlias2("batteryPack.core.sensors.T_sns", "Temperature [K|degC]", \
"batteryPack.thermal.internalMass.T", 1, 1, 15, 0)
DeclareAlias2("batteryPack.core.sensors.exp_core_v.y", "Value of Real output [V]",\
 "batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 0)
DeclareAlias2("batteryPack.core.sensors.exp_core_ocv.y", "Value of Real output [V]",\
 "batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 0)
DeclareVariable("batteryPack.core.sensors.exp_core_i.y", "Value of Real output [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("batteryPack.core.sensors.exp_core_R_max_dch.y", "Value of Real output [Ohm]",\
 "batteryPack.summary.core_R_max_dch[1, 1]", 1, 5, 1510, 0)
DeclareAlias2("batteryPack.core.sensors.exp_cell_v.y", "Value of Real output [V]",\
 "batteryPack.core.sensors.cell_v_sns", 1, 5, 1718, 0)
DeclareAlias2("batteryPack.core.sensors.exp_cell_ocv.y", "Value of Real output [V]",\
 "batteryPack.core.sensors.cell_ocv_sns", 1, 5, 1719, 0)
DeclareVariable("batteryPack.core.sensors.exp_cell_i.y", "Value of Real output [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("batteryPack.core.sensors.exp_cell_R_max_dch.y", "Value of Real output [Ohm]",\
 "batteryPack.core.sensors.cell_R_max_dch_sns", 1, 5, 1721, 0)
DeclareAlias2("batteryPack.core.sensors.exp_SoC.y", "Value of Real output [1]", \
"batteryPack.core.capacity.limitSoC.x", 1, 5, 1597, 0)
DeclareAlias2("batteryPack.core.sensors.exp_T.y", "Value of Real output [K]", \
"batteryPack.thermal.internalMass.T", 1, 1, 15, 0)
DeclareAlias2("batteryPack.core.sensors.temperatureSensor.T", "Absolute temperature as output signal [K]",\
 "batteryPack.thermal.internalMass.T", 1, 1, 15, 0)
DeclareAlias2("batteryPack.core.sensors.temperatureSensor.port.T", \
"Port temperature [K|degC]", "batteryPack.thermal.internalMass.T", 1, 1, 15, 4)
DeclareVariable("batteryPack.core.sensors.temperatureSensor.port.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0, \
0.0,0.0,0.0,0,777)
DeclareVariable("batteryPack.core.limitCurrent.x", "Monitor limits for variable x [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.limitCurrent.xMax", "Upper limit of x [A]", \
0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.limitCurrent.xMin", "Lower limit of x [A]", \
0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.limitCurrent.action", "Action when violating the condition [:#(type=Electrification.Utilities.Types.FaultAction)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareParameter("batteryPack.core.limitCurrent.use_explicit_checking_time", \
"Use an explicit checking time (else use simulation start time) [:#(type=Boolean)]",\
 214, false, 0.0,0.0,0.0,0,562)
DeclareVariable("batteryPack.core.limitCurrent.t0", "Initial time to start checking limits [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.limitCurrent.t_start", "Checking time [s]", \
0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("batteryPack.core.limitCurrent.enable_checking_latch", \
"Wait to start checking until the variable is within limits (else allow checking after t0)) [:#(type=Boolean)]",\
 215, false, 0.0,0.0,0.0,0,562)
DeclareVariable("batteryPack.core.limitCurrent.upper_limit_active", \
"Status flag of upper limit checking [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,658)
DeclareVariable("batteryPack.core.limitCurrent.lower_limit_active", \
"Status flag of lower limit checking [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,658)
DeclareVariable("batteryPack.core.limitCurrent.assert_level", "[:#(type=AssertionLevel)]",\
 1, 1.0,2.0,0.0,0,2565)
DeclareVariable("batteryPack.core.limitPower.x", "Monitor limits for variable x [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.limitPower.xMax", "Upper limit of x [W]", 0.0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.limitPower.xMin", "Lower limit of x [W]", 0.0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.limitPower.action", "Action when violating the condition [:#(type=Electrification.Utilities.Types.FaultAction)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareParameter("batteryPack.core.limitPower.use_explicit_checking_time", \
"Use an explicit checking time (else use simulation start time) [:#(type=Boolean)]",\
 216, false, 0.0,0.0,0.0,0,562)
DeclareVariable("batteryPack.core.limitPower.t0", "Initial time to start checking limits [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.core.limitPower.t_start", "Checking time [s]", 0.0,\
 0.0,0.0,0.0,0,513)
DeclareParameter("batteryPack.core.limitPower.enable_checking_latch", \
"Wait to start checking until the variable is within limits (else allow checking after t0)) [:#(type=Boolean)]",\
 217, false, 0.0,0.0,0.0,0,562)
DeclareVariable("batteryPack.core.limitPower.upper_limit_active", \
"Status flag of upper limit checking [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,658)
DeclareVariable("batteryPack.core.limitPower.lower_limit_active", \
"Status flag of lower limit checking [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,658)
DeclareVariable("batteryPack.core.limitPower.assert_level", "[:#(type=AssertionLevel)]",\
 1, 1.0,2.0,0.0,0,2565)
DeclareVariable("batteryPack.electrical.internal_ground", "Enable internal reference to ground potential [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("batteryPack.electrical.heatPort.T", "Port temperature [K|degC]", \
"batteryPack.thermal.internalMass.T", 1, 1, 15, 4)
DeclareVariable("batteryPack.electrical.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0, 0.0,0.0,0.0,0,777)
DeclareVariable("batteryPack.electrical.ground_internal.p.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("batteryPack.electrical.ground_internal.p.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("batteryPack.electrical.sensors.link_v_sns", "Link voltage [V]", \
"batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 0)
DeclareVariable("batteryPack.electrical.sensors.link_i_sns", "Link current [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("batteryPack.electrical.sensors.core_v_sns", "Core voltage [V]", \
"batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 0)
DeclareVariable("batteryPack.electrical.sensors.core_i_sns", "Core current [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.electrical.sensors.exp_core_i.y", "Value of Real output [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("batteryPack.electrical.sensors.exp_core_v.y", "Value of Real output [V]",\
 "batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 0)
DeclareAlias2("batteryPack.electrical.sensors.exp_link_v.y", "Value of Real output [V]",\
 "batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 0)
DeclareVariable("batteryPack.electrical.sensors.exp_link_i.y", "Value of Real output [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("batteryPack.electrical.sensors.product_core_p.u1", \
"Connector of Real input signal 1 [V]", "batteryPack.core.voltage.limitCellOCV.x", 1,\
 5, 1622, 0)
DeclareVariable("batteryPack.electrical.sensors.product_core_p.u2", \
"Connector of Real input signal 2 [A]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.electrical.sensors.product_core_p.y", \
"Connector of Real output signal [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.electrical.sensors.product_link_p.u1", \
"Connector of Real input signal 1 [A]", 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("batteryPack.electrical.sensors.product_link_p.u2", \
"Connector of Real input signal 2 [V]", "batteryPack.core.voltage.limitCellOCV.x", 1,\
 5, 1622, 0)
DeclareVariable("batteryPack.electrical.sensors.product_link_p.y", \
"Connector of Real output signal [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.electrical.ground.v", "Potential at the pin [V]", \
0.0, 0.0,0.0,0.0,0,2569)
DeclareVariable("batteryPack.electrical.ground.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,2825)
DeclareAlias2("batteryPack.electrical.plug_a.p.v", "Potential at the pin [V]", \
"batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 4)
DeclareVariable("batteryPack.electrical.plug_a.p.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("batteryPack.electrical.plug_a.n.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("batteryPack.electrical.plug_a.n.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("batteryPack.electrical.splitter.plug_a.p.v", "Potential at the pin [V]",\
 "batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 4)
DeclareVariable("batteryPack.electrical.splitter.plug_a.p.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("batteryPack.electrical.splitter.plug_a.n.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("batteryPack.electrical.splitter.plug_a.n.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("batteryPack.electrical.splitter.p.v", "Potential at the pin [V]",\
 "batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 4)
DeclareVariable("batteryPack.electrical.splitter.p.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("batteryPack.electrical.splitter.n.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("batteryPack.electrical.splitter.n.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("batteryPack.electrical.pin_n.v", "Potential at the pin [V]", \
0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("batteryPack.electrical.pin_n.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("batteryPack.electrical.pin_p.v", "Potential at the pin [V]", \
"batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 4)
DeclareVariable("batteryPack.electrical.pin_p.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("batteryPack.electrical.summary.v_link", "Voltage across external link pins [V]",\
 "batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 0)
DeclareAlias2("batteryPack.electrical.summary.v_core", "Voltage across core pins [V]",\
 "batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 0)
DeclareVariable("batteryPack.electrical.summary.i_link", "Current into positive link pin [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.electrical.summary.i_core", "Current into positive core pin [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.electrical.summary.p_link", "Electric power into component [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.electrical.summary.p_core", "Electric power into core component [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("batteryPack.electrical.noHeatFlow.heat.T", "Port temperature [K|degC]",\
 "batteryPack.thermal.internalMass.T", 1, 1, 15, 4)
DeclareVariable("batteryPack.electrical.noHeatFlow.heat.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("batteryPack.thermal.ns", "Number of cells connected in series [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.thermal.np", "Number of cells connected in parallel [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.thermal.gs", "Lumped grouping of cells in series (size of the array in the model only) [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.thermal.gp", "Lumped grouping of cells in parallel (size of the array in the model only) [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.thermal.ngs", "Number of cells per lumped group in series [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.thermal.ngp", "Number of cells per lumped group in parallel [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.thermal.fixed_temperature", "true to set a fixed temperature [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("batteryPack.thermal.state_when_fixed", "true to retain the temperature as a state variable even when it is set to fixed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("batteryPack.thermal.T0", "Initial or fixed temperature [K|degC]",\
 218, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("batteryPack.thermal.enable_external", "enable external thermal connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("batteryPack.thermal.T_start_fixed", "Enforce T0 as the start value if not fixed_temperature or if fixed_temperature and state_when_fixed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("batteryPack.thermal.tempElectrical.T", "Port temperature [K|degC]",\
 "batteryPack.thermal.internalMass.T", 1, 1, 15, 4)
DeclareVariable("batteryPack.thermal.tempElectrical.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("batteryPack.thermal.tempCore[1, 1].T", "Port temperature [K|degC]",\
 "batteryPack.thermal.internalMass.T", 1, 1, 15, 4)
DeclareAlias2("batteryPack.thermal.tempCore[1, 1].Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "batteryPack.summary.pack_heat_flow", 1, 5, 1506, 132)
DeclareVariable("batteryPack.thermal.summary.ns", "Number of cells connected in series [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.thermal.summary.np", "Number of cells connected in parallel [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.thermal.summary.gs", "Lumped grouping of cells in series (size of the array in the model only) [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.thermal.summary.gp", "Lumped grouping of cells in parallel (size of the array in the model only) [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.thermal.summary.ngs", "Number of cells per lumped group in series [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.thermal.summary.ngp", "Number of cells per lumped group in parallel [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareAlias2("batteryPack.thermal.summary.T_pack", "Pack temperature [K|degC]",\
 "batteryPack.thermal.internalMass.T", 1, 1, 15, 0)
DeclareAlias2("batteryPack.thermal.summary.T_cell_max", "Max cell temperature [K|degC]",\
 "batteryPack.thermal.internalMass.T", 1, 1, 15, 0)
DeclareAlias2("batteryPack.thermal.summary.Q_flow", "Total heat flow from the pack itself [W]",\
 "batteryPack.summary.pack_heat_flow", 1, 5, 1506, 0)
DeclareAlias2("batteryPack.thermal.summary.Q_flow_cells_total", "Total heat from all the cells [W]",\
 "batteryPack.summary.pack_heat_flow", 1, 5, 1506, 0)
DeclareParameter("batteryPack.thermal.geometry.cell.discretization[1]", \
"Thermal discretization of individual cell [:#(type=Integer)]", 219, 1, 0.0,0.0,\
0.0,0,564)
DeclareParameter("batteryPack.thermal.geometry.cell.discretization[2]", \
"Thermal discretization of individual cell [:#(type=Integer)]", 220, 1, 0.0,0.0,\
0.0,0,564)
DeclareParameter("batteryPack.thermal.geometry.cell.discretization[3]", \
"Thermal discretization of individual cell [:#(type=Integer)]", 221, 1, 0.0,0.0,\
0.0,0,564)
DeclareVariable("batteryPack.thermal.enable_external_cells", "enable cell nodes in external thermal connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("batteryPack.thermal.splitCoreHeat.na[1]", "Inlet (portA) dimensions [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,517)
DeclareVariable("batteryPack.thermal.splitCoreHeat.na[2]", "Inlet (portA) dimensions [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,517)
DeclareVariable("batteryPack.thermal.splitCoreHeat.nb[1]", "Outlet (portB) dimensions [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,517)
DeclareVariable("batteryPack.thermal.splitCoreHeat.nb[2]", "Outlet (portB) dimensions [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,517)
DeclareAlias2("batteryPack.thermal.splitCoreHeat.portA[1, 1].T", \
"Port temperature [K|degC]", "batteryPack.thermal.internalMass.T", 1, 1, 15, 4)
DeclareAlias2("batteryPack.thermal.splitCoreHeat.portA[1, 1].Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"batteryPack.summary.pack_heat_flow", 1, 5, 1506, 132)
DeclareAlias2("batteryPack.thermal.splitCoreHeat.portB[1, 1].T", \
"Port temperature [K|degC]", "batteryPack.thermal.internalMass.T", 1, 1, 15, 4)
DeclareAlias2("batteryPack.thermal.splitCoreHeat.portB[1, 1].Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"batteryPack.summary.pack_heat_flow", -1, 5, 1506, 132)
DeclareVariable("batteryPack.thermal.splitCoreHeat.n_1", "[:#(type=Integer)]", 1,\
 0.0,0.0,0.0,0,517)
DeclareVariable("batteryPack.thermal.splitCoreHeat.n_2", "[:#(type=Integer)]", 1,\
 0.0,0.0,0.0,0,517)
DeclareVariable("batteryPack.thermal.splitCoreHeat.v_1[1]", "[:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,517)
DeclareVariable("batteryPack.thermal.splitCoreHeat.v_2[1]", "[:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,517)
DeclareParameter("batteryPack.thermal.adaptAmbient.batteryGeometry.ns", \
"Number of cells connected in series [:#(type=Integer)]", 222, 1, 1.0,1E+100,0.0,\
0,564)
DeclareParameter("batteryPack.thermal.adaptAmbient.batteryGeometry.np", \
"Number of cells connected in parallel [:#(type=Integer)]", 223, 1, 1.0,1E+100,\
0.0,0,564)
DeclareParameter("batteryPack.thermal.adaptAmbient.batteryGeometry.gs", \
"Lumped grouping of cells in series (size of the array in the model only) [:#(type=Integer)]",\
 224, 1, 1.0,1E+100,0.0,0,564)
DeclareParameter("batteryPack.thermal.adaptAmbient.batteryGeometry.gp", \
"Lumped grouping of cells in parallel (size of the array in the model only) [:#(type=Integer)]",\
 225, 1, 1.0,1E+100,0.0,0,564)
DeclareVariable("batteryPack.thermal.adaptAmbient.batteryGeometry.ngs", \
"Number of cells per lumped group in series [:#(type=Integer)]", 1, 1.0,1E+100,\
0.0,0,517)
DeclareVariable("batteryPack.thermal.adaptAmbient.batteryGeometry.ngp", \
"Number of cells per lumped group in parallel [:#(type=Integer)]", 1, 1.0,1E+100,\
0.0,0,517)
DeclareParameter("batteryPack.thermal.adaptAmbient.batteryGeometry.thermal.cell.discretization[1]",\
 "Thermal discretization of individual cell [:#(type=Integer)]", 226, 1, \
0.0,0.0,0.0,0,564)
DeclareParameter("batteryPack.thermal.adaptAmbient.batteryGeometry.thermal.cell.discretization[2]",\
 "Thermal discretization of individual cell [:#(type=Integer)]", 227, 1, \
0.0,0.0,0.0,0,564)
DeclareParameter("batteryPack.thermal.adaptAmbient.batteryGeometry.thermal.cell.discretization[3]",\
 "Thermal discretization of individual cell [:#(type=Integer)]", 228, 1, \
0.0,0.0,0.0,0,564)
DeclareVariable("batteryPack.thermal.adaptAmbient.heat.T", "Port temperature [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,520)
DeclareVariable("batteryPack.thermal.adaptAmbient.heat.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareParameter("batteryPack.thermal.adaptCellsLumped.batteryGeometry.ns", \
"Number of cells connected in series [:#(type=Integer)]", 229, 1, 1.0,1E+100,0.0,\
0,564)
DeclareParameter("batteryPack.thermal.adaptCellsLumped.batteryGeometry.np", \
"Number of cells connected in parallel [:#(type=Integer)]", 230, 1, 1.0,1E+100,\
0.0,0,564)
DeclareParameter("batteryPack.thermal.adaptCellsLumped.batteryGeometry.gs", \
"Lumped grouping of cells in series (size of the array in the model only) [:#(type=Integer)]",\
 231, 1, 1.0,1E+100,0.0,0,564)
DeclareParameter("batteryPack.thermal.adaptCellsLumped.batteryGeometry.gp", \
"Lumped grouping of cells in parallel (size of the array in the model only) [:#(type=Integer)]",\
 232, 1, 1.0,1E+100,0.0,0,564)
DeclareVariable("batteryPack.thermal.adaptCellsLumped.batteryGeometry.ngs", \
"Number of cells per lumped group in series [:#(type=Integer)]", 1, 1.0,1E+100,\
0.0,0,517)
DeclareVariable("batteryPack.thermal.adaptCellsLumped.batteryGeometry.ngp", \
"Number of cells per lumped group in parallel [:#(type=Integer)]", 1, 1.0,1E+100,\
0.0,0,517)
DeclareParameter("batteryPack.thermal.adaptCellsLumped.batteryGeometry.thermal.cell.discretization[1]",\
 "Thermal discretization of individual cell [:#(type=Integer)]", 233, 1, \
0.0,0.0,0.0,0,564)
DeclareParameter("batteryPack.thermal.adaptCellsLumped.batteryGeometry.thermal.cell.discretization[2]",\
 "Thermal discretization of individual cell [:#(type=Integer)]", 234, 1, \
0.0,0.0,0.0,0,564)
DeclareParameter("batteryPack.thermal.adaptCellsLumped.batteryGeometry.thermal.cell.discretization[3]",\
 "Thermal discretization of individual cell [:#(type=Integer)]", 235, 1, \
0.0,0.0,0.0,0,564)
DeclareAlias2("batteryPack.thermal.adaptCellsLumped.heat.T", "Port temperature [K|degC]",\
 "batteryPack.thermal.internalMass.T", 1, 1, 15, 4)
DeclareVariable("batteryPack.thermal.adaptCellsLumped.heat.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("batteryPack.thermal.sensors.ns", "Number of cells connected in series [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.thermal.sensors.np", "Number of cells connected in parallel [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.thermal.sensors.gs", "Lumped grouping of cells in series (size of the array in the model only) [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.thermal.sensors.gp", "Lumped grouping of cells in parallel (size of the array in the model only) [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.thermal.sensors.ngs", "Number of cells per lumped group in series [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.thermal.sensors.ngp", "Number of cells per lumped group in parallel [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.thermal.sensors.batteryGeometry.ns", \
"Number of cells connected in series [:#(type=Integer)]", 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.thermal.sensors.batteryGeometry.np", \
"Number of cells connected in parallel [:#(type=Integer)]", 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.thermal.sensors.batteryGeometry.gs", \
"Lumped grouping of cells in series (size of the array in the model only) [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.thermal.sensors.batteryGeometry.gp", \
"Lumped grouping of cells in parallel (size of the array in the model only) [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.thermal.sensors.batteryGeometry.ngs", \
"Number of cells per lumped group in series [:#(type=Integer)]", 1, 1.0,1E+100,\
0.0,0,517)
DeclareVariable("batteryPack.thermal.sensors.batteryGeometry.ngp", \
"Number of cells per lumped group in parallel [:#(type=Integer)]", 1, 1.0,1E+100,\
0.0,0,517)
DeclareVariable("batteryPack.thermal.sensors.batteryGeometry.thermal.cell.discretization[1]",\
 "Thermal discretization of individual cell [:#(type=Integer)]", 0, 0.0,0.0,0.0,\
0,517)
DeclareVariable("batteryPack.thermal.sensors.batteryGeometry.thermal.cell.discretization[2]",\
 "Thermal discretization of individual cell [:#(type=Integer)]", 0, 0.0,0.0,0.0,\
0,517)
DeclareVariable("batteryPack.thermal.sensors.batteryGeometry.thermal.cell.discretization[3]",\
 "Thermal discretization of individual cell [:#(type=Integer)]", 0, 0.0,0.0,0.0,\
0,517)
DeclareAlias2("batteryPack.thermal.sensors.T_sns", "Battery temperature [K|degC]",\
 "batteryPack.thermal.internalMass.T", 1, 1, 15, 0)
DeclareAlias2("batteryPack.thermal.sensors.T_core_sns[1, 1]", "Core temperatures [gs,gp] [K|degC]",\
 "batteryPack.thermal.internalMass.T", 1, 1, 15, 0)
DeclareAlias2("batteryPack.thermal.sensors.exp_T.y", "Value of Real output [K]",\
 "batteryPack.thermal.internalMass.T", 1, 1, 15, 0)
DeclareAlias2("batteryPack.thermal.sensors.exp_core_T[1, 1].y", "Value of Real output",\
 "batteryPack.thermal.internalMass.T", 1, 1, 15, 0)
DeclareParameter("batteryPack.thermal.G_ambient", "Thermal conductance from ambient to pack [W/K]",\
 236, 10, 0.0,0.0,0.0,0,560)
DeclareParameter("batteryPack.thermal.per_cell_capacity", "Specify the heat capacity per cell (else specify the total heat capacity) [:#(type=Boolean)]",\
 237, false, 0.0,0.0,0.0,0,562)
DeclareParameter("batteryPack.thermal.C", "Total heat capacity of thermal mass (= cp*m) if not per_cell_capacity [J/K]",\
 238, 100000.0, 0.0,0.0,0.0,0,560)
DeclareParameter("batteryPack.thermal.C_cell", "Per cell heat capacity of thermal mass (= cp*m) [J/K]",\
 239, 500, 0.0,0.0,0.0,0,560)
DeclareVariable("batteryPack.thermal.C_total", "Heat capacity of thermal mass (= cp*m) if not per_cell_capacity [J/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.thermal.ambientTransfer.Q_flow", "Heat flow rate from port_a -> port_b [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.thermal.ambientTransfer.dT", "port_a.T - port_b.T [K,]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("batteryPack.thermal.ambientTransfer.port_a.T", "Port temperature [K|degC]",\
 "batteryPack.thermal.internalMass.T", 1, 1, 15, 4)
DeclareVariable("batteryPack.thermal.ambientTransfer.port_a.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareAlias2("batteryPack.thermal.ambientTransfer.port_b.T", "Port temperature [K|degC]",\
 "batteryPack.thermal.adaptAmbient.heat.T", 1, 5, 1802, 4)
DeclareVariable("batteryPack.thermal.ambientTransfer.port_b.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("batteryPack.thermal.ambientTransfer.G", "Constant thermal conductance of material [W/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.thermal.internalMass.C", "Heat capacity of element (= cp*m) [J/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.thermal.internalMass.fixed_temperature", \
"true to fix temperature to T0 [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,515)
DeclareVariable("batteryPack.thermal.internalMass.state_when_fixed", \
"true to retain the temperature as a state variable even when it is set to fixed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("batteryPack.thermal.internalMass.T0", "Fixed or initial temperature [K|degC]",\
 300, 0.0,10000.0,300.0,0,513)
DeclareVariable("batteryPack.thermal.internalMass.T_start_fixed", \
"Enforce T0 as the start value if not fixed_temperature or if fixed_temperature and state_when_fixed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareState("batteryPack.thermal.internalMass.T", "Temperature of element [K|degC]",\
 15, 0.0, 0.0,1E+100,300.0,0,544)
DeclareDerivative("batteryPack.thermal.internalMass.der(T)", "der(Temperature of element) [K/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("batteryPack.thermal.internalMass.port.T", "Port temperature [K|degC]",\
 "batteryPack.thermal.internalMass.T", 1, 1, 15, 4)
DeclareAlias2("batteryPack.thermal.internalMass.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "batteryPack.summary.pack_heat_flow", 1, 5, 1506, 132)
DeclareVariable("batteryPack.controller.id", "Unique identifier of this controller [:#(type=Integer)]",\
 0, 0.0,0.0,0.0,0,517)
DeclareVariable("batteryPack.controller.ns", "Number of cells connected in series [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.controller.np", "Number of cells connected in parallel [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.controller.gs", "Lumped grouping of cells in series (size of the array in the model only) [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.controller.gp", "Lumped grouping of cells in parallel (size of the array in the model only) [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.controller.ngs", "Number of cells per lumped group in series [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.controller.ngp", "Number of cells per lumped group in parallel [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("batteryPack.controller.enable_core", "Enable core domain connector [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("batteryPack.controller.enable_electrical", "Enable electrical domain connector [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("batteryPack.controller.enable_thermal", "Enable thermal domain connector [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("batteryPack.limitDischarge.x", "Monitor limits for variable x [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.limitDischarge.xMax", "Upper limit of x [A]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("batteryPack.limitDischarge.xMin", "Lower limit of x", -1E+60, \
0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.limitDischarge.action", "Action when violating the condition [:#(type=Electrification.Utilities.Types.FaultAction)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareParameter("batteryPack.limitDischarge.use_explicit_checking_time", \
"Use an explicit checking time (else use simulation start time) [:#(type=Boolean)]",\
 240, false, 0.0,0.0,0.0,0,562)
DeclareVariable("batteryPack.limitDischarge.t0", "Initial time to start checking limits [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.limitDischarge.t_start", "Checking time [s]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareParameter("batteryPack.limitDischarge.enable_checking_latch", \
"Wait to start checking until the variable is within limits (else allow checking after t0)) [:#(type=Boolean)]",\
 241, false, 0.0,0.0,0.0,0,562)
DeclareVariable("batteryPack.limitDischarge.upper_limit_active", \
"Status flag of upper limit checking [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,658)
DeclareVariable("batteryPack.limitDischarge.lower_limit_active", \
"Status flag of lower limit checking [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,658)
DeclareVariable("batteryPack.limitDischarge.assert_level", "[:#(type=AssertionLevel)]",\
 1, 1.0,2.0,0.0,0,2565)
DeclareVariable("ground.p.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("ground.p.i", "Current flowing into the pin [A]", "dcdc1.dc_n1.i", -1,\
 5, 1005, 132)
DeclareVariable("simpleLine2.inductor.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("simpleLine2.inductor.i", "Current flowing from pin p to pin n [A]",\
 16, 0, 0.0,0.0,0.0,0,560)
DeclareDerivative("simpleLine2.inductor.der(i)", "der(Current flowing from pin p to pin n) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("simpleLine2.inductor.p.v", "Potential at the pin [V]", \
"simpleLine2.p1.v", 1, 5, 1856, 4)
DeclareAlias2("simpleLine2.inductor.p.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", 1, 1, 16, 132)
DeclareVariable("simpleLine2.inductor.n.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,520)
DeclareAlias2("simpleLine2.inductor.n.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", -1, 1, 16, 132)
DeclareVariable("simpleLine2.inductor.L", "Inductance [H]", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("simpleLine2.p1.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,\
0,520)
DeclareAlias2("simpleLine2.p1.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", 1, 1, 16, 132)
DeclareParameter("simpleLine2.L", "Line inductance [H]", 242, 1E-06, 0.0,0.0,0.0,\
0,560)
DeclareVariable("simpleLine2.resistor.R", "Resistance at temperature T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareParameter("simpleLine2.resistor.T_ref", "Reference temperature [K|degC]",\
 243, 300.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("simpleLine2.resistor.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 244, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("simpleLine2.resistor.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("simpleLine2.resistor.i", "Current flowing from pin p to pin n [A]",\
 "simpleLine2.inductor.i", 1, 1, 16, 0)
DeclareAlias2("simpleLine2.resistor.p.v", "Potential at the pin [V]", \
"simpleLine2.inductor.n.v", 1, 5, 1854, 4)
DeclareAlias2("simpleLine2.resistor.p.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", 1, 1, 16, 132)
DeclareAlias2("simpleLine2.resistor.n.v", "Potential at the pin [V]", \
"simpleLine2.n1.v", 1, 5, 1863, 4)
DeclareAlias2("simpleLine2.resistor.n.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", -1, 1, 16, 132)
DeclareVariable("simpleLine2.resistor.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("simpleLine2.resistor.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("simpleLine2.resistor.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("simpleLine2.resistor.T_heatPort", "Temperature of heatPort [K|degC]",\
 "simpleLine2.resistor.T", 1, 5, 1860, 0)
DeclareVariable("simpleLine2.resistor.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("simpleLine2.n1.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,\
0,520)
DeclareAlias2("simpleLine2.n1.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", -1, 1, 16, 132)
DeclareParameter("simpleLine2.R", "Line resistance at temperature T_ref [Ohm]", 245,\
 0, 0.0,0.0,0.0,0,560)
DeclareVariable("simpleLine3.inductor.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("simpleLine3.inductor.i", "Current flowing from pin p to pin n [A]",\
 "simpleLine2.inductor.i", -1, 1, 16, 0)
DeclareAlias2("simpleLine3.inductor.der(i)", "der(Current flowing from pin p to pin n) [A/s]",\
 "simpleLine2.inductor.der(i)", -1, 6, 16, 0)
DeclareAlias2("simpleLine3.inductor.p.v", "Potential at the pin [V]", \
"simpleLine3.p1.v", 1, 5, 1867, 4)
DeclareAlias2("simpleLine3.inductor.p.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", -1, 1, 16, 132)
DeclareVariable("simpleLine3.inductor.n.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,520)
DeclareAlias2("simpleLine3.inductor.n.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", 1, 1, 16, 132)
DeclareVariable("simpleLine3.inductor.L", "Inductance [H]", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("simpleLine3.p1.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,\
0,520)
DeclareAlias2("simpleLine3.p1.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", -1, 1, 16, 132)
DeclareParameter("simpleLine3.L", "Line inductance [H]", 246, 1E-06, 0.0,0.0,0.0,\
0,560)
DeclareVariable("simpleLine3.resistor.R", "Resistance at temperature T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareParameter("simpleLine3.resistor.T_ref", "Reference temperature [K|degC]",\
 247, 300.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("simpleLine3.resistor.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 248, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("simpleLine3.resistor.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("simpleLine3.resistor.i", "Current flowing from pin p to pin n [A]",\
 "simpleLine2.inductor.i", -1, 1, 16, 0)
DeclareAlias2("simpleLine3.resistor.p.v", "Potential at the pin [V]", \
"simpleLine3.inductor.n.v", 1, 5, 1865, 4)
DeclareAlias2("simpleLine3.resistor.p.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", -1, 1, 16, 132)
DeclareAlias2("simpleLine3.resistor.n.v", "Potential at the pin [V]", \
"simpleLine3.n1.v", 1, 5, 1874, 4)
DeclareAlias2("simpleLine3.resistor.n.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", 1, 1, 16, 132)
DeclareVariable("simpleLine3.resistor.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("simpleLine3.resistor.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("simpleLine3.resistor.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("simpleLine3.resistor.T_heatPort", "Temperature of heatPort [K|degC]",\
 "simpleLine3.resistor.T", 1, 5, 1871, 0)
DeclareVariable("simpleLine3.resistor.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("simpleLine3.n1.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,\
0,520)
DeclareAlias2("simpleLine3.n1.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", 1, 1, 16, 132)
DeclareParameter("simpleLine3.R", "Line resistance at temperature T_ref [Ohm]", 249,\
 0, 0.0,0.0,0.0,0,560)
DeclareVariable("circuitBreaker4.switch.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("circuitBreaker4.switch.i", "Current flowing from pin p to pin n [A]",\
 "simpleLine2.inductor.i", 1, 1, 16, 0)
DeclareAlias2("circuitBreaker4.switch.p.v", "Potential at the pin [V]", \
"dcdc1.dc_p2.v", 1, 5, 1008, 4)
DeclareAlias2("circuitBreaker4.switch.p.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", 1, 1, 16, 132)
DeclareAlias2("circuitBreaker4.switch.n.v", "Potential at the pin [V]", \
"simpleLine2.p1.v", 1, 5, 1856, 4)
DeclareAlias2("circuitBreaker4.switch.n.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", -1, 1, 16, 132)
DeclareParameter("circuitBreaker4.switch.Ron", "Closed switch resistance [Ohm]",\
 250, 1E-05, 0.0,1E+100,0.0,0,560)
DeclareParameter("circuitBreaker4.switch.Goff", "Opened switch conductance [S]",\
 251, 1E-05, 0.0,1E+100,0.0,0,560)
DeclareVariable("circuitBreaker4.switch.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("circuitBreaker4.switch.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("circuitBreaker4.switch.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("circuitBreaker4.switch.T_heatPort", "Temperature of heatPort [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("circuitBreaker4.switch.off", "Indicates off-state [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2690)
DeclareVariable("circuitBreaker4.switch.s", "Auxiliary variable [1]", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("circuitBreaker4.switch.unitVoltage", "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("circuitBreaker4.switch.unitCurrent", "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("circuitBreaker4.switch.control", "true => switch open, false => p--n connected [:#(type=Boolean)]",\
 "circuitBreaker4.switch.off", 1, 5, 1880, 65)
DeclareParameter("circuitBreaker4.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 252, false, 0.0,0.0,0.0,0,562)
DeclareParameter("circuitBreaker4.Goff", "Opened switch conductance [S]", 253, \
1E-05, 0.0,0.0,0.0,0,560)
DeclareParameter("circuitBreaker4.Ron", "Closed switch resistance [Ohm]", 254, \
1E-05, 0.0,0.0,0.0,0,560)
DeclareAlias2("circuitBreaker4.cB_Trigger.currentSensor.p.v", "Potential at the pin [V]",\
 "dcdc1.dc_p2.v", 1, 5, 1008, 4)
DeclareAlias2("circuitBreaker4.cB_Trigger.currentSensor.p.i", "Current flowing into the pin [A]",\
 "simpleLine2.inductor.i", 1, 1, 16, 132)
DeclareAlias2("circuitBreaker4.cB_Trigger.currentSensor.n.v", "Potential at the pin [V]",\
 "dcdc1.dc_p2.v", 1, 5, 1008, 4)
DeclareAlias2("circuitBreaker4.cB_Trigger.currentSensor.n.i", "Current flowing into the pin [A]",\
 "simpleLine2.inductor.i", -1, 1, 16, 132)
DeclareAlias2("circuitBreaker4.cB_Trigger.currentSensor.i", "Current in the branch from p to n as output signal [A]",\
 "simpleLine2.inductor.i", 1, 1, 16, 0)
DeclareAlias2("circuitBreaker4.cB_Trigger.greater.u1", "Connector of first Real input signal [A]",\
 "simpleLine2.inductor.i", 1, 1, 16, 0)
DeclareAlias2("circuitBreaker4.cB_Trigger.greater.u2", "Connector of second Real input signal",\
 "circuitBreaker4.cB_Trigger.const.k", 1, 5, 1884, 0)
DeclareAlias2("circuitBreaker4.cB_Trigger.greater.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "circuitBreaker4.switch.off", 1, 5, 1880, 65)
DeclareAlias2("circuitBreaker4.cB_Trigger.p1.v", "Potential at the pin [V]", \
"dcdc1.dc_p2.v", 1, 5, 1008, 4)
DeclareAlias2("circuitBreaker4.cB_Trigger.p1.i", "Current flowing into the pin [A]",\
 "simpleLine2.inductor.i", 1, 1, 16, 132)
DeclareAlias2("circuitBreaker4.cB_Trigger.n1.v", "Potential at the pin [V]", \
"dcdc1.dc_p2.v", 1, 5, 1008, 4)
DeclareAlias2("circuitBreaker4.cB_Trigger.n1.i", "Current flowing into the pin [A]",\
 "simpleLine2.inductor.i", -1, 1, 16, 132)
DeclareVariable("circuitBreaker4.cB_Trigger.const.k", "Constant output value", 1,\
 0.0,0.0,0.0,0,513)
DeclareAlias2("circuitBreaker4.cB_Trigger.const.y", "Connector of Real output signal",\
 "circuitBreaker4.cB_Trigger.const.k", 1, 5, 1884, 0)
DeclareVariable("circuitBreaker4.cB_Trigger.k", "Reference overcurrent value", \
0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("circuitBreaker4.cB_Trigger.y1", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "circuitBreaker4.switch.off", 1, 5, 1880, 65)
DeclareAlias2("circuitBreaker4.p1.v", "Potential at the pin [V]", \
"dcdc1.dc_p2.v", 1, 5, 1008, 4)
DeclareAlias2("circuitBreaker4.p1.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", 1, 1, 16, 132)
DeclareAlias2("circuitBreaker4.n1.v", "Potential at the pin [V]", \
"simpleLine2.p1.v", 1, 5, 1856, 4)
DeclareAlias2("circuitBreaker4.n1.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", -1, 1, 16, 132)
DeclareParameter("circuitBreaker4.k", "Reference overcurrent value", 255, 200000,\
 0.0,0.0,0.0,0,560)
DeclareAlias2("circuitBreaker5.switch.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 "simpleLine3.p1.v", -1, 5, 1867, 0)
DeclareAlias2("circuitBreaker5.switch.i", "Current flowing from pin p to pin n [A]",\
 "simpleLine2.inductor.i", -1, 1, 16, 0)
DeclareVariable("circuitBreaker5.switch.p.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,521)
DeclareAlias2("circuitBreaker5.switch.p.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", -1, 1, 16, 132)
DeclareAlias2("circuitBreaker5.switch.n.v", "Potential at the pin [V]", \
"simpleLine3.p1.v", 1, 5, 1867, 4)
DeclareAlias2("circuitBreaker5.switch.n.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", 1, 1, 16, 132)
DeclareParameter("circuitBreaker5.switch.Ron", "Closed switch resistance [Ohm]",\
 256, 1E-05, 0.0,1E+100,0.0,0,560)
DeclareParameter("circuitBreaker5.switch.Goff", "Opened switch conductance [S]",\
 257, 1E-05, 0.0,1E+100,0.0,0,560)
DeclareVariable("circuitBreaker5.switch.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("circuitBreaker5.switch.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("circuitBreaker5.switch.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("circuitBreaker5.switch.T_heatPort", "Temperature of heatPort [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("circuitBreaker5.switch.off", "Indicates off-state [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2690)
DeclareVariable("circuitBreaker5.switch.s", "Auxiliary variable [1]", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("circuitBreaker5.switch.unitVoltage", "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("circuitBreaker5.switch.unitCurrent", "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("circuitBreaker5.switch.control", "true => switch open, false => p--n connected [:#(type=Boolean)]",\
 "circuitBreaker5.switch.off", 1, 5, 1891, 65)
DeclareParameter("circuitBreaker5.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 258, false, 0.0,0.0,0.0,0,562)
DeclareParameter("circuitBreaker5.Goff", "Opened switch conductance [S]", 259, \
1E-05, 0.0,0.0,0.0,0,560)
DeclareParameter("circuitBreaker5.Ron", "Closed switch resistance [Ohm]", 260, \
1E-05, 0.0,0.0,0.0,0,560)
DeclareVariable("circuitBreaker5.cB_Trigger.currentSensor.p.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("circuitBreaker5.cB_Trigger.currentSensor.p.i", "Current flowing into the pin [A]",\
 "simpleLine2.inductor.i", -1, 1, 16, 132)
DeclareVariable("circuitBreaker5.cB_Trigger.currentSensor.n.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("circuitBreaker5.cB_Trigger.currentSensor.n.i", "Current flowing into the pin [A]",\
 "simpleLine2.inductor.i", 1, 1, 16, 132)
DeclareAlias2("circuitBreaker5.cB_Trigger.currentSensor.i", "Current in the branch from p to n as output signal [A]",\
 "simpleLine2.inductor.i", -1, 1, 16, 0)
DeclareAlias2("circuitBreaker5.cB_Trigger.greater.u1", "Connector of first Real input signal [A]",\
 "simpleLine2.inductor.i", -1, 1, 16, 0)
DeclareAlias2("circuitBreaker5.cB_Trigger.greater.u2", "Connector of second Real input signal",\
 "circuitBreaker5.cB_Trigger.const.k", 1, 5, 1899, 0)
DeclareAlias2("circuitBreaker5.cB_Trigger.greater.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "circuitBreaker5.switch.off", 1, 5, 1891, 65)
DeclareVariable("circuitBreaker5.cB_Trigger.p1.v", "Potential at the pin [V]", \
0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("circuitBreaker5.cB_Trigger.p1.i", "Current flowing into the pin [A]",\
 "simpleLine2.inductor.i", -1, 1, 16, 132)
DeclareVariable("circuitBreaker5.cB_Trigger.n1.v", "Potential at the pin [V]", \
0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("circuitBreaker5.cB_Trigger.n1.i", "Current flowing into the pin [A]",\
 "simpleLine2.inductor.i", 1, 1, 16, 132)
DeclareVariable("circuitBreaker5.cB_Trigger.const.k", "Constant output value", 1,\
 0.0,0.0,0.0,0,513)
DeclareAlias2("circuitBreaker5.cB_Trigger.const.y", "Connector of Real output signal",\
 "circuitBreaker5.cB_Trigger.const.k", 1, 5, 1899, 0)
DeclareVariable("circuitBreaker5.cB_Trigger.k", "Reference overcurrent value", \
0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("circuitBreaker5.cB_Trigger.y1", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "circuitBreaker5.switch.off", 1, 5, 1891, 65)
DeclareVariable("circuitBreaker5.p1.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,521)
DeclareAlias2("circuitBreaker5.p1.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", -1, 1, 16, 132)
DeclareAlias2("circuitBreaker5.n1.v", "Potential at the pin [V]", \
"simpleLine3.p1.v", 1, 5, 1867, 4)
DeclareAlias2("circuitBreaker5.n1.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", 1, 1, 16, 132)
DeclareParameter("circuitBreaker5.k", "Reference overcurrent value", 261, 200000,\
 0.0,0.0,0.0,0,560)
DeclareVariable("circuitBreaker6.switch.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("circuitBreaker6.switch.i", "Current flowing from pin p to pin n [A]",\
 "simpleLine2.inductor.i", 1, 1, 16, 0)
DeclareAlias2("circuitBreaker6.switch.p.v", "Potential at the pin [V]", \
"simpleLine2.n1.v", 1, 5, 1863, 4)
DeclareAlias2("circuitBreaker6.switch.p.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", 1, 1, 16, 132)
DeclareAlias2("circuitBreaker6.switch.n.v", "Potential at the pin [V]", \
"inverter1.dc_p.v", 1, 5, 755, 4)
DeclareAlias2("circuitBreaker6.switch.n.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", -1, 1, 16, 132)
DeclareParameter("circuitBreaker6.switch.Ron", "Closed switch resistance [Ohm]",\
 262, 1E-05, 0.0,1E+100,0.0,0,560)
DeclareParameter("circuitBreaker6.switch.Goff", "Opened switch conductance [S]",\
 263, 1E-05, 0.0,1E+100,0.0,0,560)
DeclareVariable("circuitBreaker6.switch.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("circuitBreaker6.switch.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("circuitBreaker6.switch.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("circuitBreaker6.switch.T_heatPort", "Temperature of heatPort [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("circuitBreaker6.switch.off", "Indicates off-state [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2690)
DeclareVariable("circuitBreaker6.switch.s", "Auxiliary variable [1]", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("circuitBreaker6.switch.unitVoltage", "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("circuitBreaker6.switch.unitCurrent", "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("circuitBreaker6.switch.control", "true => switch open, false => p--n connected [:#(type=Boolean)]",\
 "circuitBreaker6.switch.off", 1, 5, 1907, 65)
DeclareParameter("circuitBreaker6.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 264, false, 0.0,0.0,0.0,0,562)
DeclareParameter("circuitBreaker6.Goff", "Opened switch conductance [S]", 265, \
1E-05, 0.0,0.0,0.0,0,560)
DeclareParameter("circuitBreaker6.Ron", "Closed switch resistance [Ohm]", 266, \
1E-05, 0.0,0.0,0.0,0,560)
DeclareAlias2("circuitBreaker6.cB_Trigger.currentSensor.p.v", "Potential at the pin [V]",\
 "simpleLine2.n1.v", 1, 5, 1863, 4)
DeclareAlias2("circuitBreaker6.cB_Trigger.currentSensor.p.i", "Current flowing into the pin [A]",\
 "simpleLine2.inductor.i", 1, 1, 16, 132)
DeclareAlias2("circuitBreaker6.cB_Trigger.currentSensor.n.v", "Potential at the pin [V]",\
 "simpleLine2.n1.v", 1, 5, 1863, 4)
DeclareAlias2("circuitBreaker6.cB_Trigger.currentSensor.n.i", "Current flowing into the pin [A]",\
 "simpleLine2.inductor.i", -1, 1, 16, 132)
DeclareAlias2("circuitBreaker6.cB_Trigger.currentSensor.i", "Current in the branch from p to n as output signal [A]",\
 "simpleLine2.inductor.i", 1, 1, 16, 0)
DeclareAlias2("circuitBreaker6.cB_Trigger.greater.u1", "Connector of first Real input signal [A]",\
 "simpleLine2.inductor.i", 1, 1, 16, 0)
DeclareAlias2("circuitBreaker6.cB_Trigger.greater.u2", "Connector of second Real input signal",\
 "circuitBreaker6.cB_Trigger.const.k", 1, 5, 1911, 0)
DeclareAlias2("circuitBreaker6.cB_Trigger.greater.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "circuitBreaker6.switch.off", 1, 5, 1907, 65)
DeclareAlias2("circuitBreaker6.cB_Trigger.p1.v", "Potential at the pin [V]", \
"simpleLine2.n1.v", 1, 5, 1863, 4)
DeclareAlias2("circuitBreaker6.cB_Trigger.p1.i", "Current flowing into the pin [A]",\
 "simpleLine2.inductor.i", 1, 1, 16, 132)
DeclareAlias2("circuitBreaker6.cB_Trigger.n1.v", "Potential at the pin [V]", \
"simpleLine2.n1.v", 1, 5, 1863, 4)
DeclareAlias2("circuitBreaker6.cB_Trigger.n1.i", "Current flowing into the pin [A]",\
 "simpleLine2.inductor.i", -1, 1, 16, 132)
DeclareVariable("circuitBreaker6.cB_Trigger.const.k", "Constant output value", 1,\
 0.0,0.0,0.0,0,513)
DeclareAlias2("circuitBreaker6.cB_Trigger.const.y", "Connector of Real output signal",\
 "circuitBreaker6.cB_Trigger.const.k", 1, 5, 1911, 0)
DeclareVariable("circuitBreaker6.cB_Trigger.k", "Reference overcurrent value", \
0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("circuitBreaker6.cB_Trigger.y1", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "circuitBreaker6.switch.off", 1, 5, 1907, 65)
DeclareAlias2("circuitBreaker6.p1.v", "Potential at the pin [V]", \
"simpleLine2.n1.v", 1, 5, 1863, 4)
DeclareAlias2("circuitBreaker6.p1.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", 1, 1, 16, 132)
DeclareAlias2("circuitBreaker6.n1.v", "Potential at the pin [V]", \
"inverter1.dc_p.v", 1, 5, 755, 4)
DeclareAlias2("circuitBreaker6.n1.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", -1, 1, 16, 132)
DeclareParameter("circuitBreaker6.k", "Reference overcurrent value", 267, 200000,\
 0.0,0.0,0.0,0,560)
DeclareVariable("circuitBreaker7.switch.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("circuitBreaker7.switch.i", "Current flowing from pin p to pin n [A]",\
 "simpleLine2.inductor.i", -1, 1, 16, 0)
DeclareAlias2("circuitBreaker7.switch.p.v", "Potential at the pin [V]", \
"simpleLine3.n1.v", 1, 5, 1874, 4)
DeclareAlias2("circuitBreaker7.switch.p.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", -1, 1, 16, 132)
DeclareAlias2("circuitBreaker7.switch.n.v", "Potential at the pin [V]", \
"inverter1.dc_n.v", 1, 5, 756, 4)
DeclareAlias2("circuitBreaker7.switch.n.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", 1, 1, 16, 132)
DeclareParameter("circuitBreaker7.switch.Ron", "Closed switch resistance [Ohm]",\
 268, 1E-05, 0.0,1E+100,0.0,0,560)
DeclareParameter("circuitBreaker7.switch.Goff", "Opened switch conductance [S]",\
 269, 1E-05, 0.0,1E+100,0.0,0,560)
DeclareVariable("circuitBreaker7.switch.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("circuitBreaker7.switch.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("circuitBreaker7.switch.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("circuitBreaker7.switch.T_heatPort", "Temperature of heatPort [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("circuitBreaker7.switch.off", "Indicates off-state [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2690)
DeclareVariable("circuitBreaker7.switch.s", "Auxiliary variable [1]", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("circuitBreaker7.switch.unitVoltage", "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("circuitBreaker7.switch.unitCurrent", "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("circuitBreaker7.switch.control", "true => switch open, false => p--n connected [:#(type=Boolean)]",\
 "circuitBreaker7.switch.off", 1, 5, 1918, 65)
DeclareParameter("circuitBreaker7.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 270, false, 0.0,0.0,0.0,0,562)
DeclareParameter("circuitBreaker7.Goff", "Opened switch conductance [S]", 271, \
1E-05, 0.0,0.0,0.0,0,560)
DeclareParameter("circuitBreaker7.Ron", "Closed switch resistance [Ohm]", 272, \
1E-05, 0.0,0.0,0.0,0,560)
DeclareAlias2("circuitBreaker7.cB_Trigger.currentSensor.p.v", "Potential at the pin [V]",\
 "simpleLine3.n1.v", 1, 5, 1874, 4)
DeclareAlias2("circuitBreaker7.cB_Trigger.currentSensor.p.i", "Current flowing into the pin [A]",\
 "simpleLine2.inductor.i", -1, 1, 16, 132)
DeclareAlias2("circuitBreaker7.cB_Trigger.currentSensor.n.v", "Potential at the pin [V]",\
 "simpleLine3.n1.v", 1, 5, 1874, 4)
DeclareAlias2("circuitBreaker7.cB_Trigger.currentSensor.n.i", "Current flowing into the pin [A]",\
 "simpleLine2.inductor.i", 1, 1, 16, 132)
DeclareAlias2("circuitBreaker7.cB_Trigger.currentSensor.i", "Current in the branch from p to n as output signal [A]",\
 "simpleLine2.inductor.i", -1, 1, 16, 0)
DeclareAlias2("circuitBreaker7.cB_Trigger.greater.u1", "Connector of first Real input signal [A]",\
 "simpleLine2.inductor.i", -1, 1, 16, 0)
DeclareAlias2("circuitBreaker7.cB_Trigger.greater.u2", "Connector of second Real input signal",\
 "circuitBreaker7.cB_Trigger.const.k", 1, 5, 1922, 0)
DeclareAlias2("circuitBreaker7.cB_Trigger.greater.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "circuitBreaker7.switch.off", 1, 5, 1918, 65)
DeclareAlias2("circuitBreaker7.cB_Trigger.p1.v", "Potential at the pin [V]", \
"simpleLine3.n1.v", 1, 5, 1874, 4)
DeclareAlias2("circuitBreaker7.cB_Trigger.p1.i", "Current flowing into the pin [A]",\
 "simpleLine2.inductor.i", -1, 1, 16, 132)
DeclareAlias2("circuitBreaker7.cB_Trigger.n1.v", "Potential at the pin [V]", \
"simpleLine3.n1.v", 1, 5, 1874, 4)
DeclareAlias2("circuitBreaker7.cB_Trigger.n1.i", "Current flowing into the pin [A]",\
 "simpleLine2.inductor.i", 1, 1, 16, 132)
DeclareVariable("circuitBreaker7.cB_Trigger.const.k", "Constant output value", 1,\
 0.0,0.0,0.0,0,513)
DeclareAlias2("circuitBreaker7.cB_Trigger.const.y", "Connector of Real output signal",\
 "circuitBreaker7.cB_Trigger.const.k", 1, 5, 1922, 0)
DeclareVariable("circuitBreaker7.cB_Trigger.k", "Reference overcurrent value", \
0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("circuitBreaker7.cB_Trigger.y1", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "circuitBreaker7.switch.off", 1, 5, 1918, 65)
DeclareAlias2("circuitBreaker7.p1.v", "Potential at the pin [V]", \
"simpleLine3.n1.v", 1, 5, 1874, 4)
DeclareAlias2("circuitBreaker7.p1.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", -1, 1, 16, 132)
DeclareAlias2("circuitBreaker7.n1.v", "Potential at the pin [V]", \
"inverter1.dc_n.v", 1, 5, 756, 4)
DeclareAlias2("circuitBreaker7.n1.i", "Current flowing into the pin [A]", \
"simpleLine2.inductor.i", 1, 1, 16, 132)
DeclareParameter("circuitBreaker7.k", "Reference overcurrent value", 273, 200000,\
 0.0,0.0,0.0,0,560)
DeclareVariable("simplifiedFuelCell1.constantVoltage.V", "Value of constant voltage [V]",\
 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("simplifiedFuelCell1.constantVoltage.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 "simplifiedFuelCell1.constantVoltage.V", 1, 5, 1924, 0)
DeclareAlias2("simplifiedFuelCell1.constantVoltage.i", "Current flowing from pin p to pin n [A]",\
 "simplifiedFuelCell1.pin_p.i", 1, 5, 1933, 0)
DeclareAlias2("simplifiedFuelCell1.constantVoltage.p.v", "Potential at the pin [V]",\
 "simplifiedFuelCell1.constantVoltage.V", 1, 5, 1924, 4)
DeclareAlias2("simplifiedFuelCell1.constantVoltage.p.i", "Current flowing into the pin [A]",\
 "simplifiedFuelCell1.pin_p.i", 1, 5, 1933, 132)
DeclareVariable("simplifiedFuelCell1.constantVoltage.n.v", "Potential at the pin [V]",\
 0, 0.0,0.0,0.0,0,521)
DeclareAlias2("simplifiedFuelCell1.constantVoltage.n.i", "Current flowing into the pin [A]",\
 "simplifiedFuelCell1.pin_p.i", -1, 5, 1933, 132)
DeclareVariable("simplifiedFuelCell1.resistor.R", "Resistance at temperature T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareParameter("simplifiedFuelCell1.resistor.T_ref", "Reference temperature [K|degC]",\
 274, 300.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("simplifiedFuelCell1.resistor.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 275, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("simplifiedFuelCell1.resistor.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("simplifiedFuelCell1.resistor.i", "Current flowing from pin p to pin n [A]",\
 "simplifiedFuelCell1.pin_p.i", -1, 5, 1933, 0)
DeclareAlias2("simplifiedFuelCell1.resistor.p.v", "Potential at the pin [V]", \
"simplifiedFuelCell1.constantVoltage.V", 1, 5, 1924, 4)
DeclareAlias2("simplifiedFuelCell1.resistor.p.i", "Current flowing into the pin [A]",\
 "simplifiedFuelCell1.pin_p.i", -1, 5, 1933, 132)
DeclareAlias2("simplifiedFuelCell1.resistor.n.v", "Potential at the pin [V]", \
"simplifiedFuelCell1.pin_p.v", 1, 5, 1932, 4)
DeclareAlias2("simplifiedFuelCell1.resistor.n.i", "Current flowing into the pin [A]",\
 "simplifiedFuelCell1.pin_p.i", 1, 5, 1933, 132)
DeclareVariable("simplifiedFuelCell1.resistor.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("simplifiedFuelCell1.resistor.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("simplifiedFuelCell1.resistor.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("simplifiedFuelCell1.resistor.T_heatPort", "Temperature of heatPort [K|degC]",\
 "simplifiedFuelCell1.resistor.T", 1, 5, 1929, 0)
DeclareVariable("simplifiedFuelCell1.resistor.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("simplifiedFuelCell1.pin_p.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,520)
DeclareVariable("simplifiedFuelCell1.pin_p.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareParameter("simplifiedFuelCell1.R", "Impedance [Ohm]", 276, 0, 0.0,0.0,0.0,\
0,560)
DeclareParameter("simplifiedFuelCell1.L", "Impedance [H]", 277, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("simplifiedFuelCell1.V", "Fuel cell voltage [V]", 278, 1000, \
0.0,0.0,0.0,0,560)
DeclareVariable("simplifiedFuelCell1.constantVoltage1.V", "Value of constant voltage [V]",\
 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("simplifiedFuelCell1.constantVoltage1.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 "simplifiedFuelCell1.constantVoltage1.V", 1, 5, 1934, 0)
DeclareAlias2("simplifiedFuelCell1.constantVoltage1.i", "Current flowing from pin p to pin n [A]",\
 "simplifiedFuelCell1.pin_p1.i", -1, 5, 1945, 0)
DeclareVariable("simplifiedFuelCell1.constantVoltage1.p.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("simplifiedFuelCell1.constantVoltage1.p.i", "Current flowing into the pin [A]",\
 "simplifiedFuelCell1.pin_p1.i", -1, 5, 1945, 132)
DeclareAlias2("simplifiedFuelCell1.constantVoltage1.n.v", "Potential at the pin [V]",\
 "simplifiedFuelCell1.constantVoltage1.V", -1, 5, 1934, 4)
DeclareAlias2("simplifiedFuelCell1.constantVoltage1.n.i", "Current flowing into the pin [A]",\
 "simplifiedFuelCell1.pin_p1.i", 1, 5, 1945, 132)
DeclareVariable("simplifiedFuelCell1.ground.p.v", "Potential at the pin [V]", \
0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("simplifiedFuelCell1.ground.p.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("simplifiedFuelCell1.resistor1.R", "Resistance at temperature T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareParameter("simplifiedFuelCell1.resistor1.T_ref", "Reference temperature [K|degC]",\
 279, 300.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("simplifiedFuelCell1.resistor1.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 280, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("simplifiedFuelCell1.resistor1.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("simplifiedFuelCell1.resistor1.i", "Current flowing from pin p to pin n [A]",\
 "simplifiedFuelCell1.pin_p1.i", -1, 5, 1945, 0)
DeclareAlias2("simplifiedFuelCell1.resistor1.p.v", "Potential at the pin [V]", \
"simplifiedFuelCell1.constantVoltage1.V", -1, 5, 1934, 4)
DeclareAlias2("simplifiedFuelCell1.resistor1.p.i", "Current flowing into the pin [A]",\
 "simplifiedFuelCell1.pin_p1.i", -1, 5, 1945, 132)
DeclareAlias2("simplifiedFuelCell1.resistor1.n.v", "Potential at the pin [V]", \
"simplifiedFuelCell1.pin_p1.v", 1, 5, 1944, 4)
DeclareAlias2("simplifiedFuelCell1.resistor1.n.i", "Current flowing into the pin [A]",\
 "simplifiedFuelCell1.pin_p1.i", 1, 5, 1945, 132)
DeclareVariable("simplifiedFuelCell1.resistor1.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("simplifiedFuelCell1.resistor1.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("simplifiedFuelCell1.resistor1.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("simplifiedFuelCell1.resistor1.T_heatPort", "Temperature of heatPort [K|degC]",\
 "simplifiedFuelCell1.resistor1.T", 1, 5, 1941, 0)
DeclareVariable("simplifiedFuelCell1.resistor1.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("simplifiedFuelCell1.pin_p1.v", "Potential at the pin [V]", 0.0,\
 0.0,0.0,0.0,0,520)
DeclareVariable("simplifiedFuelCell1.pin_p1.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("inverter3.useConstantEnable", "true = disabled boolean input, use constantEnable [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("inverter3.constantEnable", "Constant enabling of firing signals [:#(type=Boolean)]",\
 281, true, 0.0,0.0,0.0,0,562)
DeclareVariable("inverter3.m", "Number of phases [:#(type=Integer)]", 3, 3.0,\
1E+100,0.0,0,517)
DeclareAlias2("inverter3.andCondition_p[1].u1", "Connector of first Boolean input signal [:#(type=Boolean)]",\
 "inverter3.fire_p[1]", 1, 5, 1948, 65)
DeclareAlias2("inverter3.andCondition_p[1].u2", "Connector of second Boolean input signal [:#(type=Boolean)]",\
 "inverter3.enableLogic.enableConstantSource.k", 1, 5, 1954, 65)
DeclareAlias2("inverter3.andCondition_p[1].y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter3.transistor_p.fire[1]", 1, 5, 2003, 65)
DeclareAlias2("inverter3.andCondition_p[2].u1", "Connector of first Boolean input signal [:#(type=Boolean)]",\
 "inverter3.fire_p[2]", 1, 5, 1949, 65)
DeclareAlias2("inverter3.andCondition_p[2].u2", "Connector of second Boolean input signal [:#(type=Boolean)]",\
 "inverter3.enableLogic.enableConstantSource.k", 1, 5, 1954, 65)
DeclareAlias2("inverter3.andCondition_p[2].y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter3.transistor_p.fire[2]", 1, 5, 2004, 65)
DeclareAlias2("inverter3.andCondition_p[3].u1", "Connector of first Boolean input signal [:#(type=Boolean)]",\
 "inverter3.fire_p[3]", 1, 5, 1950, 65)
DeclareAlias2("inverter3.andCondition_p[3].u2", "Connector of second Boolean input signal [:#(type=Boolean)]",\
 "inverter3.enableLogic.enableConstantSource.k", 1, 5, 1954, 65)
DeclareAlias2("inverter3.andCondition_p[3].y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter3.transistor_p.fire[3]", 1, 5, 2005, 65)
DeclareVariable("inverter3.fire_p[1]", "Firing signals of positive potential transistors [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,642)
DeclareVariable("inverter3.fire_p[2]", "Firing signals of positive potential transistors [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,642)
DeclareVariable("inverter3.fire_p[3]", "Firing signals of positive potential transistors [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,642)
DeclareVariable("inverter3.enableLogic.useConstantEnable", "true = disabled boolean input, use constantEnable [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("inverter3.enableLogic.constantEnable", "Constant enabling of firing signals [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("inverter3.enableLogic.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("inverter3.enableLogic.enableConstantSource.k", "Constant output value [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("inverter3.enableLogic.enableConstantSource.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter3.enableLogic.enableConstantSource.k", 1, 5, 1954, 65)
DeclareVariable("inverter3.enableLogic.booleanReplicator.nout", "Number of outputs [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareAlias2("inverter3.enableLogic.booleanReplicator.u", "Connector of Boolean input signal [:#(type=Boolean)]",\
 "inverter3.enableLogic.enableConstantSource.k", 1, 5, 1954, 65)
DeclareAlias2("inverter3.enableLogic.booleanReplicator.y[1]", "Connector of Boolean output signals [:#(type=Boolean)]",\
 "inverter3.enableLogic.enableConstantSource.k", 1, 5, 1954, 65)
DeclareAlias2("inverter3.enableLogic.booleanReplicator.y[2]", "Connector of Boolean output signals [:#(type=Boolean)]",\
 "inverter3.enableLogic.enableConstantSource.k", 1, 5, 1954, 65)
DeclareAlias2("inverter3.enableLogic.booleanReplicator.y[3]", "Connector of Boolean output signals [:#(type=Boolean)]",\
 "inverter3.enableLogic.enableConstantSource.k", 1, 5, 1954, 65)
DeclareAlias2("inverter3.enableLogic.internalEnable[1]", "m replicated enable signals [:#(type=Boolean)]",\
 "inverter3.enableLogic.enableConstantSource.k", 1, 5, 1954, 65)
DeclareAlias2("inverter3.enableLogic.internalEnable[2]", "m replicated enable signals [:#(type=Boolean)]",\
 "inverter3.enableLogic.enableConstantSource.k", 1, 5, 1954, 65)
DeclareAlias2("inverter3.enableLogic.internalEnable[3]", "m replicated enable signals [:#(type=Boolean)]",\
 "inverter3.enableLogic.enableConstantSource.k", 1, 5, 1954, 65)
DeclareAlias2("inverter3.andCondition_n[1].u1", "Connector of first Boolean input signal [:#(type=Boolean)]",\
 "inverter3.fire_n[1]", 1, 5, 1956, 65)
DeclareAlias2("inverter3.andCondition_n[1].u2", "Connector of second Boolean input signal [:#(type=Boolean)]",\
 "inverter3.enableLogic.enableConstantSource.k", 1, 5, 1954, 65)
DeclareAlias2("inverter3.andCondition_n[1].y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter3.transistor_n.fire[1]", 1, 5, 2117, 65)
DeclareAlias2("inverter3.andCondition_n[2].u1", "Connector of first Boolean input signal [:#(type=Boolean)]",\
 "inverter3.fire_n[2]", 1, 5, 1957, 65)
DeclareAlias2("inverter3.andCondition_n[2].u2", "Connector of second Boolean input signal [:#(type=Boolean)]",\
 "inverter3.enableLogic.enableConstantSource.k", 1, 5, 1954, 65)
DeclareAlias2("inverter3.andCondition_n[2].y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter3.transistor_n.fire[2]", 1, 5, 2118, 65)
DeclareAlias2("inverter3.andCondition_n[3].u1", "Connector of first Boolean input signal [:#(type=Boolean)]",\
 "inverter3.fire_n[3]", 1, 5, 1958, 65)
DeclareAlias2("inverter3.andCondition_n[3].u2", "Connector of second Boolean input signal [:#(type=Boolean)]",\
 "inverter3.enableLogic.enableConstantSource.k", 1, 5, 1954, 65)
DeclareAlias2("inverter3.andCondition_n[3].y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter3.transistor_n.fire[3]", 1, 5, 2119, 65)
DeclareVariable("inverter3.fire_n[1]", "Firing signals of negative potential transistors [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,642)
DeclareVariable("inverter3.fire_n[2]", "Firing signals of negative potential transistors [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,642)
DeclareVariable("inverter3.fire_n[3]", "Firing signals of negative potential transistors [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,642)
DeclareParameter("inverter3.RonTransistor", "Transistor closed resistance [Ohm]",\
 282, 1E-05, 0.0,0.0,0.0,0,560)
DeclareParameter("inverter3.GoffTransistor", "Transistor opened conductance [S]",\
 283, 1E-05, 0.0,0.0,0.0,0,560)
DeclareParameter("inverter3.VkneeTransistor", "Transistor threshold voltage [V]",\
 284, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("inverter3.RonDiode", "Diode closed resistance [Ohm]", 285, \
1E-05, 0.0,0.0,0.0,0,560)
DeclareParameter("inverter3.GoffDiode", "Diode opened conductance [S]", 286, \
1E-05, 0.0,0.0,0.0,0,560)
DeclareParameter("inverter3.VkneeDiode", "Diode threshold voltage [V]", 287, 0, \
0.0,0.0,0.0,0,560)
DeclareVariable("inverter3.dc_p.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,\
0,520)
DeclareVariable("inverter3.dc_p.i", "Current flowing into the pin [A]", 0.0, \
0.0,0.0,0.0,0,776)
DeclareVariable("inverter3.dc_n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,\
0,520)
DeclareVariable("inverter3.dc_n.i", "Current flowing into the pin [A]", 0.0, \
0.0,0.0,0.0,0,776)
DeclareVariable("inverter3.vDC", "DC voltage [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter3.iDC", "DC current [A]", "inverter3.dc_p.i", 1, 5, 1960,\
 0)
DeclareVariable("inverter3.powerDC", "DC power [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter3.ac.m", "Number of phases [:#(type=Integer)]", 3, 1.0,\
1E+100,0.0,0,525)
DeclareVariable("inverter3.ac.pin[1].v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,520)
DeclareVariable("inverter3.ac.pin[1].i", "Current flowing into the pin [A]", 0.0,\
 0.0,0.0,0.0,0,776)
DeclareVariable("inverter3.ac.pin[2].v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,520)
DeclareVariable("inverter3.ac.pin[2].i", "Current flowing into the pin [A]", 0.0,\
 0.0,0.0,0.0,0,776)
DeclareVariable("inverter3.ac.pin[3].v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,520)
DeclareVariable("inverter3.ac.pin[3].i", "Current flowing into the pin [A]", 0.0,\
 0.0,0.0,0.0,0,776)
DeclareAlias2("inverter3.vAC[1]", "AC potential [V]", "inverter3.ac.pin[1].v", 1,\
 5, 1966, 0)
DeclareAlias2("inverter3.vAC[2]", "AC potential [V]", "inverter3.ac.pin[2].v", 1,\
 5, 1968, 0)
DeclareAlias2("inverter3.vAC[3]", "AC potential [V]", "inverter3.ac.pin[3].v", 1,\
 5, 1970, 0)
DeclareAlias2("inverter3.iAC[1]", "AC current [A]", "inverter3.ac.pin[1].i", 1, 5,\
 1967, 0)
DeclareAlias2("inverter3.iAC[2]", "AC current [A]", "inverter3.ac.pin[2].i", 1, 5,\
 1969, 0)
DeclareAlias2("inverter3.iAC[3]", "AC current [A]", "inverter3.ac.pin[3].i", 1, 5,\
 1971, 0)
DeclareVariable("inverter3.powerAC[1]", "AC power [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter3.powerAC[2]", "AC power [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter3.powerAC[3]", "AC power [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter3.powerTotalAC", "AC total power [W]", 0.0, 0.0,0.0,0.0,\
0,512)
DeclareVariable("inverter3.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("inverter3.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter3.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter3.T_heatPort", "Temperature of heatPort [K|degC]", \
293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter3.transistor_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("inverter3.transistor_p.v[1]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter3.transistor_p.v[2]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter3.transistor_p.v[3]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter3.transistor_p.i[1]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter3.transistor_p.i[2]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter3.transistor_p.i[3]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter3.transistor_p.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("inverter3.transistor_p.plug_p.pin[1].v", "Potential at the pin [V]",\
 "inverter3.dc_p.v", 1, 5, 1959, 4)
DeclareAlias2("inverter3.transistor_p.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 "inverter3.transistor_p.i[1]", 1, 5, 1984, 132)
DeclareAlias2("inverter3.transistor_p.plug_p.pin[2].v", "Potential at the pin [V]",\
 "inverter3.dc_p.v", 1, 5, 1959, 4)
DeclareAlias2("inverter3.transistor_p.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 "inverter3.transistor_p.i[2]", 1, 5, 1985, 132)
DeclareAlias2("inverter3.transistor_p.plug_p.pin[3].v", "Potential at the pin [V]",\
 "inverter3.dc_p.v", 1, 5, 1959, 4)
DeclareAlias2("inverter3.transistor_p.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 "inverter3.transistor_p.i[3]", 1, 5, 1986, 132)
DeclareVariable("inverter3.transistor_p.plug_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("inverter3.transistor_p.plug_n.pin[1].v", "Potential at the pin [V]",\
 "inverter3.ac.pin[1].v", 1, 5, 1966, 4)
DeclareAlias2("inverter3.transistor_p.plug_n.pin[1].i", "Current flowing into the pin [A]",\
 "inverter3.transistor_p.i[1]", -1, 5, 1984, 132)
DeclareAlias2("inverter3.transistor_p.plug_n.pin[2].v", "Potential at the pin [V]",\
 "inverter3.ac.pin[2].v", 1, 5, 1968, 4)
DeclareAlias2("inverter3.transistor_p.plug_n.pin[2].i", "Current flowing into the pin [A]",\
 "inverter3.transistor_p.i[2]", -1, 5, 1985, 132)
DeclareAlias2("inverter3.transistor_p.plug_n.pin[3].v", "Potential at the pin [V]",\
 "inverter3.ac.pin[3].v", 1, 5, 1970, 4)
DeclareAlias2("inverter3.transistor_p.plug_n.pin[3].i", "Current flowing into the pin [A]",\
 "inverter3.transistor_p.i[3]", -1, 5, 1986, 132)
DeclareVariable("inverter3.transistor_p.Ron[1]", "Closed thyristor resistance [Ohm]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_p.Ron[2]", "Closed thyristor resistance [Ohm]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_p.Ron[3]", "Closed thyristor resistance [Ohm]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_p.Goff[1]", "Opened thyristor conductance [S]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_p.Goff[2]", "Opened thyristor conductance [S]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_p.Goff[3]", "Opened thyristor conductance [S]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_p.Vknee[1]", "Threshold voltage [V]", 0, \
0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_p.Vknee[2]", "Threshold voltage [V]", 0, \
0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_p.Vknee[3]", "Threshold voltage [V]", 0, \
0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_p.mh", "Number of heatPorts=number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("inverter3.transistor_p.useHeatPort", "=true, if all heat ports are enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("inverter3.transistor_p.T[1]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter3.transistor_p.T[2]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter3.transistor_p.T[3]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter3.transistor_p.fire[1]", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,642)
DeclareVariable("inverter3.transistor_p.fire[2]", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,642)
DeclareVariable("inverter3.transistor_p.fire[3]", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,642)
DeclareVariable("inverter3.transistor_p.idealGTOThyristor[1].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter3.transistor_p.idealGTOThyristor[1].i", "Current flowing from pin p to pin n [A]",\
 "inverter3.transistor_p.i[1]", 1, 5, 1984, 0)
DeclareAlias2("inverter3.transistor_p.idealGTOThyristor[1].p.v", \
"Potential at the pin [V]", "inverter3.dc_p.v", 1, 5, 1959, 4)
DeclareAlias2("inverter3.transistor_p.idealGTOThyristor[1].p.i", \
"Current flowing into the pin [A]", "inverter3.transistor_p.i[1]", 1, 5, 1984, 132)
DeclareAlias2("inverter3.transistor_p.idealGTOThyristor[1].n.v", \
"Potential at the pin [V]", "inverter3.ac.pin[1].v", 1, 5, 1966, 4)
DeclareAlias2("inverter3.transistor_p.idealGTOThyristor[1].n.i", \
"Current flowing into the pin [A]", "inverter3.transistor_p.i[1]", -1, 5, 1984, 132)
DeclareVariable("inverter3.transistor_p.idealGTOThyristor[1].Ron", \
"Forward state-on differential resistance (closed resistance) [Ohm]", 0.0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_p.idealGTOThyristor[1].Goff", \
"Backward state-off conductance (opened conductance) [S]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_p.idealGTOThyristor[1].Vknee", \
"Forward threshold voltage [V]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_p.idealGTOThyristor[1].useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter3.transistor_p.idealGTOThyristor[1].T", \
"Fixed device temperature if useHeatPort = false [K|degC]", 288, 293.15, 0.0,\
1E+100,300.0,0,560)
DeclareVariable("inverter3.transistor_p.idealGTOThyristor[1].LossPower", \
"Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter3.transistor_p.idealGTOThyristor[1].T_heatPort", \
"Temperature of heatPort [K|degC]", "inverter3.transistor_p.idealGTOThyristor[1].T", 1,\
 7, 288, 0)
DeclareVariable("inverter3.transistor_p.idealGTOThyristor[1].off", \
"Switching state [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter3.transistor_p.idealGTOThyristor[1].s", \
"Auxiliary variable for actual position on the ideal diode characteristic [1]", 0,\
 0.0,0.0,0.0,0,2624)
DeclareVariable("inverter3.transistor_p.idealGTOThyristor[1].unitVoltage", "[V]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("inverter3.transistor_p.idealGTOThyristor[1].unitCurrent", "[A]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("inverter3.transistor_p.idealGTOThyristor[1].fire", \
"[:#(type=Boolean)]", "inverter3.transistor_p.fire[1]", 1, 5, 2003, 65)
DeclareVariable("inverter3.transistor_p.idealGTOThyristor[2].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter3.transistor_p.idealGTOThyristor[2].i", "Current flowing from pin p to pin n [A]",\
 "inverter3.transistor_p.i[2]", 1, 5, 1985, 0)
DeclareAlias2("inverter3.transistor_p.idealGTOThyristor[2].p.v", \
"Potential at the pin [V]", "inverter3.dc_p.v", 1, 5, 1959, 4)
DeclareAlias2("inverter3.transistor_p.idealGTOThyristor[2].p.i", \
"Current flowing into the pin [A]", "inverter3.transistor_p.i[2]", 1, 5, 1985, 132)
DeclareAlias2("inverter3.transistor_p.idealGTOThyristor[2].n.v", \
"Potential at the pin [V]", "inverter3.ac.pin[2].v", 1, 5, 1968, 4)
DeclareAlias2("inverter3.transistor_p.idealGTOThyristor[2].n.i", \
"Current flowing into the pin [A]", "inverter3.transistor_p.i[2]", -1, 5, 1985, 132)
DeclareVariable("inverter3.transistor_p.idealGTOThyristor[2].Ron", \
"Forward state-on differential resistance (closed resistance) [Ohm]", 0.0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_p.idealGTOThyristor[2].Goff", \
"Backward state-off conductance (opened conductance) [S]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_p.idealGTOThyristor[2].Vknee", \
"Forward threshold voltage [V]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_p.idealGTOThyristor[2].useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter3.transistor_p.idealGTOThyristor[2].T", \
"Fixed device temperature if useHeatPort = false [K|degC]", 289, 293.15, 0.0,\
1E+100,300.0,0,560)
DeclareVariable("inverter3.transistor_p.idealGTOThyristor[2].LossPower", \
"Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter3.transistor_p.idealGTOThyristor[2].T_heatPort", \
"Temperature of heatPort [K|degC]", "inverter3.transistor_p.idealGTOThyristor[2].T", 1,\
 7, 289, 0)
DeclareVariable("inverter3.transistor_p.idealGTOThyristor[2].off", \
"Switching state [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter3.transistor_p.idealGTOThyristor[2].s", \
"Auxiliary variable for actual position on the ideal diode characteristic [1]", 0,\
 0.0,0.0,0.0,0,2624)
DeclareVariable("inverter3.transistor_p.idealGTOThyristor[2].unitVoltage", "[V]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("inverter3.transistor_p.idealGTOThyristor[2].unitCurrent", "[A]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("inverter3.transistor_p.idealGTOThyristor[2].fire", \
"[:#(type=Boolean)]", "inverter3.transistor_p.fire[2]", 1, 5, 2004, 65)
DeclareVariable("inverter3.transistor_p.idealGTOThyristor[3].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter3.transistor_p.idealGTOThyristor[3].i", "Current flowing from pin p to pin n [A]",\
 "inverter3.transistor_p.i[3]", 1, 5, 1986, 0)
DeclareAlias2("inverter3.transistor_p.idealGTOThyristor[3].p.v", \
"Potential at the pin [V]", "inverter3.dc_p.v", 1, 5, 1959, 4)
DeclareAlias2("inverter3.transistor_p.idealGTOThyristor[3].p.i", \
"Current flowing into the pin [A]", "inverter3.transistor_p.i[3]", 1, 5, 1986, 132)
DeclareAlias2("inverter3.transistor_p.idealGTOThyristor[3].n.v", \
"Potential at the pin [V]", "inverter3.ac.pin[3].v", 1, 5, 1970, 4)
DeclareAlias2("inverter3.transistor_p.idealGTOThyristor[3].n.i", \
"Current flowing into the pin [A]", "inverter3.transistor_p.i[3]", -1, 5, 1986, 132)
DeclareVariable("inverter3.transistor_p.idealGTOThyristor[3].Ron", \
"Forward state-on differential resistance (closed resistance) [Ohm]", 0.0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_p.idealGTOThyristor[3].Goff", \
"Backward state-off conductance (opened conductance) [S]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_p.idealGTOThyristor[3].Vknee", \
"Forward threshold voltage [V]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_p.idealGTOThyristor[3].useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter3.transistor_p.idealGTOThyristor[3].T", \
"Fixed device temperature if useHeatPort = false [K|degC]", 290, 293.15, 0.0,\
1E+100,300.0,0,560)
DeclareVariable("inverter3.transistor_p.idealGTOThyristor[3].LossPower", \
"Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter3.transistor_p.idealGTOThyristor[3].T_heatPort", \
"Temperature of heatPort [K|degC]", "inverter3.transistor_p.idealGTOThyristor[3].T", 1,\
 7, 290, 0)
DeclareVariable("inverter3.transistor_p.idealGTOThyristor[3].off", \
"Switching state [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter3.transistor_p.idealGTOThyristor[3].s", \
"Auxiliary variable for actual position on the ideal diode characteristic [1]", 0,\
 0.0,0.0,0.0,0,2624)
DeclareVariable("inverter3.transistor_p.idealGTOThyristor[3].unitVoltage", "[V]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("inverter3.transistor_p.idealGTOThyristor[3].unitCurrent", "[A]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("inverter3.transistor_p.idealGTOThyristor[3].fire", \
"[:#(type=Boolean)]", "inverter3.transistor_p.fire[3]", 1, 5, 2005, 65)
DeclareVariable("inverter3.diode_p.m", "Number of phases [:#(type=Integer)]", 3,\
 1.0,1E+100,0.0,0,517)
DeclareVariable("inverter3.diode_p.v[1]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter3.diode_p.v[2]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter3.diode_p.v[3]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter3.diode_p.i[1]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter3.diode_p.i[2]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter3.diode_p.i[3]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter3.diode_p.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("inverter3.diode_p.plug_p.pin[1].v", "Potential at the pin [V]", \
"inverter3.ac.pin[1].v", 1, 5, 1966, 4)
DeclareAlias2("inverter3.diode_p.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 "inverter3.diode_p.i[1]", 1, 5, 2040, 132)
DeclareAlias2("inverter3.diode_p.plug_p.pin[2].v", "Potential at the pin [V]", \
"inverter3.ac.pin[2].v", 1, 5, 1968, 4)
DeclareAlias2("inverter3.diode_p.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 "inverter3.diode_p.i[2]", 1, 5, 2041, 132)
DeclareAlias2("inverter3.diode_p.plug_p.pin[3].v", "Potential at the pin [V]", \
"inverter3.ac.pin[3].v", 1, 5, 1970, 4)
DeclareAlias2("inverter3.diode_p.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 "inverter3.diode_p.i[3]", 1, 5, 2042, 132)
DeclareVariable("inverter3.diode_p.plug_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("inverter3.diode_p.plug_n.pin[1].v", "Potential at the pin [V]", \
"inverter3.dc_p.v", 1, 5, 1959, 4)
DeclareAlias2("inverter3.diode_p.plug_n.pin[1].i", "Current flowing into the pin [A]",\
 "inverter3.diode_p.i[1]", -1, 5, 2040, 132)
DeclareAlias2("inverter3.diode_p.plug_n.pin[2].v", "Potential at the pin [V]", \
"inverter3.dc_p.v", 1, 5, 1959, 4)
DeclareAlias2("inverter3.diode_p.plug_n.pin[2].i", "Current flowing into the pin [A]",\
 "inverter3.diode_p.i[2]", -1, 5, 2041, 132)
DeclareAlias2("inverter3.diode_p.plug_n.pin[3].v", "Potential at the pin [V]", \
"inverter3.dc_p.v", 1, 5, 1959, 4)
DeclareAlias2("inverter3.diode_p.plug_n.pin[3].i", "Current flowing into the pin [A]",\
 "inverter3.diode_p.i[3]", -1, 5, 2042, 132)
DeclareVariable("inverter3.diode_p.Ron[1]", "Closed diode resistance [Ohm]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_p.Ron[2]", "Closed diode resistance [Ohm]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_p.Ron[3]", "Closed diode resistance [Ohm]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_p.Goff[1]", "Opened diode conductance [S]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_p.Goff[2]", "Opened diode conductance [S]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_p.Goff[3]", "Opened diode conductance [S]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_p.Vknee[1]", "Threshold voltage [V]", 0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_p.Vknee[2]", "Threshold voltage [V]", 0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_p.Vknee[3]", "Threshold voltage [V]", 0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_p.mh", "Number of heatPorts=number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("inverter3.diode_p.useHeatPort", "=true, if all heat ports are enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("inverter3.diode_p.T[1]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter3.diode_p.T[2]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter3.diode_p.T[3]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter3.diode_p.idealDiode[1].v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter3.diode_p.idealDiode[1].i", "Current flowing from pin p to pin n [A]",\
 "inverter3.diode_p.i[1]", 1, 5, 2040, 0)
DeclareAlias2("inverter3.diode_p.idealDiode[1].p.v", "Potential at the pin [V]",\
 "inverter3.ac.pin[1].v", 1, 5, 1966, 4)
DeclareAlias2("inverter3.diode_p.idealDiode[1].p.i", "Current flowing into the pin [A]",\
 "inverter3.diode_p.i[1]", 1, 5, 2040, 132)
DeclareAlias2("inverter3.diode_p.idealDiode[1].n.v", "Potential at the pin [V]",\
 "inverter3.dc_p.v", 1, 5, 1959, 4)
DeclareAlias2("inverter3.diode_p.idealDiode[1].n.i", "Current flowing into the pin [A]",\
 "inverter3.diode_p.i[1]", -1, 5, 2040, 132)
DeclareVariable("inverter3.diode_p.idealDiode[1].Ron", "Forward state-on differential resistance (closed resistance) [Ohm]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_p.idealDiode[1].Goff", "Backward state-off conductance (opened conductance) [S]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_p.idealDiode[1].Vknee", "Forward threshold voltage [V]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_p.idealDiode[1].useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter3.diode_p.idealDiode[1].T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 291, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("inverter3.diode_p.idealDiode[1].LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter3.diode_p.idealDiode[1].T_heatPort", "Temperature of heatPort [K|degC]",\
 "inverter3.diode_p.idealDiode[1].T", 1, 7, 291, 0)
DeclareVariable("inverter3.diode_p.idealDiode[1].off", "Switching state [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter3.diode_p.idealDiode[1].s", "Auxiliary variable for actual position on the ideal diode characteristic [1]",\
 0, 0.0,0.0,0.0,0,2624)
DeclareVariable("inverter3.diode_p.idealDiode[1].unitVoltage", "[V]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter3.diode_p.idealDiode[1].unitCurrent", "[A]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter3.diode_p.idealDiode[2].v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter3.diode_p.idealDiode[2].i", "Current flowing from pin p to pin n [A]",\
 "inverter3.diode_p.i[2]", 1, 5, 2041, 0)
DeclareAlias2("inverter3.diode_p.idealDiode[2].p.v", "Potential at the pin [V]",\
 "inverter3.ac.pin[2].v", 1, 5, 1968, 4)
DeclareAlias2("inverter3.diode_p.idealDiode[2].p.i", "Current flowing into the pin [A]",\
 "inverter3.diode_p.i[2]", 1, 5, 2041, 132)
DeclareAlias2("inverter3.diode_p.idealDiode[2].n.v", "Potential at the pin [V]",\
 "inverter3.dc_p.v", 1, 5, 1959, 4)
DeclareAlias2("inverter3.diode_p.idealDiode[2].n.i", "Current flowing into the pin [A]",\
 "inverter3.diode_p.i[2]", -1, 5, 2041, 132)
DeclareVariable("inverter3.diode_p.idealDiode[2].Ron", "Forward state-on differential resistance (closed resistance) [Ohm]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_p.idealDiode[2].Goff", "Backward state-off conductance (opened conductance) [S]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_p.idealDiode[2].Vknee", "Forward threshold voltage [V]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_p.idealDiode[2].useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter3.diode_p.idealDiode[2].T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 292, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("inverter3.diode_p.idealDiode[2].LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter3.diode_p.idealDiode[2].T_heatPort", "Temperature of heatPort [K|degC]",\
 "inverter3.diode_p.idealDiode[2].T", 1, 7, 292, 0)
DeclareVariable("inverter3.diode_p.idealDiode[2].off", "Switching state [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter3.diode_p.idealDiode[2].s", "Auxiliary variable for actual position on the ideal diode characteristic [1]",\
 0, 0.0,0.0,0.0,0,2624)
DeclareVariable("inverter3.diode_p.idealDiode[2].unitVoltage", "[V]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter3.diode_p.idealDiode[2].unitCurrent", "[A]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter3.diode_p.idealDiode[3].v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter3.diode_p.idealDiode[3].i", "Current flowing from pin p to pin n [A]",\
 "inverter3.diode_p.i[3]", 1, 5, 2042, 0)
DeclareAlias2("inverter3.diode_p.idealDiode[3].p.v", "Potential at the pin [V]",\
 "inverter3.ac.pin[3].v", 1, 5, 1970, 4)
DeclareAlias2("inverter3.diode_p.idealDiode[3].p.i", "Current flowing into the pin [A]",\
 "inverter3.diode_p.i[3]", 1, 5, 2042, 132)
DeclareAlias2("inverter3.diode_p.idealDiode[3].n.v", "Potential at the pin [V]",\
 "inverter3.dc_p.v", 1, 5, 1959, 4)
DeclareAlias2("inverter3.diode_p.idealDiode[3].n.i", "Current flowing into the pin [A]",\
 "inverter3.diode_p.i[3]", -1, 5, 2042, 132)
DeclareVariable("inverter3.diode_p.idealDiode[3].Ron", "Forward state-on differential resistance (closed resistance) [Ohm]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_p.idealDiode[3].Goff", "Backward state-off conductance (opened conductance) [S]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_p.idealDiode[3].Vknee", "Forward threshold voltage [V]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_p.idealDiode[3].useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter3.diode_p.idealDiode[3].T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 293, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("inverter3.diode_p.idealDiode[3].LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter3.diode_p.idealDiode[3].T_heatPort", "Temperature of heatPort [K|degC]",\
 "inverter3.diode_p.idealDiode[3].T", 1, 7, 293, 0)
DeclareVariable("inverter3.diode_p.idealDiode[3].off", "Switching state [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter3.diode_p.idealDiode[3].s", "Auxiliary variable for actual position on the ideal diode characteristic [1]",\
 0, 0.0,0.0,0.0,0,2624)
DeclareVariable("inverter3.diode_p.idealDiode[3].unitVoltage", "[V]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter3.diode_p.idealDiode[3].unitCurrent", "[A]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter3.star_p.m", "Number of phases [:#(type=Integer)]", 3, \
1.0,1E+100,0.0,0,517)
DeclareVariable("inverter3.star_p.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("inverter3.star_p.plug_p.pin[1].v", "Potential at the pin [V]", \
"inverter3.dc_p.v", 1, 5, 1959, 4)
DeclareVariable("inverter3.star_p.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("inverter3.star_p.plug_p.pin[2].v", "Potential at the pin [V]", \
"inverter3.dc_p.v", 1, 5, 1959, 4)
DeclareVariable("inverter3.star_p.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("inverter3.star_p.plug_p.pin[3].v", "Potential at the pin [V]", \
"inverter3.dc_p.v", 1, 5, 1959, 4)
DeclareVariable("inverter3.star_p.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("inverter3.star_p.pin_n.v", "Potential at the pin [V]", \
"inverter3.dc_p.v", 1, 5, 1959, 4)
DeclareAlias2("inverter3.star_p.pin_n.i", "Current flowing into the pin [A]", \
"inverter3.dc_p.i", 1, 5, 1960, 132)
DeclareVariable("inverter3.transistor_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("inverter3.transistor_n.v[1]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter3.transistor_n.v[2]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter3.transistor_n.v[3]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter3.transistor_n.i[1]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter3.transistor_n.i[2]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter3.transistor_n.i[3]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter3.transistor_n.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("inverter3.transistor_n.plug_p.pin[1].v", "Potential at the pin [V]",\
 "inverter3.ac.pin[1].v", 1, 5, 1966, 4)
DeclareAlias2("inverter3.transistor_n.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 "inverter3.transistor_n.i[1]", 1, 5, 2098, 132)
DeclareAlias2("inverter3.transistor_n.plug_p.pin[2].v", "Potential at the pin [V]",\
 "inverter3.ac.pin[2].v", 1, 5, 1968, 4)
DeclareAlias2("inverter3.transistor_n.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 "inverter3.transistor_n.i[2]", 1, 5, 2099, 132)
DeclareAlias2("inverter3.transistor_n.plug_p.pin[3].v", "Potential at the pin [V]",\
 "inverter3.ac.pin[3].v", 1, 5, 1970, 4)
DeclareAlias2("inverter3.transistor_n.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 "inverter3.transistor_n.i[3]", 1, 5, 2100, 132)
DeclareVariable("inverter3.transistor_n.plug_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("inverter3.transistor_n.plug_n.pin[1].v", "Potential at the pin [V]",\
 "inverter3.dc_n.v", 1, 5, 1961, 4)
DeclareAlias2("inverter3.transistor_n.plug_n.pin[1].i", "Current flowing into the pin [A]",\
 "inverter3.transistor_n.i[1]", -1, 5, 2098, 132)
DeclareAlias2("inverter3.transistor_n.plug_n.pin[2].v", "Potential at the pin [V]",\
 "inverter3.dc_n.v", 1, 5, 1961, 4)
DeclareAlias2("inverter3.transistor_n.plug_n.pin[2].i", "Current flowing into the pin [A]",\
 "inverter3.transistor_n.i[2]", -1, 5, 2099, 132)
DeclareAlias2("inverter3.transistor_n.plug_n.pin[3].v", "Potential at the pin [V]",\
 "inverter3.dc_n.v", 1, 5, 1961, 4)
DeclareAlias2("inverter3.transistor_n.plug_n.pin[3].i", "Current flowing into the pin [A]",\
 "inverter3.transistor_n.i[3]", -1, 5, 2100, 132)
DeclareVariable("inverter3.transistor_n.Ron[1]", "Closed thyristor resistance [Ohm]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_n.Ron[2]", "Closed thyristor resistance [Ohm]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_n.Ron[3]", "Closed thyristor resistance [Ohm]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_n.Goff[1]", "Opened thyristor conductance [S]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_n.Goff[2]", "Opened thyristor conductance [S]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_n.Goff[3]", "Opened thyristor conductance [S]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_n.Vknee[1]", "Threshold voltage [V]", 0, \
0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_n.Vknee[2]", "Threshold voltage [V]", 0, \
0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_n.Vknee[3]", "Threshold voltage [V]", 0, \
0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_n.mh", "Number of heatPorts=number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("inverter3.transistor_n.useHeatPort", "=true, if all heat ports are enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("inverter3.transistor_n.T[1]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter3.transistor_n.T[2]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter3.transistor_n.T[3]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter3.transistor_n.fire[1]", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,642)
DeclareVariable("inverter3.transistor_n.fire[2]", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,642)
DeclareVariable("inverter3.transistor_n.fire[3]", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,642)
DeclareVariable("inverter3.transistor_n.idealGTOThyristor[1].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter3.transistor_n.idealGTOThyristor[1].i", "Current flowing from pin p to pin n [A]",\
 "inverter3.transistor_n.i[1]", 1, 5, 2098, 0)
DeclareAlias2("inverter3.transistor_n.idealGTOThyristor[1].p.v", \
"Potential at the pin [V]", "inverter3.ac.pin[1].v", 1, 5, 1966, 4)
DeclareAlias2("inverter3.transistor_n.idealGTOThyristor[1].p.i", \
"Current flowing into the pin [A]", "inverter3.transistor_n.i[1]", 1, 5, 2098, 132)
DeclareAlias2("inverter3.transistor_n.idealGTOThyristor[1].n.v", \
"Potential at the pin [V]", "inverter3.dc_n.v", 1, 5, 1961, 4)
DeclareAlias2("inverter3.transistor_n.idealGTOThyristor[1].n.i", \
"Current flowing into the pin [A]", "inverter3.transistor_n.i[1]", -1, 5, 2098, 132)
DeclareVariable("inverter3.transistor_n.idealGTOThyristor[1].Ron", \
"Forward state-on differential resistance (closed resistance) [Ohm]", 0.0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_n.idealGTOThyristor[1].Goff", \
"Backward state-off conductance (opened conductance) [S]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_n.idealGTOThyristor[1].Vknee", \
"Forward threshold voltage [V]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_n.idealGTOThyristor[1].useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter3.transistor_n.idealGTOThyristor[1].T", \
"Fixed device temperature if useHeatPort = false [K|degC]", 294, 293.15, 0.0,\
1E+100,300.0,0,560)
DeclareVariable("inverter3.transistor_n.idealGTOThyristor[1].LossPower", \
"Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter3.transistor_n.idealGTOThyristor[1].T_heatPort", \
"Temperature of heatPort [K|degC]", "inverter3.transistor_n.idealGTOThyristor[1].T", 1,\
 7, 294, 0)
DeclareVariable("inverter3.transistor_n.idealGTOThyristor[1].off", \
"Switching state [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter3.transistor_n.idealGTOThyristor[1].s", \
"Auxiliary variable for actual position on the ideal diode characteristic [1]", 0,\
 0.0,0.0,0.0,0,2624)
DeclareVariable("inverter3.transistor_n.idealGTOThyristor[1].unitVoltage", "[V]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("inverter3.transistor_n.idealGTOThyristor[1].unitCurrent", "[A]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("inverter3.transistor_n.idealGTOThyristor[1].fire", \
"[:#(type=Boolean)]", "inverter3.transistor_n.fire[1]", 1, 5, 2117, 65)
DeclareVariable("inverter3.transistor_n.idealGTOThyristor[2].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter3.transistor_n.idealGTOThyristor[2].i", "Current flowing from pin p to pin n [A]",\
 "inverter3.transistor_n.i[2]", 1, 5, 2099, 0)
DeclareAlias2("inverter3.transistor_n.idealGTOThyristor[2].p.v", \
"Potential at the pin [V]", "inverter3.ac.pin[2].v", 1, 5, 1968, 4)
DeclareAlias2("inverter3.transistor_n.idealGTOThyristor[2].p.i", \
"Current flowing into the pin [A]", "inverter3.transistor_n.i[2]", 1, 5, 2099, 132)
DeclareAlias2("inverter3.transistor_n.idealGTOThyristor[2].n.v", \
"Potential at the pin [V]", "inverter3.dc_n.v", 1, 5, 1961, 4)
DeclareAlias2("inverter3.transistor_n.idealGTOThyristor[2].n.i", \
"Current flowing into the pin [A]", "inverter3.transistor_n.i[2]", -1, 5, 2099, 132)
DeclareVariable("inverter3.transistor_n.idealGTOThyristor[2].Ron", \
"Forward state-on differential resistance (closed resistance) [Ohm]", 0.0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_n.idealGTOThyristor[2].Goff", \
"Backward state-off conductance (opened conductance) [S]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_n.idealGTOThyristor[2].Vknee", \
"Forward threshold voltage [V]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_n.idealGTOThyristor[2].useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter3.transistor_n.idealGTOThyristor[2].T", \
"Fixed device temperature if useHeatPort = false [K|degC]", 295, 293.15, 0.0,\
1E+100,300.0,0,560)
DeclareVariable("inverter3.transistor_n.idealGTOThyristor[2].LossPower", \
"Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter3.transistor_n.idealGTOThyristor[2].T_heatPort", \
"Temperature of heatPort [K|degC]", "inverter3.transistor_n.idealGTOThyristor[2].T", 1,\
 7, 295, 0)
DeclareVariable("inverter3.transistor_n.idealGTOThyristor[2].off", \
"Switching state [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter3.transistor_n.idealGTOThyristor[2].s", \
"Auxiliary variable for actual position on the ideal diode characteristic [1]", 0,\
 0.0,0.0,0.0,0,2624)
DeclareVariable("inverter3.transistor_n.idealGTOThyristor[2].unitVoltage", "[V]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("inverter3.transistor_n.idealGTOThyristor[2].unitCurrent", "[A]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("inverter3.transistor_n.idealGTOThyristor[2].fire", \
"[:#(type=Boolean)]", "inverter3.transistor_n.fire[2]", 1, 5, 2118, 65)
DeclareVariable("inverter3.transistor_n.idealGTOThyristor[3].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter3.transistor_n.idealGTOThyristor[3].i", "Current flowing from pin p to pin n [A]",\
 "inverter3.transistor_n.i[3]", 1, 5, 2100, 0)
DeclareAlias2("inverter3.transistor_n.idealGTOThyristor[3].p.v", \
"Potential at the pin [V]", "inverter3.ac.pin[3].v", 1, 5, 1970, 4)
DeclareAlias2("inverter3.transistor_n.idealGTOThyristor[3].p.i", \
"Current flowing into the pin [A]", "inverter3.transistor_n.i[3]", 1, 5, 2100, 132)
DeclareAlias2("inverter3.transistor_n.idealGTOThyristor[3].n.v", \
"Potential at the pin [V]", "inverter3.dc_n.v", 1, 5, 1961, 4)
DeclareAlias2("inverter3.transistor_n.idealGTOThyristor[3].n.i", \
"Current flowing into the pin [A]", "inverter3.transistor_n.i[3]", -1, 5, 2100, 132)
DeclareVariable("inverter3.transistor_n.idealGTOThyristor[3].Ron", \
"Forward state-on differential resistance (closed resistance) [Ohm]", 0.0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_n.idealGTOThyristor[3].Goff", \
"Backward state-off conductance (opened conductance) [S]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_n.idealGTOThyristor[3].Vknee", \
"Forward threshold voltage [V]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.transistor_n.idealGTOThyristor[3].useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter3.transistor_n.idealGTOThyristor[3].T", \
"Fixed device temperature if useHeatPort = false [K|degC]", 296, 293.15, 0.0,\
1E+100,300.0,0,560)
DeclareVariable("inverter3.transistor_n.idealGTOThyristor[3].LossPower", \
"Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter3.transistor_n.idealGTOThyristor[3].T_heatPort", \
"Temperature of heatPort [K|degC]", "inverter3.transistor_n.idealGTOThyristor[3].T", 1,\
 7, 296, 0)
DeclareVariable("inverter3.transistor_n.idealGTOThyristor[3].off", \
"Switching state [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter3.transistor_n.idealGTOThyristor[3].s", \
"Auxiliary variable for actual position on the ideal diode characteristic [1]", 0,\
 0.0,0.0,0.0,0,2624)
DeclareVariable("inverter3.transistor_n.idealGTOThyristor[3].unitVoltage", "[V]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("inverter3.transistor_n.idealGTOThyristor[3].unitCurrent", "[A]",\
 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("inverter3.transistor_n.idealGTOThyristor[3].fire", \
"[:#(type=Boolean)]", "inverter3.transistor_n.fire[3]", 1, 5, 2119, 65)
DeclareVariable("inverter3.diode_n.m", "Number of phases [:#(type=Integer)]", 3,\
 1.0,1E+100,0.0,0,517)
DeclareVariable("inverter3.diode_n.v[1]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter3.diode_n.v[2]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter3.diode_n.v[3]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter3.diode_n.i[1]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter3.diode_n.i[2]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter3.diode_n.i[3]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inverter3.diode_n.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("inverter3.diode_n.plug_p.pin[1].v", "Potential at the pin [V]", \
"inverter3.dc_n.v", 1, 5, 1961, 4)
DeclareAlias2("inverter3.diode_n.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 "inverter3.diode_n.i[1]", 1, 5, 2154, 132)
DeclareAlias2("inverter3.diode_n.plug_p.pin[2].v", "Potential at the pin [V]", \
"inverter3.dc_n.v", 1, 5, 1961, 4)
DeclareAlias2("inverter3.diode_n.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 "inverter3.diode_n.i[2]", 1, 5, 2155, 132)
DeclareAlias2("inverter3.diode_n.plug_p.pin[3].v", "Potential at the pin [V]", \
"inverter3.dc_n.v", 1, 5, 1961, 4)
DeclareAlias2("inverter3.diode_n.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 "inverter3.diode_n.i[3]", 1, 5, 2156, 132)
DeclareVariable("inverter3.diode_n.plug_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("inverter3.diode_n.plug_n.pin[1].v", "Potential at the pin [V]", \
"inverter3.ac.pin[1].v", 1, 5, 1966, 4)
DeclareAlias2("inverter3.diode_n.plug_n.pin[1].i", "Current flowing into the pin [A]",\
 "inverter3.diode_n.i[1]", -1, 5, 2154, 132)
DeclareAlias2("inverter3.diode_n.plug_n.pin[2].v", "Potential at the pin [V]", \
"inverter3.ac.pin[2].v", 1, 5, 1968, 4)
DeclareAlias2("inverter3.diode_n.plug_n.pin[2].i", "Current flowing into the pin [A]",\
 "inverter3.diode_n.i[2]", -1, 5, 2155, 132)
DeclareAlias2("inverter3.diode_n.plug_n.pin[3].v", "Potential at the pin [V]", \
"inverter3.ac.pin[3].v", 1, 5, 1970, 4)
DeclareAlias2("inverter3.diode_n.plug_n.pin[3].i", "Current flowing into the pin [A]",\
 "inverter3.diode_n.i[3]", -1, 5, 2156, 132)
DeclareVariable("inverter3.diode_n.Ron[1]", "Closed diode resistance [Ohm]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_n.Ron[2]", "Closed diode resistance [Ohm]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_n.Ron[3]", "Closed diode resistance [Ohm]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_n.Goff[1]", "Opened diode conductance [S]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_n.Goff[2]", "Opened diode conductance [S]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_n.Goff[3]", "Opened diode conductance [S]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_n.Vknee[1]", "Threshold voltage [V]", 0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_n.Vknee[2]", "Threshold voltage [V]", 0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_n.Vknee[3]", "Threshold voltage [V]", 0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_n.mh", "Number of heatPorts=number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("inverter3.diode_n.useHeatPort", "=true, if all heat ports are enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("inverter3.diode_n.T[1]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter3.diode_n.T[2]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter3.diode_n.T[3]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("inverter3.diode_n.idealDiode[1].v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter3.diode_n.idealDiode[1].i", "Current flowing from pin p to pin n [A]",\
 "inverter3.diode_n.i[1]", 1, 5, 2154, 0)
DeclareAlias2("inverter3.diode_n.idealDiode[1].p.v", "Potential at the pin [V]",\
 "inverter3.dc_n.v", 1, 5, 1961, 4)
DeclareAlias2("inverter3.diode_n.idealDiode[1].p.i", "Current flowing into the pin [A]",\
 "inverter3.diode_n.i[1]", 1, 5, 2154, 132)
DeclareAlias2("inverter3.diode_n.idealDiode[1].n.v", "Potential at the pin [V]",\
 "inverter3.ac.pin[1].v", 1, 5, 1966, 4)
DeclareAlias2("inverter3.diode_n.idealDiode[1].n.i", "Current flowing into the pin [A]",\
 "inverter3.diode_n.i[1]", -1, 5, 2154, 132)
DeclareVariable("inverter3.diode_n.idealDiode[1].Ron", "Forward state-on differential resistance (closed resistance) [Ohm]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_n.idealDiode[1].Goff", "Backward state-off conductance (opened conductance) [S]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_n.idealDiode[1].Vknee", "Forward threshold voltage [V]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_n.idealDiode[1].useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter3.diode_n.idealDiode[1].T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 297, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("inverter3.diode_n.idealDiode[1].LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter3.diode_n.idealDiode[1].T_heatPort", "Temperature of heatPort [K|degC]",\
 "inverter3.diode_n.idealDiode[1].T", 1, 7, 297, 0)
DeclareVariable("inverter3.diode_n.idealDiode[1].off", "Switching state [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter3.diode_n.idealDiode[1].s", "Auxiliary variable for actual position on the ideal diode characteristic [1]",\
 0, 0.0,0.0,0.0,0,2624)
DeclareVariable("inverter3.diode_n.idealDiode[1].unitVoltage", "[V]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter3.diode_n.idealDiode[1].unitCurrent", "[A]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter3.diode_n.idealDiode[2].v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter3.diode_n.idealDiode[2].i", "Current flowing from pin p to pin n [A]",\
 "inverter3.diode_n.i[2]", 1, 5, 2155, 0)
DeclareAlias2("inverter3.diode_n.idealDiode[2].p.v", "Potential at the pin [V]",\
 "inverter3.dc_n.v", 1, 5, 1961, 4)
DeclareAlias2("inverter3.diode_n.idealDiode[2].p.i", "Current flowing into the pin [A]",\
 "inverter3.diode_n.i[2]", 1, 5, 2155, 132)
DeclareAlias2("inverter3.diode_n.idealDiode[2].n.v", "Potential at the pin [V]",\
 "inverter3.ac.pin[2].v", 1, 5, 1968, 4)
DeclareAlias2("inverter3.diode_n.idealDiode[2].n.i", "Current flowing into the pin [A]",\
 "inverter3.diode_n.i[2]", -1, 5, 2155, 132)
DeclareVariable("inverter3.diode_n.idealDiode[2].Ron", "Forward state-on differential resistance (closed resistance) [Ohm]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_n.idealDiode[2].Goff", "Backward state-off conductance (opened conductance) [S]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_n.idealDiode[2].Vknee", "Forward threshold voltage [V]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_n.idealDiode[2].useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter3.diode_n.idealDiode[2].T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 298, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("inverter3.diode_n.idealDiode[2].LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter3.diode_n.idealDiode[2].T_heatPort", "Temperature of heatPort [K|degC]",\
 "inverter3.diode_n.idealDiode[2].T", 1, 7, 298, 0)
DeclareVariable("inverter3.diode_n.idealDiode[2].off", "Switching state [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter3.diode_n.idealDiode[2].s", "Auxiliary variable for actual position on the ideal diode characteristic [1]",\
 0, 0.0,0.0,0.0,0,2624)
DeclareVariable("inverter3.diode_n.idealDiode[2].unitVoltage", "[V]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter3.diode_n.idealDiode[2].unitCurrent", "[A]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter3.diode_n.idealDiode[3].v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inverter3.diode_n.idealDiode[3].i", "Current flowing from pin p to pin n [A]",\
 "inverter3.diode_n.i[3]", 1, 5, 2156, 0)
DeclareAlias2("inverter3.diode_n.idealDiode[3].p.v", "Potential at the pin [V]",\
 "inverter3.dc_n.v", 1, 5, 1961, 4)
DeclareAlias2("inverter3.diode_n.idealDiode[3].p.i", "Current flowing into the pin [A]",\
 "inverter3.diode_n.i[3]", 1, 5, 2156, 132)
DeclareAlias2("inverter3.diode_n.idealDiode[3].n.v", "Potential at the pin [V]",\
 "inverter3.ac.pin[3].v", 1, 5, 1970, 4)
DeclareAlias2("inverter3.diode_n.idealDiode[3].n.i", "Current flowing into the pin [A]",\
 "inverter3.diode_n.i[3]", -1, 5, 2156, 132)
DeclareVariable("inverter3.diode_n.idealDiode[3].Ron", "Forward state-on differential resistance (closed resistance) [Ohm]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_n.idealDiode[3].Goff", "Backward state-off conductance (opened conductance) [S]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_n.idealDiode[3].Vknee", "Forward threshold voltage [V]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("inverter3.diode_n.idealDiode[3].useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("inverter3.diode_n.idealDiode[3].T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 299, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("inverter3.diode_n.idealDiode[3].LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
EndNonAlias(1)
PreNonAliasNew(2)
StartNonAlias(2)
DeclareAlias2("inverter3.diode_n.idealDiode[3].T_heatPort", "Temperature of heatPort [K|degC]",\
 "inverter3.diode_n.idealDiode[3].T", 1, 7, 299, 0)
DeclareVariable("inverter3.diode_n.idealDiode[3].off", "Switching state [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,706)
DeclareVariable("inverter3.diode_n.idealDiode[3].s", "Auxiliary variable for actual position on the ideal diode characteristic [1]",\
 0, 0.0,0.0,0.0,0,2624)
DeclareVariable("inverter3.diode_n.idealDiode[3].unitVoltage", "[V]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter3.diode_n.idealDiode[3].unitCurrent", "[A]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("inverter3.star_n.m", "Number of phases [:#(type=Integer)]", 3, \
1.0,1E+100,0.0,0,517)
DeclareVariable("inverter3.star_n.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("inverter3.star_n.plug_p.pin[1].v", "Potential at the pin [V]", \
"inverter3.dc_n.v", 1, 5, 1961, 4)
DeclareVariable("inverter3.star_n.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("inverter3.star_n.plug_p.pin[2].v", "Potential at the pin [V]", \
"inverter3.dc_n.v", 1, 5, 1961, 4)
DeclareVariable("inverter3.star_n.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("inverter3.star_n.plug_p.pin[3].v", "Potential at the pin [V]", \
"inverter3.dc_n.v", 1, 5, 1961, 4)
DeclareVariable("inverter3.star_n.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("inverter3.star_n.pin_n.v", "Potential at the pin [V]", \
"inverter3.dc_n.v", 1, 5, 1961, 4)
DeclareAlias2("inverter3.star_n.pin_n.i", "Current flowing into the pin [A]", \
"inverter3.dc_n.i", 1, 5, 1962, 132)
DeclareParameter("dcdc2.RonTransistor", "Transistor closed resistance [Ohm]", 300,\
 1E-05, 0.0,0.0,0.0,0,560)
DeclareParameter("dcdc2.GoffTransistor", "Transistor opened conductance [S]", 301,\
 1E-05, 0.0,0.0,0.0,0,560)
DeclareParameter("dcdc2.VkneeTransistor", "Transistor threshold voltage [V]", 302,\
 0, 0.0,0.0,0.0,0,560)
DeclareParameter("dcdc2.RonDiode", "Closed diode resistance [Ohm]", 303, 1E-05, \
0.0,1E+100,0.0,0,560)
DeclareParameter("dcdc2.GoffDiode", "Opened diode conductance [S]", 304, 1E-05, \
0.0,1E+100,0.0,0,560)
DeclareParameter("dcdc2.VkneeDiode", "Diode forward threshold voltage [V]", 305,\
 0, 0.0,1E+100,0.0,0,560)
DeclareAlias2("dcdc2.dc_p1.v", "Potential at the pin [V]", "simplifiedFuelCell1.pin_p.v", 1,\
 5, 1932, 4)
DeclareAlias2("dcdc2.dc_p1.i", "Current flowing into the pin [A]", \
"simplifiedFuelCell1.pin_p.i", -1, 5, 1933, 132)
DeclareAlias2("dcdc2.dc_n1.v", "Potential at the pin [V]", "simplifiedFuelCell1.pin_p1.v", 1,\
 5, 1944, 4)
DeclareAlias2("dcdc2.dc_n1.i", "Current flowing into the pin [A]", \
"simplifiedFuelCell1.pin_p1.i", -1, 5, 1945, 132)
DeclareVariable("dcdc2.vDC1", "DC voltage side 1 [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dcdc2.iDC1", "DC current side 1 [A]", "simplifiedFuelCell1.pin_p.i", -1,\
 5, 1933, 0)
DeclareVariable("dcdc2.powerDC1", "DC power side 1 [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("dcdc2.dc_p2.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("dcdc2.dc_p2.i", "Current flowing into the pin [A]", \
"inverter3.dc_p.i", 1, 5, 1960, 132)
DeclareAlias2("dcdc2.dc_n2.v", "Potential at the pin [V]", "simplifiedFuelCell1.pin_p1.v", 1,\
 5, 1944, 4)
DeclareAlias2("dcdc2.dc_n2.i", "Current flowing into the pin [A]", \
"inverter3.dc_n.i", 1, 5, 1962, 132)
DeclareVariable("dcdc2.vDC2", "DC voltages side 2 [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dcdc2.iDC2", "DC current side 2 [A]", "inverter3.dc_p.i", 1, 5, 1960,\
 0)
DeclareVariable("dcdc2.powerDC2", "DC power side 2 [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("dcdc2.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("dcdc2.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("dcdc2.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("dcdc2.T_heatPort", "Temperature of heatPort [K|degC]", 293.15, \
0.0,1E+100,300.0,0,513)
DeclareVariable("dcdc2.useConstantEnable", "true = disabled boolean input, use constantEnable [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("dcdc2.constantEnable", "Constant enabling of firing signals [:#(type=Boolean)]",\
 306, true, 0.0,0.0,0.0,0,562)
DeclareVariable("dcdc2.m", "Number of phases [:#(type=Integer)]", 1, 1.0,1E+100,\
0.0,0,517)
DeclareVariable("dcdc2.enableLogic.useConstantEnable", "true = disabled boolean input, use constantEnable [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("dcdc2.enableLogic.constantEnable", "Constant enabling of firing signals [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("dcdc2.enableLogic.m", "Number of phases [:#(type=Integer)]", 1,\
 1.0,1E+100,0.0,0,517)
DeclareVariable("dcdc2.enableLogic.enableConstantSource.k", "Constant output value [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("dcdc2.enableLogic.enableConstantSource.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "dcdc2.enableLogic.enableConstantSource.k", 1, 5, 2222, 65)
DeclareVariable("dcdc2.enableLogic.booleanReplicator.nout", "Number of outputs [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,517)
DeclareAlias2("dcdc2.enableLogic.booleanReplicator.u", "Connector of Boolean input signal [:#(type=Boolean)]",\
 "dcdc2.enableLogic.enableConstantSource.k", 1, 5, 2222, 65)
DeclareAlias2("dcdc2.enableLogic.booleanReplicator.y[1]", "Connector of Boolean output signals [:#(type=Boolean)]",\
 "dcdc2.enableLogic.enableConstantSource.k", 1, 5, 2222, 65)
DeclareAlias2("dcdc2.enableLogic.internalEnable[1]", "m replicated enable signals [:#(type=Boolean)]",\
 "dcdc2.enableLogic.enableConstantSource.k", 1, 5, 2222, 65)
DeclareAlias2("dcdc2.andCondition_p.u1", "Connector of first Boolean input signal [:#(type=Boolean)]",\
 "dcdc2.fire_p", 1, 5, 2225, 65)
DeclareAlias2("dcdc2.andCondition_p.u2", "Connector of second Boolean input signal [:#(type=Boolean)]",\
 "dcdc2.enableLogic.enableConstantSource.k", 1, 5, 2222, 65)
DeclareVariable("dcdc2.andCondition_p.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,642)
DeclareVariable("dcdc2.fire_p", "Firing signal of positive potential transistor [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,642)
DeclareVariable("dcdc2.transistor.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("dcdc2.transistor.i", "Current flowing from pin p to pin n [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dcdc2.transistor.p.v", "Potential at the pin [V]", \
"simplifiedFuelCell1.pin_p.v", 1, 5, 1932, 4)
DeclareAlias2("dcdc2.transistor.p.i", "Current flowing into the pin [A]", \
"dcdc2.transistor.i", 1, 5, 2227, 132)
DeclareAlias2("dcdc2.transistor.n.v", "Potential at the pin [V]", \
"simplifiedFuelCell1.pin_p1.v", 1, 5, 1944, 4)
DeclareAlias2("dcdc2.transistor.n.i", "Current flowing into the pin [A]", \
"dcdc2.transistor.i", -1, 5, 2227, 132)
DeclareVariable("dcdc2.transistor.Ron", "Forward state-on differential resistance (closed resistance) [Ohm]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("dcdc2.transistor.Goff", "Backward state-off conductance (opened conductance) [S]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("dcdc2.transistor.Vknee", "Forward threshold voltage [V]", 0.0, \
0.0,1E+100,0.0,0,513)
DeclareVariable("dcdc2.transistor.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("dcdc2.transistor.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 307, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("dcdc2.transistor.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dcdc2.transistor.T_heatPort", "Temperature of heatPort [K|degC]",\
 "dcdc2.transistor.T", 1, 7, 307, 0)
DeclareVariable("dcdc2.transistor.off", "Switching state [:#(type=Boolean)]", \
true, 0.0,0.0,0.0,0,706)
DeclareVariable("dcdc2.transistor.s", "Auxiliary variable for actual position on the ideal diode characteristic [1]",\
 0, 0.0,0.0,0.0,0,2560)
DeclareVariable("dcdc2.transistor.unitVoltage", "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("dcdc2.transistor.unitCurrent", "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("dcdc2.transistor.fire", "[:#(type=Boolean)]", "dcdc2.andCondition_p.y", 1,\
 5, 2224, 65)
DeclareVariable("dcdc2.diode.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dcdc2.diode.i", "Current flowing from pin p to pin n [A]", \
"inverter3.dc_p.i", -1, 5, 1960, 0)
DeclareAlias2("dcdc2.diode.p.v", "Potential at the pin [V]", "simplifiedFuelCell1.pin_p.v", 1,\
 5, 1932, 4)
DeclareAlias2("dcdc2.diode.p.i", "Current flowing into the pin [A]", \
"inverter3.dc_p.i", -1, 5, 1960, 132)
DeclareAlias2("dcdc2.diode.n.v", "Potential at the pin [V]", "dcdc2.dc_p2.v", 1,\
 5, 2210, 4)
DeclareAlias2("dcdc2.diode.n.i", "Current flowing into the pin [A]", \
"inverter3.dc_p.i", 1, 5, 1960, 132)
DeclareVariable("dcdc2.diode.Ron", "Forward state-on differential resistance (closed resistance) [Ohm]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("dcdc2.diode.Goff", "Backward state-off conductance (opened conductance) [S]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("dcdc2.diode.Vknee", "Forward threshold voltage [V]", 0.0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("dcdc2.diode.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("dcdc2.diode.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 308, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("dcdc2.diode.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dcdc2.diode.T_heatPort", "Temperature of heatPort [K|degC]", \
"dcdc2.diode.T", 1, 7, 308, 0)
DeclareVariable("dcdc2.diode.off", "Switching state [:#(type=Boolean)]", true, \
0.0,0.0,0.0,0,706)
DeclareVariable("dcdc2.diode.s", "Auxiliary variable for actual position on the ideal diode characteristic [1]",\
 0, 0.0,0.0,0.0,0,2560)
DeclareVariable("dcdc2.diode.unitVoltage", "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("dcdc2.diode.unitCurrent", "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("signalPWM4.useConstantDutyCycle", "Enables constant duty cycle [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("signalPWM4.constantDutyCycle", "Constant duty cycle", 309, 0.6,\
 0.0,0.0,0.0,0,560)
DeclareParameter("signalPWM4.f", "Switching frequency [Hz]", 310, 100, 0.0,0.0,\
0.0,0,560)
DeclareParameter("signalPWM4.startTime", "Start time [s]", 311, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("signalPWM4.fire", "Firing PWM signal [:#(type=Boolean)]", \
"dcdc2.fire_p", 1, 5, 2225, 65)
DeclareVariable("signalPWM4.notFire", "Firing PWM signal [:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,642)
DeclareVariable("signalPWM4.const.k", "Constant output value", 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("signalPWM4.const.y", "Connector of Real output signal", \
"signalPWM4.const.k", 1, 5, 2249, 0)
DeclareParameter("signalPWM4.limiter.uMax", "Upper limits of input signals", 312,\
 1, 0.0,0.0,0.0,0,560)
DeclareParameter("signalPWM4.limiter.uMin", "Lower limits of input signals", 313,\
 0, 0.0,0.0,0.0,0,560)
DeclareVariable("signalPWM4.limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("signalPWM4.limiter.homotopyType", "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("signalPWM4.limiter.limitsAtInit", "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("signalPWM4.limiter.u", "Connector of Real input signal", \
"signalPWM4.const.k", 1, 5, 2249, 0)
DeclareVariable("signalPWM4.limiter.y", "Connector of Real output signal", 0.0, \
0.0,0.0,0.0,0,513)
DeclareAlias2("signalPWM4.limiter.simplifiedExpr", "Simplified expression for homotopy-based initialization",\
 "signalPWM4.const.k", 1, 5, 2249, 1024)
DeclareVariable("signalPWM4.greaterEqual.u1", "Connector of first Real input signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("signalPWM4.greaterEqual.u2", "Connector of second Real input signal",\
 0.0, 0.0,0.0,0.0,0,640)
DeclareAlias2("signalPWM4.greaterEqual.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "dcdc2.fire_p", 1, 5, 2225, 65)
DeclareVariable("signalPWM4.zeroOrderHold.samplePeriod", "Sample period of component [s]",\
 0.1, 1E-13,1E+100,0.0,0,513)
DeclareVariable("signalPWM4.zeroOrderHold.startTime", "First sample time instant [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM4.zeroOrderHold.sampleTrigger", "True, if sample time instant [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2690)
DeclareVariable("signalPWM4.zeroOrderHold.firstTrigger", "Rising edge signals first sample instant [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2706)
DeclareAlias2("signalPWM4.zeroOrderHold.u", "Connector of Real input signal", \
"signalPWM4.limiter.y", 1, 5, 2253, 0)
DeclareAlias2("signalPWM4.zeroOrderHold.y", "Connector of Real output signal", \
"signalPWM4.greaterEqual.u2", 1, 5, 2255, 0)
DeclareVariable("signalPWM4.zeroOrderHold.ySample", "", 0, 0.0,0.0,0.0,0,656)
DeclareVariable("signalPWM4.sawtooth.amplitude", "Amplitude of saw tooth", 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM4.sawtooth.period", "Time for one period [s]", 1, \
1E-60,1E+100,0.0,0,513)
DeclareVariable("signalPWM4.sawtooth.nperiod", "Number of periods (< 0 means infinite number of periods) [:#(type=Integer)]",\
 -1, 0.0,0.0,0.0,0,517)
DeclareAlias2("signalPWM4.sawtooth.y", "Connector of Real output signal", \
"signalPWM4.greaterEqual.u1", 1, 5, 2254, 0)
DeclareVariable("signalPWM4.sawtooth.offset", "Offset of output signal y", 0, \
0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM4.sawtooth.startTime", "Output y = offset for time < startTime [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM4.sawtooth.T_start", "Start time of current period [s]",\
 0.0, 0.0,0.0,0.0,0,2688)
DeclareVariable("signalPWM4.sawtooth.count", "Period count [:#(type=Integer)]", 0,\
 0.0,0.0,0.0,0,2692)
DeclareAlias2("signalPWM4.inverse.u", "Connector of Boolean input signal [:#(type=Boolean)]",\
 "dcdc2.fire_p", 1, 5, 2225, 65)
DeclareAlias2("signalPWM4.inverse.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "signalPWM4.notFire", 1, 5, 2248, 65)
DeclareParameter("threePhaseMotor2.m", "Number of phases [:#(type=Integer)]", 314,\
 3, 0.0,0.0,0.0,0,564)
DeclareParameter("threePhaseMotor2.wref", "[rev/min]", 315, 4000, 0.0,0.0,0.0,0,560)
DeclareVariable("threePhaseMotor2.aimc.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("threePhaseMotor2.aimc.p", "Number of pole pairs (Integer) [:#(type=Integer)]",\
 2, 1.0,1E+100,0.0,0,517)
DeclareVariable("threePhaseMotor2.aimc.fsNominal", "Nominal frequency [Hz]", 50,\
 0.0,0.0,0.0,0,513)
DeclareParameter("threePhaseMotor2.aimc.TsOperational", "Operational temperature of stator resistance [K|degC]",\
 316, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("threePhaseMotor2.aimc.Rs", "Stator resistance per phase at TRef [Ohm]",\
 0.03, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.TsRef", "Reference temperature of stator resistance [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.alpha20s", "Temperature coefficient of stator resistance at 20 degC [1/K|1/K]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.Lszero", "Stator zero sequence inductance [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.Lssigma", "Stator stray inductance per phase [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.Jr", "Rotor's moment of inertia [kg.m2]",\
 0.29, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.useSupport", "Enable / disable (=fixed stator) support [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("threePhaseMotor2.aimc.Js", "Stator's moment of inertia [kg.m2]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.useThermalPort", "Enable / disable (=fixed temperatures) thermal port [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("threePhaseMotor2.aimc.frictionParameters.PRef", \
"Reference friction losses at wRef [W]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.frictionParameters.wRef", \
"Reference angular velocity that the PRef refer to [rad/s|rev/min]", 1E-60, \
1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.frictionParameters.power_w", \
"Exponent of friction torque w.r.t. angular velocity", 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.frictionParameters.tauRef", \
"Reference friction torque at reference angular velocity [N.m]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.frictionParameters.linear", \
"Linear angular velocity range with respect to reference angular velocity", \
0.001, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.frictionParameters.wLinear", \
"Linear angular velocity range [rad/s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.frictionParameters.tauLinear", \
"Torque corresponding with linear angular velocity range [N.m]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.phiMechanical", "Mechanical angle of rotor against stator [rad|deg]",\
 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor2.aimc.der(phiMechanical)", "der(Mechanical angle of rotor against stator) [rad/s]",\
 "fan2.inertia.w", 1, 1, 23, 0)
DeclareAlias2("threePhaseMotor2.aimc.wMechanical", "Mechanical angular velocity of rotor against stator [rad/s|rev/min]",\
 "fan2.inertia.w", 1, 1, 23, 0)
DeclareVariable("threePhaseMotor2.aimc.tauElectrical", "Electromagnetic torque [N.m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor2.aimc.tauShaft", "Shaft torque [N.m]", \
"threePhaseMotor2.flange1.tau", -1, 5, 2573, 0)
DeclareAlias2("threePhaseMotor2.aimc.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "variableSpeedDrive_ThreePhase2.speedSensor.flange.phi", 1, 1, 21, 4)
DeclareAlias2("threePhaseMotor2.aimc.flange.tau", "Cut torque in the flange [N.m]",\
 "threePhaseMotor2.flange1.tau", 1, 5, 2573, 132)
DeclareAlias2("threePhaseMotor2.aimc.inertiaRotor.flange_a.phi", \
"Absolute rotation angle of flange [rad|deg]", "variableSpeedDrive_ThreePhase2.speedSensor.flange.phi", 1,\
 1, 21, 4)
DeclareAlias2("threePhaseMotor2.aimc.inertiaRotor.flange_a.tau", \
"Cut torque in the flange [N.m]", "threePhaseMotor2.aimc.tauElectrical", 1, 5, 2288,\
 132)
DeclareAlias2("threePhaseMotor2.aimc.inertiaRotor.flange_b.phi", \
"Absolute rotation angle of flange [rad|deg]", "variableSpeedDrive_ThreePhase2.speedSensor.flange.phi", 1,\
 1, 21, 4)
DeclareAlias2("threePhaseMotor2.aimc.inertiaRotor.flange_b.tau", \
"Cut torque in the flange [N.m]", "threePhaseMotor2.flange1.tau", 1, 5, 2573, 132)
DeclareVariable("threePhaseMotor2.aimc.inertiaRotor.J", "Moment of inertia [kg.m2]",\
 1, 0.0,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.inertiaRotor.stateSelect", \
"Priority to use phi and w as states [:#(type=StateSelect)]", 3, 1.0,5.0,0.0,0,1541)
DeclareAlias2("threePhaseMotor2.aimc.inertiaRotor.phi", "Absolute rotation angle of component [rad|deg]",\
 "variableSpeedDrive_ThreePhase2.speedSensor.flange.phi", 1, 1, 21, 0)
DeclareAlias2("threePhaseMotor2.aimc.inertiaRotor.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 "fan2.inertia.w", 1, 1, 23, 0)
DeclareAlias2("threePhaseMotor2.aimc.inertiaRotor.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 "fan2.inertia.w", 1, 1, 23, 0)
DeclareAlias2("threePhaseMotor2.aimc.inertiaRotor.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 "fan2.inertia.der(w)", 1, 6, 23, 0)
DeclareAlias2("threePhaseMotor2.aimc.inertiaRotor.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "fan2.inertia.der(w)", 1, 6, 23, 0)
DeclareAlias2("threePhaseMotor2.aimc.inertiaStator.flange_a.phi", \
"Absolute rotation angle of flange [rad|deg]", "threePhaseMotor2.aimc.fixed.phi0", 1,\
 7, 317, 4)
DeclareVariable("threePhaseMotor2.aimc.inertiaStator.flange_a.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("threePhaseMotor2.aimc.inertiaStator.flange_b.phi", \
"Absolute rotation angle of flange [rad|deg]", "threePhaseMotor2.aimc.fixed.phi0", 1,\
 7, 317, 4)
DeclareVariable("threePhaseMotor2.aimc.inertiaStator.flange_b.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor2.aimc.inertiaStator.J", "Moment of inertia [kg.m2]",\
 1, 0.0,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.inertiaStator.stateSelect", \
"Priority to use phi and w as states [:#(type=StateSelect)]", 3, 1.0,5.0,0.0,0,1541)
DeclareAlias2("threePhaseMotor2.aimc.inertiaStator.phi", "Absolute rotation angle of component [rad|deg]",\
 "threePhaseMotor2.aimc.fixed.phi0", 1, 7, 317, 0)
DeclareVariable("threePhaseMotor2.aimc.inertiaStator.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.inertiaStator.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.inertiaStator.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.inertiaStator.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("threePhaseMotor2.aimc.fixed.phi0", "Fixed offset angle of housing [rad|deg]",\
 317, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("threePhaseMotor2.aimc.fixed.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "threePhaseMotor2.aimc.fixed.phi0", 1, 7, 317, 4)
DeclareAlias2("threePhaseMotor2.aimc.fixed.flange.tau", "Cut torque in the flange [N.m]",\
 "threePhaseMotor2.aimc.tauElectrical", -1, 5, 2288, 132)
DeclareAlias2("threePhaseMotor2.aimc.friction.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "variableSpeedDrive_ThreePhase2.speedSensor.flange.phi", 1, 1, 21, 4)
DeclareVariable("threePhaseMotor2.aimc.friction.flange.tau", "Cut torque in the flange [N.m]",\
 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("threePhaseMotor2.aimc.friction.support.phi", "Absolute rotation angle of flange [rad|deg]",\
 "threePhaseMotor2.aimc.fixed.phi0", 1, 7, 317, 4)
DeclareVariable("threePhaseMotor2.aimc.friction.support.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor2.aimc.friction.phi", "Angle between shaft and support [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor2.aimc.friction.der(phi)", "der(Angle between shaft and support) [rad/s]",\
 "fan2.inertia.w", 1, 1, 23, 0)
DeclareVariable("threePhaseMotor2.aimc.friction.tau", "Torque [N.m]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareAlias2("threePhaseMotor2.aimc.friction.w", "Relative angular velocity of flange and support [rad/s]",\
 "fan2.inertia.w", 1, 1, 23, 0)
DeclareVariable("threePhaseMotor2.aimc.friction.frictionParameters.PRef", \
"Reference friction losses at wRef [W]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.friction.frictionParameters.wRef", \
"Reference angular velocity that the PRef refer to [rad/s|rev/min]", 1E-60, \
1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.friction.frictionParameters.power_w", \
"Exponent of friction torque w.r.t. angular velocity", 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.friction.frictionParameters.tauRef", \
"Reference friction torque at reference angular velocity [N.m]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.friction.frictionParameters.linear", \
"Linear angular velocity range with respect to reference angular velocity", \
0.001, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.friction.frictionParameters.wLinear", \
"Linear angular velocity range [rad/s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.friction.frictionParameters.tauLinear", \
"Torque corresponding with linear angular velocity range [N.m]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.friction.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("threePhaseMotor2.aimc.friction.heatPort.T", "Port temperature [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("threePhaseMotor2.aimc.friction.heatPort.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor2.aimc.friction.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("threePhaseMotor2.aimc.internalSupport.phi", "Absolute rotation angle of flange [rad|deg]",\
 "threePhaseMotor2.aimc.fixed.phi0", 1, 7, 317, 1028)
DeclareVariable("threePhaseMotor2.aimc.internalSupport.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,2825)
DeclareVariable("threePhaseMotor2.aimc.statorCoreParameters.m", "Number of phases (1 for DC, 3 for induction machines) [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("threePhaseMotor2.aimc.statorCoreParameters.PRef", \
"Reference core losses at reference inner voltage VRef [W]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.statorCoreParameters.VRef", \
"Reference inner RMS voltage that reference core losses PRef refer to [V]", 100,\
 1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.statorCoreParameters.wRef", \
"Reference angular velocity that reference core losses PRef refer to [rad/s]", \
1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.statorCoreParameters.ratioHysteresis", \
"Ratio of hysteresis losses with respect to the total core losses at VRef and fRef",\
 0.0, 0.0,1.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.statorCoreParameters.GcRef", \
"Reference conductance at reference frequency and voltage [S]", 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("threePhaseMotor2.aimc.statorCoreParameters.wMin", "[rad/s]", \
0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.strayLoadParameters.PRef", \
"Reference stray load losses at IRef and wRef [W]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.strayLoadParameters.IRef", \
"Reference RMS current that PRef refers to [A]", 100, 1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.strayLoadParameters.wRef", \
"Reference angular velocity that PRef refers to [rad/s|rev/min]", 1E-60, 1E-60,\
1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.strayLoadParameters.power_w", \
"Exponent of stray load loss torque w.r.t. angular velocity", 1E-60, 1E-60,\
1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.strayLoadParameters.tauRef", \
"Reference stray load torque at reference angular velocity and reference current [N.m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.powerBalance.powerStator", \
"Electrical power (stator) [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.powerBalance.powerMechanical", \
"Mechanical power [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.powerBalance.powerInertiaStator", \
"Stator inertia power [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.powerBalance.powerInertiaRotor", \
"Rotor inertia power [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.powerBalance.lossPowerTotal", \
"Total loss power [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.powerBalance.lossPowerStatorWinding", \
"Stator copper losses [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.powerBalance.lossPowerStatorCore", \
"Stator core losses [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.powerBalance.lossPowerRotorCore", \
"Rotor core losses [W]", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.powerBalance.lossPowerStrayLoad", \
"Stray load losses [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.powerBalance.lossPowerFriction", \
"Friction losses [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.powerBalance.lossPowerRotorWinding", \
"Rotor copper losses [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.vs[1]", "Stator instantaneous voltages [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.vs[2]", "Stator instantaneous voltages [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.vs[3]", "Stator instantaneous voltages [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor2.aimc.is[1]", "Stator instantaneous currents [A]",\
 "inverter3.ac.pin[1].i", -1, 5, 1967, 0)
DeclareAlias2("threePhaseMotor2.aimc.is[2]", "Stator instantaneous currents [A]",\
 "inverter3.ac.pin[2].i", -1, 5, 1969, 0)
DeclareAlias2("threePhaseMotor2.aimc.is[3]", "Stator instantaneous currents [A]",\
 "inverter3.ac.pin[3].i", -1, 5, 1971, 0)
DeclareVariable("threePhaseMotor2.aimc.i_0_s", "Stator zero-sequence current [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.der(i_0_s)", "der(Stator zero-sequence current) [A/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("threePhaseMotor2.aimc.idq_ss[1]", "Stator space phasor current / stator fixed frame [A]",\
 "threePhaseMotor2.aimc.lssigma.i_[1]", 1, 5, 2401, 0)
DeclareAlias2("threePhaseMotor2.aimc.idq_ss[2]", "Stator space phasor current / stator fixed frame [A]",\
 "threePhaseMotor2.aimc.lssigma.i_[2]", 1, 5, 2402, 0)
DeclareState("threePhaseMotor2.aimc.idq_sr[1]", "Stator space phasor current / rotor fixed frame [A]",\
 17, 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("threePhaseMotor2.aimc.der(idq_sr[1])", "der(Stator space phasor current / rotor fixed frame) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("threePhaseMotor2.aimc.idq_sr[2]", "Stator space phasor current / rotor fixed frame [A]",\
 18, 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("threePhaseMotor2.aimc.der(idq_sr[2])", "der(Stator space phasor current / rotor fixed frame) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.idq_rs[1]", "Rotor space phasor current / stator fixed frame [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.idq_rs[2]", "Rotor space phasor current / stator fixed frame [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.der(idq_rs[1])", "der(Rotor space phasor current / stator fixed frame) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.der(idq_rs[2])", "der(Rotor space phasor current / stator fixed frame) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("threePhaseMotor2.aimc.idq_rr[1]", "Rotor space phasor current / rotor fixed frame [A]",\
 19, 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("threePhaseMotor2.aimc.der(idq_rr[1])", "der(Rotor space phasor current / rotor fixed frame) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("threePhaseMotor2.aimc.idq_rr[2]", "Rotor space phasor current / rotor fixed frame [A]",\
 20, 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("threePhaseMotor2.aimc.der(idq_rr[2])", "der(Rotor space phasor current / rotor fixed frame) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.plug_sp.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("threePhaseMotor2.aimc.plug_sp.pin[1].v", "Potential at the pin [V]",\
 "inverter3.ac.pin[1].v", 1, 5, 1966, 4)
DeclareAlias2("threePhaseMotor2.aimc.plug_sp.pin[1].i", "Current flowing into the pin [A]",\
 "inverter3.ac.pin[1].i", -1, 5, 1967, 132)
DeclareAlias2("threePhaseMotor2.aimc.plug_sp.pin[2].v", "Potential at the pin [V]",\
 "inverter3.ac.pin[2].v", 1, 5, 1968, 4)
DeclareAlias2("threePhaseMotor2.aimc.plug_sp.pin[2].i", "Current flowing into the pin [A]",\
 "inverter3.ac.pin[2].i", -1, 5, 1969, 132)
DeclareAlias2("threePhaseMotor2.aimc.plug_sp.pin[3].v", "Potential at the pin [V]",\
 "inverter3.ac.pin[3].v", 1, 5, 1970, 4)
DeclareAlias2("threePhaseMotor2.aimc.plug_sp.pin[3].i", "Current flowing into the pin [A]",\
 "inverter3.ac.pin[3].i", -1, 5, 1971, 132)
DeclareVariable("threePhaseMotor2.aimc.plug_sn.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareVariable("threePhaseMotor2.aimc.plug_sn.pin[1].v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("threePhaseMotor2.aimc.plug_sn.pin[1].i", "Current flowing into the pin [A]",\
 "inverter3.ac.pin[1].i", 1, 5, 1967, 132)
DeclareAlias2("threePhaseMotor2.aimc.plug_sn.pin[2].v", "Potential at the pin [V]",\
 "threePhaseMotor2.aimc.plug_sn.pin[1].v", 1, 5, 2349, 4)
DeclareAlias2("threePhaseMotor2.aimc.plug_sn.pin[2].i", "Current flowing into the pin [A]",\
 "inverter3.ac.pin[2].i", 1, 5, 1969, 132)
DeclareAlias2("threePhaseMotor2.aimc.plug_sn.pin[3].v", "Potential at the pin [V]",\
 "threePhaseMotor2.aimc.plug_sn.pin[1].v", 1, 5, 2349, 4)
DeclareAlias2("threePhaseMotor2.aimc.plug_sn.pin[3].i", "Current flowing into the pin [A]",\
 "inverter3.ac.pin[3].i", 1, 5, 1971, 132)
DeclareVariable("threePhaseMotor2.aimc.rs.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("threePhaseMotor2.aimc.rs.v[1]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.rs.v[2]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.rs.v[3]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor2.aimc.rs.i[1]", "Currents flowing into positive polyphase plugs [A]",\
 "inverter3.ac.pin[1].i", -1, 5, 1967, 0)
DeclareAlias2("threePhaseMotor2.aimc.rs.i[2]", "Currents flowing into positive polyphase plugs [A]",\
 "inverter3.ac.pin[2].i", -1, 5, 1969, 0)
DeclareAlias2("threePhaseMotor2.aimc.rs.i[3]", "Currents flowing into positive polyphase plugs [A]",\
 "inverter3.ac.pin[3].i", -1, 5, 1971, 0)
DeclareVariable("threePhaseMotor2.aimc.rs.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("threePhaseMotor2.aimc.rs.plug_p.pin[1].v", "Potential at the pin [V]",\
 "inverter3.ac.pin[1].v", 1, 5, 1966, 4)
DeclareAlias2("threePhaseMotor2.aimc.rs.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 "inverter3.ac.pin[1].i", -1, 5, 1967, 132)
DeclareAlias2("threePhaseMotor2.aimc.rs.plug_p.pin[2].v", "Potential at the pin [V]",\
 "inverter3.ac.pin[2].v", 1, 5, 1968, 4)
DeclareAlias2("threePhaseMotor2.aimc.rs.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 "inverter3.ac.pin[2].i", -1, 5, 1969, 132)
DeclareAlias2("threePhaseMotor2.aimc.rs.plug_p.pin[3].v", "Potential at the pin [V]",\
 "inverter3.ac.pin[3].v", 1, 5, 1970, 4)
DeclareAlias2("threePhaseMotor2.aimc.rs.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 "inverter3.ac.pin[3].i", -1, 5, 1971, 132)
DeclareVariable("threePhaseMotor2.aimc.rs.plug_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareVariable("threePhaseMotor2.aimc.rs.plug_n.pin[1].v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("threePhaseMotor2.aimc.rs.plug_n.pin[1].i", "Current flowing into the pin [A]",\
 "inverter3.ac.pin[1].i", 1, 5, 1967, 132)
DeclareVariable("threePhaseMotor2.aimc.rs.plug_n.pin[2].v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("threePhaseMotor2.aimc.rs.plug_n.pin[2].i", "Current flowing into the pin [A]",\
 "inverter3.ac.pin[2].i", 1, 5, 1969, 132)
DeclareVariable("threePhaseMotor2.aimc.rs.plug_n.pin[3].v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("threePhaseMotor2.aimc.rs.plug_n.pin[3].i", "Current flowing into the pin [A]",\
 "inverter3.ac.pin[3].i", 1, 5, 1971, 132)
DeclareVariable("threePhaseMotor2.aimc.rs.R[1]", "Resistances R_ref at temperatures T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.rs.R[2]", "Resistances R_ref at temperatures T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.rs.R[3]", "Resistances R_ref at temperatures T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.rs.T_ref[1]", "Reference temperatures [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.rs.T_ref[2]", "Reference temperatures [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.rs.T_ref[3]", "Reference temperatures [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.rs.alpha[1]", "Temperature coefficients of resistances at reference temperatures [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.rs.alpha[2]", "Temperature coefficients of resistances at reference temperatures [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.rs.alpha[3]", "Temperature coefficients of resistances at reference temperatures [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.rs.mh", "Number of heatPorts=number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("threePhaseMotor2.aimc.rs.useHeatPort", "=true, if all heat ports are enabled [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("threePhaseMotor2.aimc.rs.T[1]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.rs.T[2]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.rs.T[3]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("threePhaseMotor2.aimc.rs.heatPort[1].T", "Port temperature [K|degC]",\
 "threePhaseMotor2.aimc.thermalAmbient.constTs.k", 1, 5, 2505, 4)
DeclareAlias2("threePhaseMotor2.aimc.rs.heatPort[1].Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "threePhaseMotor2.aimc.rs.resistor[1].LossPower", -1, 5, 2379, 132)
DeclareAlias2("threePhaseMotor2.aimc.rs.heatPort[2].T", "Port temperature [K|degC]",\
 "threePhaseMotor2.aimc.thermalAmbient.constTs.k", 1, 5, 2505, 4)
DeclareAlias2("threePhaseMotor2.aimc.rs.heatPort[2].Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "threePhaseMotor2.aimc.rs.resistor[2].LossPower", -1, 5, 2387, 132)
DeclareAlias2("threePhaseMotor2.aimc.rs.heatPort[3].T", "Port temperature [K|degC]",\
 "threePhaseMotor2.aimc.thermalAmbient.constTs.k", 1, 5, 2505, 4)
DeclareAlias2("threePhaseMotor2.aimc.rs.heatPort[3].Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "threePhaseMotor2.aimc.rs.resistor[3].LossPower", -1, 5, 2395, 132)
DeclareVariable("threePhaseMotor2.aimc.rs.resistor[1].R", "Resistance at temperature T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.rs.resistor[1].T_ref", "Reference temperature [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.rs.resistor[1].alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.rs.resistor[1].v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor2.aimc.rs.resistor[1].i", "Current flowing from pin p to pin n [A]",\
 "inverter3.ac.pin[1].i", -1, 5, 1967, 0)
DeclareAlias2("threePhaseMotor2.aimc.rs.resistor[1].p.v", "Potential at the pin [V]",\
 "inverter3.ac.pin[1].v", 1, 5, 1966, 4)
DeclareAlias2("threePhaseMotor2.aimc.rs.resistor[1].p.i", "Current flowing into the pin [A]",\
 "inverter3.ac.pin[1].i", -1, 5, 1967, 132)
DeclareAlias2("threePhaseMotor2.aimc.rs.resistor[1].n.v", "Potential at the pin [V]",\
 "threePhaseMotor2.aimc.rs.plug_n.pin[1].v", 1, 5, 2356, 4)
DeclareAlias2("threePhaseMotor2.aimc.rs.resistor[1].n.i", "Current flowing into the pin [A]",\
 "inverter3.ac.pin[1].i", 1, 5, 1967, 132)
DeclareVariable("threePhaseMotor2.aimc.rs.resistor[1].useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("threePhaseMotor2.aimc.rs.resistor[1].T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("threePhaseMotor2.aimc.rs.resistor[1].heatPort.T", \
"Port temperature [K|degC]", "threePhaseMotor2.aimc.thermalAmbient.constTs.k", 1,\
 5, 2505, 4)
DeclareAlias2("threePhaseMotor2.aimc.rs.resistor[1].heatPort.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor2.aimc.rs.resistor[1].LossPower", -1, 5, 2379, 132)
DeclareVariable("threePhaseMotor2.aimc.rs.resistor[1].LossPower", \
"Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor2.aimc.rs.resistor[1].T_heatPort", \
"Temperature of heatPort [K|degC]", "threePhaseMotor2.aimc.thermalAmbient.constTs.k", 1,\
 5, 2505, 0)
DeclareVariable("threePhaseMotor2.aimc.rs.resistor[1].R_actual", \
"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]", 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("threePhaseMotor2.aimc.rs.resistor[2].R", "Resistance at temperature T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.rs.resistor[2].T_ref", "Reference temperature [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.rs.resistor[2].alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.rs.resistor[2].v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor2.aimc.rs.resistor[2].i", "Current flowing from pin p to pin n [A]",\
 "inverter3.ac.pin[2].i", -1, 5, 1969, 0)
DeclareAlias2("threePhaseMotor2.aimc.rs.resistor[2].p.v", "Potential at the pin [V]",\
 "inverter3.ac.pin[2].v", 1, 5, 1968, 4)
DeclareAlias2("threePhaseMotor2.aimc.rs.resistor[2].p.i", "Current flowing into the pin [A]",\
 "inverter3.ac.pin[2].i", -1, 5, 1969, 132)
DeclareAlias2("threePhaseMotor2.aimc.rs.resistor[2].n.v", "Potential at the pin [V]",\
 "threePhaseMotor2.aimc.rs.plug_n.pin[2].v", 1, 5, 2357, 4)
DeclareAlias2("threePhaseMotor2.aimc.rs.resistor[2].n.i", "Current flowing into the pin [A]",\
 "inverter3.ac.pin[2].i", 1, 5, 1969, 132)
DeclareVariable("threePhaseMotor2.aimc.rs.resistor[2].useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("threePhaseMotor2.aimc.rs.resistor[2].T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("threePhaseMotor2.aimc.rs.resistor[2].heatPort.T", \
"Port temperature [K|degC]", "threePhaseMotor2.aimc.thermalAmbient.constTs.k", 1,\
 5, 2505, 4)
DeclareAlias2("threePhaseMotor2.aimc.rs.resistor[2].heatPort.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor2.aimc.rs.resistor[2].LossPower", -1, 5, 2387, 132)
DeclareVariable("threePhaseMotor2.aimc.rs.resistor[2].LossPower", \
"Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor2.aimc.rs.resistor[2].T_heatPort", \
"Temperature of heatPort [K|degC]", "threePhaseMotor2.aimc.thermalAmbient.constTs.k", 1,\
 5, 2505, 0)
DeclareVariable("threePhaseMotor2.aimc.rs.resistor[2].R_actual", \
"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]", 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("threePhaseMotor2.aimc.rs.resistor[3].R", "Resistance at temperature T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.rs.resistor[3].T_ref", "Reference temperature [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.rs.resistor[3].alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.rs.resistor[3].v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor2.aimc.rs.resistor[3].i", "Current flowing from pin p to pin n [A]",\
 "inverter3.ac.pin[3].i", -1, 5, 1971, 0)
DeclareAlias2("threePhaseMotor2.aimc.rs.resistor[3].p.v", "Potential at the pin [V]",\
 "inverter3.ac.pin[3].v", 1, 5, 1970, 4)
DeclareAlias2("threePhaseMotor2.aimc.rs.resistor[3].p.i", "Current flowing into the pin [A]",\
 "inverter3.ac.pin[3].i", -1, 5, 1971, 132)
DeclareAlias2("threePhaseMotor2.aimc.rs.resistor[3].n.v", "Potential at the pin [V]",\
 "threePhaseMotor2.aimc.rs.plug_n.pin[3].v", 1, 5, 2358, 4)
DeclareAlias2("threePhaseMotor2.aimc.rs.resistor[3].n.i", "Current flowing into the pin [A]",\
 "inverter3.ac.pin[3].i", 1, 5, 1971, 132)
DeclareVariable("threePhaseMotor2.aimc.rs.resistor[3].useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("threePhaseMotor2.aimc.rs.resistor[3].T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("threePhaseMotor2.aimc.rs.resistor[3].heatPort.T", \
"Port temperature [K|degC]", "threePhaseMotor2.aimc.thermalAmbient.constTs.k", 1,\
 5, 2505, 4)
DeclareAlias2("threePhaseMotor2.aimc.rs.resistor[3].heatPort.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor2.aimc.rs.resistor[3].LossPower", -1, 5, 2395, 132)
DeclareVariable("threePhaseMotor2.aimc.rs.resistor[3].LossPower", \
"Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor2.aimc.rs.resistor[3].T_heatPort", \
"Temperature of heatPort [K|degC]", "threePhaseMotor2.aimc.thermalAmbient.constTs.k", 1,\
 5, 2505, 0)
DeclareVariable("threePhaseMotor2.aimc.rs.resistor[3].R_actual", \
"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]", 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("threePhaseMotor2.aimc.lssigma.L[1]", "Inductance of both axes [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.lssigma.L[2]", "Inductance of both axes [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.lssigma.v_[1]", "[V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.lssigma.v_[2]", "[V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.lssigma.i_[1]", "[A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.lssigma.i_[2]", "[A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.lssigma.der(i_[1])", "[A/s]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.lssigma.der(i_[2])", "[A/s]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.lssigma.spacePhasor_a.v_[1]", \
"1=real, 2=imaginary part [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareVariable("threePhaseMotor2.aimc.lssigma.spacePhasor_a.v_[2]", \
"1=real, 2=imaginary part [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("threePhaseMotor2.aimc.lssigma.spacePhasor_a.i_[1]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor2.aimc.lssigma.i_[1]", 1, 5, 2401,\
 132)
DeclareAlias2("threePhaseMotor2.aimc.lssigma.spacePhasor_a.i_[2]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor2.aimc.lssigma.i_[2]", 1, 5, 2402,\
 132)
DeclareAlias2("threePhaseMotor2.aimc.lssigma.spacePhasor_b.v_[1]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor2.aimc.airGapS.der(psi_ms[1])", 1,\
 5, 2531, 4)
DeclareAlias2("threePhaseMotor2.aimc.lssigma.spacePhasor_b.v_[2]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor2.aimc.airGapS.der(psi_ms[2])", 1,\
 5, 2532, 4)
DeclareAlias2("threePhaseMotor2.aimc.lssigma.spacePhasor_b.i_[1]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor2.aimc.lssigma.i_[1]", -1, 5, 2401,\
 132)
DeclareAlias2("threePhaseMotor2.aimc.lssigma.spacePhasor_b.i_[2]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor2.aimc.lssigma.i_[2]", -1, 5, 2402,\
 132)
DeclareVariable("threePhaseMotor2.aimc.lszero.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.lszero.i", "Current flowing from pin p to pin n [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.lszero.der(i)", "der(Current flowing from pin p to pin n) [A/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.lszero.p.v", "Potential at the pin [V]", \
0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("threePhaseMotor2.aimc.lszero.p.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor2.aimc.lszero.n.v", "Potential at the pin [V]", 0,\
 0.0,0.0,0.0,0,521)
DeclareVariable("threePhaseMotor2.aimc.lszero.n.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor2.aimc.lszero.L", "Inductance [H]", 1, 0.0,0.0,\
0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.statorCore.coreParameters.m", \
"Number of phases (1 for DC, 3 for induction machines) [:#(type=Integer)]", 3, \
0.0,0.0,0.0,0,517)
DeclareVariable("threePhaseMotor2.aimc.statorCore.coreParameters.PRef", \
"Reference core losses at reference inner voltage VRef [W]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.statorCore.coreParameters.VRef", \
"Reference inner RMS voltage that reference core losses PRef refer to [V]", \
1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.statorCore.coreParameters.wRef", \
"Reference angular velocity that reference core losses PRef refer to [rad/s]", \
1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.statorCore.coreParameters.ratioHysteresis",\
 "Ratio of hysteresis losses with respect to the total core losses at VRef and fRef",\
 0.0, 0.0,1.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.statorCore.coreParameters.GcRef", \
"Reference conductance at reference frequency and voltage [S]", 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("threePhaseMotor2.aimc.statorCore.coreParameters.wMin", \
"[rad/s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.statorCore.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("threePhaseMotor2.aimc.statorCore.turnsRatio", "Effective number of stator turns / effective number of rotor turns (if used as rotor core)",\
 1, 1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.statorCore.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("threePhaseMotor2.aimc.statorCore.heatPort.T", "Port temperature [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("threePhaseMotor2.aimc.statorCore.heatPort.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor2.aimc.statorCore.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("threePhaseMotor2.aimc.statorCore.spacePhasor.v_[1]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor2.aimc.lssigma.spacePhasor_a.v_[1]", 1,\
 5, 2405, 4)
DeclareAlias2("threePhaseMotor2.aimc.statorCore.spacePhasor.v_[2]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor2.aimc.lssigma.spacePhasor_a.v_[2]", 1,\
 5, 2406, 4)
DeclareVariable("threePhaseMotor2.aimc.statorCore.spacePhasor.i_[1]", \
"1=real, 2=imaginary part [A]", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor2.aimc.statorCore.spacePhasor.i_[2]", \
"1=real, 2=imaginary part [A]", 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("threePhaseMotor2.aimc.statorCore.w", "Remagnetization angular velocity [rad/s]",\
 "threePhaseMotor2.aimc.statorCoreParameters.wRef", 1, 5, 2318, 0)
DeclareVariable("threePhaseMotor2.aimc.statorCore.Gc", "Variable core loss conductance [S]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.statorCore.wLimit", "Limited angular velocity [rad/s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor2.aimc.spacePhasorS.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("threePhaseMotor2.aimc.spacePhasorS.turnsRatio", \
"Turns ratio [1]", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.spacePhasorS.v[1]", "Instantaneous phase voltages [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.spacePhasorS.v[2]", "Instantaneous phase voltages [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.spacePhasorS.v[3]", "Instantaneous phase voltages [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor2.aimc.spacePhasorS.i[1]", "Instantaneous phase currents [A]",\
 "inverter3.ac.pin[1].i", -1, 5, 1967, 0)
DeclareAlias2("threePhaseMotor2.aimc.spacePhasorS.i[2]", "Instantaneous phase currents [A]",\
 "inverter3.ac.pin[2].i", -1, 5, 1969, 0)
DeclareAlias2("threePhaseMotor2.aimc.spacePhasorS.i[3]", "Instantaneous phase currents [A]",\
 "inverter3.ac.pin[3].i", -1, 5, 1971, 0)
DeclareVariable("threePhaseMotor2.aimc.spacePhasorS.TransformationMatrix[1, 1]",\
 "[1]", 0.6666666666666666, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor2.aimc.spacePhasorS.TransformationMatrix[1, 2]",\
 "[1]", -0.33333333333333315, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor2.aimc.spacePhasorS.TransformationMatrix[1, 3]",\
 "[1]", -0.3333333333333336, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor2.aimc.spacePhasorS.TransformationMatrix[2, 1]",\
 "[1]", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor2.aimc.spacePhasorS.TransformationMatrix[2, 2]",\
 "[1]", 0.5773502691896257, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor2.aimc.spacePhasorS.TransformationMatrix[2, 3]",\
 "[1]", -0.5773502691896255, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor2.aimc.spacePhasorS.InverseTransformation[1, 1]",\
 "", 1.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor2.aimc.spacePhasorS.InverseTransformation[1, 2]",\
 "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor2.aimc.spacePhasorS.InverseTransformation[2, 1]",\
 "", -0.4999999999999998, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor2.aimc.spacePhasorS.InverseTransformation[2, 2]",\
 "", 0.8660254037844387, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor2.aimc.spacePhasorS.InverseTransformation[3, 1]",\
 "", -0.5000000000000004, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor2.aimc.spacePhasorS.InverseTransformation[3, 2]",\
 "", -0.8660254037844384, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor2.aimc.spacePhasorS.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("threePhaseMotor2.aimc.spacePhasorS.plug_p.pin[1].v", \
"Potential at the pin [V]", "threePhaseMotor2.aimc.rs.plug_n.pin[1].v", 1, 5, 2356,\
 4)
DeclareAlias2("threePhaseMotor2.aimc.spacePhasorS.plug_p.pin[1].i", \
"Current flowing into the pin [A]", "inverter3.ac.pin[1].i", -1, 5, 1967, 132)
DeclareAlias2("threePhaseMotor2.aimc.spacePhasorS.plug_p.pin[2].v", \
"Potential at the pin [V]", "threePhaseMotor2.aimc.rs.plug_n.pin[2].v", 1, 5, 2357,\
 4)
DeclareAlias2("threePhaseMotor2.aimc.spacePhasorS.plug_p.pin[2].i", \
"Current flowing into the pin [A]", "inverter3.ac.pin[2].i", -1, 5, 1969, 132)
DeclareAlias2("threePhaseMotor2.aimc.spacePhasorS.plug_p.pin[3].v", \
"Potential at the pin [V]", "threePhaseMotor2.aimc.rs.plug_n.pin[3].v", 1, 5, 2358,\
 4)
DeclareAlias2("threePhaseMotor2.aimc.spacePhasorS.plug_p.pin[3].i", \
"Current flowing into the pin [A]", "inverter3.ac.pin[3].i", -1, 5, 1971, 132)
DeclareVariable("threePhaseMotor2.aimc.spacePhasorS.plug_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("threePhaseMotor2.aimc.spacePhasorS.plug_n.pin[1].v", \
"Potential at the pin [V]", "threePhaseMotor2.aimc.plug_sn.pin[1].v", 1, 5, 2349,\
 4)
DeclareAlias2("threePhaseMotor2.aimc.spacePhasorS.plug_n.pin[1].i", \
"Current flowing into the pin [A]", "inverter3.ac.pin[1].i", 1, 5, 1967, 132)
DeclareAlias2("threePhaseMotor2.aimc.spacePhasorS.plug_n.pin[2].v", \
"Potential at the pin [V]", "threePhaseMotor2.aimc.plug_sn.pin[1].v", 1, 5, 2349,\
 4)
DeclareAlias2("threePhaseMotor2.aimc.spacePhasorS.plug_n.pin[2].i", \
"Current flowing into the pin [A]", "inverter3.ac.pin[2].i", 1, 5, 1969, 132)
DeclareAlias2("threePhaseMotor2.aimc.spacePhasorS.plug_n.pin[3].v", \
"Potential at the pin [V]", "threePhaseMotor2.aimc.plug_sn.pin[1].v", 1, 5, 2349,\
 4)
DeclareAlias2("threePhaseMotor2.aimc.spacePhasorS.plug_n.pin[3].i", \
"Current flowing into the pin [A]", "inverter3.ac.pin[3].i", 1, 5, 1971, 132)
DeclareVariable("threePhaseMotor2.aimc.spacePhasorS.zero.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("threePhaseMotor2.aimc.spacePhasorS.zero.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor2.aimc.spacePhasorS.ground.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("threePhaseMotor2.aimc.spacePhasorS.ground.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("threePhaseMotor2.aimc.spacePhasorS.spacePhasor.v_[1]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor2.aimc.lssigma.spacePhasor_a.v_[1]", 1,\
 5, 2405, 4)
DeclareAlias2("threePhaseMotor2.aimc.spacePhasorS.spacePhasor.v_[2]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor2.aimc.lssigma.spacePhasor_a.v_[2]", 1,\
 5, 2406, 4)
DeclareAlias2("threePhaseMotor2.aimc.spacePhasorS.spacePhasor.i_[1]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor2.aimc.lssigma.i_[1]", -1, 5, 2401,\
 132)
DeclareAlias2("threePhaseMotor2.aimc.spacePhasorS.spacePhasor.i_[2]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor2.aimc.lssigma.i_[2]", -1, 5, 2402,\
 132)
DeclareVariable("threePhaseMotor2.aimc.strayLoad.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("threePhaseMotor2.aimc.strayLoad.v[1]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.strayLoad.v[2]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.strayLoad.v[3]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("threePhaseMotor2.aimc.strayLoad.i[1]", "Currents flowing into positive polyphase plugs [A]",\
 "inverter3.ac.pin[1].i", -1, 5, 1967, 0)
DeclareAlias2("threePhaseMotor2.aimc.strayLoad.i[2]", "Currents flowing into positive polyphase plugs [A]",\
 "inverter3.ac.pin[2].i", -1, 5, 1969, 0)
DeclareAlias2("threePhaseMotor2.aimc.strayLoad.i[3]", "Currents flowing into positive polyphase plugs [A]",\
 "inverter3.ac.pin[3].i", -1, 5, 1971, 0)
DeclareVariable("threePhaseMotor2.aimc.strayLoad.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("threePhaseMotor2.aimc.strayLoad.plug_p.pin[1].v", \
"Potential at the pin [V]", "inverter3.ac.pin[1].v", 1, 5, 1966, 4)
DeclareAlias2("threePhaseMotor2.aimc.strayLoad.plug_p.pin[1].i", \
"Current flowing into the pin [A]", "inverter3.ac.pin[1].i", -1, 5, 1967, 132)
DeclareAlias2("threePhaseMotor2.aimc.strayLoad.plug_p.pin[2].v", \
"Potential at the pin [V]", "inverter3.ac.pin[2].v", 1, 5, 1968, 4)
DeclareAlias2("threePhaseMotor2.aimc.strayLoad.plug_p.pin[2].i", \
"Current flowing into the pin [A]", "inverter3.ac.pin[2].i", -1, 5, 1969, 132)
DeclareAlias2("threePhaseMotor2.aimc.strayLoad.plug_p.pin[3].v", \
"Potential at the pin [V]", "inverter3.ac.pin[3].v", 1, 5, 1970, 4)
DeclareAlias2("threePhaseMotor2.aimc.strayLoad.plug_p.pin[3].i", \
"Current flowing into the pin [A]", "inverter3.ac.pin[3].i", -1, 5, 1971, 132)
DeclareVariable("threePhaseMotor2.aimc.strayLoad.plug_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("threePhaseMotor2.aimc.strayLoad.plug_n.pin[1].v", \
"Potential at the pin [V]", "inverter3.ac.pin[1].v", 1, 5, 1966, 4)
DeclareAlias2("threePhaseMotor2.aimc.strayLoad.plug_n.pin[1].i", \
"Current flowing into the pin [A]", "inverter3.ac.pin[1].i", 1, 5, 1967, 132)
DeclareAlias2("threePhaseMotor2.aimc.strayLoad.plug_n.pin[2].v", \
"Potential at the pin [V]", "inverter3.ac.pin[2].v", 1, 5, 1968, 4)
DeclareAlias2("threePhaseMotor2.aimc.strayLoad.plug_n.pin[2].i", \
"Current flowing into the pin [A]", "inverter3.ac.pin[2].i", 1, 5, 1969, 132)
DeclareAlias2("threePhaseMotor2.aimc.strayLoad.plug_n.pin[3].v", \
"Potential at the pin [V]", "inverter3.ac.pin[3].v", 1, 5, 1970, 4)
DeclareAlias2("threePhaseMotor2.aimc.strayLoad.plug_n.pin[3].i", \
"Current flowing into the pin [A]", "inverter3.ac.pin[3].i", 1, 5, 1971, 132)
DeclareAlias2("threePhaseMotor2.aimc.strayLoad.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "variableSpeedDrive_ThreePhase2.speedSensor.flange.phi", 1, 1, 21, 4)
DeclareVariable("threePhaseMotor2.aimc.strayLoad.flange.tau", "Cut torque in the flange [N.m]",\
 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("threePhaseMotor2.aimc.strayLoad.support.phi", "Absolute rotation angle of flange [rad|deg]",\
 "threePhaseMotor2.aimc.fixed.phi0", 1, 7, 317, 4)
DeclareVariable("threePhaseMotor2.aimc.strayLoad.support.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor2.aimc.strayLoad.phi", "Angle between shaft and support [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor2.aimc.strayLoad.der(phi)", "der(Angle between shaft and support) [rad/s]",\
 "fan2.inertia.w", 1, 1, 23, 0)
DeclareVariable("threePhaseMotor2.aimc.strayLoad.tau", "Torque [N.m]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareAlias2("threePhaseMotor2.aimc.strayLoad.w", "Relative angular velocity of flange and support [rad/s]",\
 "fan2.inertia.w", 1, 1, 23, 0)
DeclareVariable("threePhaseMotor2.aimc.strayLoad.strayLoadParameters.PRef", \
"Reference stray load losses at IRef and wRef [W]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.strayLoad.strayLoadParameters.IRef", \
"Reference RMS current that PRef refers to [A]", 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.strayLoad.strayLoadParameters.wRef", \
"Reference angular velocity that PRef refers to [rad/s|rev/min]", 1E-60, 1E-60,\
1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.strayLoad.strayLoadParameters.power_w", \
"Exponent of stray load loss torque w.r.t. angular velocity", 1E-60, 1E-60,\
1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.strayLoad.strayLoadParameters.tauRef", \
"Reference stray load torque at reference angular velocity and reference current [N.m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.strayLoad.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("threePhaseMotor2.aimc.strayLoad.heatPort.T", "Port temperature [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("threePhaseMotor2.aimc.strayLoad.heatPort.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor2.aimc.strayLoad.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.strayLoad.iRMS", "[A]", 0.0, 0.0,0.0,0.0,\
0,512)
DeclareVariable("threePhaseMotor2.aimc.thermalAmbient.m", "Number of stator phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("threePhaseMotor2.aimc.thermalAmbient.useTemperatureInputs", \
"If true, temperature inputs are used; else, temperatures are constant [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("threePhaseMotor2.aimc.thermalAmbient.TDefault", \
"Default temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.thermalAmbient.Ts", "Temperature of stator windings [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.thermalAmbient.Q_flowStatorWinding", \
"Heat flow rate of stator windings [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.thermalAmbient.Q_flowStatorCore", \
"Heat flow rate of stator core losses [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.thermalAmbient.Q_flowRotorCore", \
"Heat flow rate of stator core losses [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.thermalAmbient.Q_flowStrayLoad", \
"Heat flow rate of stray load losses [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.thermalAmbient.Q_flowFriction", \
"Heat flow rate of friction losses [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.thermalAmbient.thermalPort.m", \
"Number of stator phases [:#(type=Integer)]", 3, 0.0,0.0,0.0,0,525)
DeclareAlias2("threePhaseMotor2.aimc.thermalAmbient.thermalPort.heatPortStatorWinding[1].T",\
 "Port temperature [K|degC]", "threePhaseMotor2.aimc.thermalAmbient.constTs.k", 1,\
 5, 2505, 4)
DeclareAlias2("threePhaseMotor2.aimc.thermalAmbient.thermalPort.heatPortStatorWinding[1].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor2.aimc.rs.resistor[1].LossPower", 1, 5, 2379, 132)
DeclareAlias2("threePhaseMotor2.aimc.thermalAmbient.thermalPort.heatPortStatorWinding[2].T",\
 "Port temperature [K|degC]", "threePhaseMotor2.aimc.thermalAmbient.constTs.k", 1,\
 5, 2505, 4)
DeclareAlias2("threePhaseMotor2.aimc.thermalAmbient.thermalPort.heatPortStatorWinding[2].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor2.aimc.rs.resistor[2].LossPower", 1, 5, 2387, 132)
DeclareAlias2("threePhaseMotor2.aimc.thermalAmbient.thermalPort.heatPortStatorWinding[3].T",\
 "Port temperature [K|degC]", "threePhaseMotor2.aimc.thermalAmbient.constTs.k", 1,\
 5, 2505, 4)
DeclareAlias2("threePhaseMotor2.aimc.thermalAmbient.thermalPort.heatPortStatorWinding[3].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor2.aimc.rs.resistor[3].LossPower", 1, 5, 2395, 132)
DeclareVariable("threePhaseMotor2.aimc.thermalAmbient.thermalPort.heatPortStatorCore.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("threePhaseMotor2.aimc.thermalAmbient.thermalPort.heatPortStatorCore.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor2.aimc.thermalAmbient.thermalPort.heatPortRotorCore.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("threePhaseMotor2.aimc.thermalAmbient.thermalPort.heatPortRotorCore.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor2.aimc.thermalAmbient.thermalPort.heatPortStrayLoad.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("threePhaseMotor2.aimc.thermalAmbient.thermalPort.heatPortStrayLoad.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor2.aimc.thermalAmbient.thermalPort.heatPortFriction.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("threePhaseMotor2.aimc.thermalAmbient.thermalPort.heatPortFriction.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareAlias2("threePhaseMotor2.aimc.thermalAmbient.thermalPort.heatPortRotorWinding.T",\
 "Port temperature [K|degC]", "threePhaseMotor2.aimc.thermalAmbient.constTr.k", 1,\
 5, 2509, 4)
DeclareAlias2("threePhaseMotor2.aimc.thermalAmbient.thermalPort.heatPortRotorWinding.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor2.aimc.powerBalance.lossPowerRotorWinding", 1, 5, 2337, 132)
DeclareAlias2("threePhaseMotor2.aimc.thermalAmbient.temperatureStatorWinding.port.T",\
 "Port temperature [K|degC]", "threePhaseMotor2.aimc.thermalAmbient.constTs.k", 1,\
 5, 2505, 4)
DeclareAlias2("threePhaseMotor2.aimc.thermalAmbient.temperatureStatorWinding.port.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor2.aimc.thermalAmbient.Q_flowStatorWinding", 1, 5, 2479, 132)
DeclareAlias2("threePhaseMotor2.aimc.thermalAmbient.temperatureStatorWinding.T",\
 "[K]", "threePhaseMotor2.aimc.thermalAmbient.constTs.k", 1, 5, 2505, 0)
DeclareVariable("threePhaseMotor2.aimc.thermalAmbient.temperatureStatorCore.T", \
"Fixed temperature at port [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.thermalAmbient.temperatureStatorCore.port.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("threePhaseMotor2.aimc.thermalAmbient.temperatureStatorCore.port.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor2.aimc.thermalAmbient.temperatureRotorCore.T", \
"Fixed temperature at port [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.thermalAmbient.temperatureRotorCore.port.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("threePhaseMotor2.aimc.thermalAmbient.temperatureRotorCore.port.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor2.aimc.thermalAmbient.temperatureStrayLoad.T", \
"Fixed temperature at port [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.thermalAmbient.temperatureStrayLoad.port.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("threePhaseMotor2.aimc.thermalAmbient.temperatureStrayLoad.port.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor2.aimc.thermalAmbient.temperatureFriction.T", \
"Fixed temperature at port [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.thermalAmbient.temperatureFriction.port.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("threePhaseMotor2.aimc.thermalAmbient.temperatureFriction.port.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor2.aimc.thermalAmbient.constTs.k", \
"Constant output value [K]", 1, 0.0,1E+100,300.0,0,513)
DeclareAlias2("threePhaseMotor2.aimc.thermalAmbient.constTs.y", "Connector of Real output signal [K]",\
 "threePhaseMotor2.aimc.thermalAmbient.constTs.k", 1, 5, 2505, 0)
DeclareVariable("threePhaseMotor2.aimc.thermalAmbient.thermalCollectorStator.m",\
 "Number of collected heat flows [:#(type=Integer)]", 3, 1.0,1E+100,0.0,0,517)
DeclareAlias2("threePhaseMotor2.aimc.thermalAmbient.thermalCollectorStator.port_a[1].T",\
 "Port temperature [K|degC]", "threePhaseMotor2.aimc.thermalAmbient.constTs.k", 1,\
 5, 2505, 4)
DeclareAlias2("threePhaseMotor2.aimc.thermalAmbient.thermalCollectorStator.port_a[1].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor2.aimc.rs.resistor[1].LossPower", 1, 5, 2379, 132)
DeclareAlias2("threePhaseMotor2.aimc.thermalAmbient.thermalCollectorStator.port_a[2].T",\
 "Port temperature [K|degC]", "threePhaseMotor2.aimc.thermalAmbient.constTs.k", 1,\
 5, 2505, 4)
DeclareAlias2("threePhaseMotor2.aimc.thermalAmbient.thermalCollectorStator.port_a[2].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor2.aimc.rs.resistor[2].LossPower", 1, 5, 2387, 132)
DeclareAlias2("threePhaseMotor2.aimc.thermalAmbient.thermalCollectorStator.port_a[3].T",\
 "Port temperature [K|degC]", "threePhaseMotor2.aimc.thermalAmbient.constTs.k", 1,\
 5, 2505, 4)
DeclareAlias2("threePhaseMotor2.aimc.thermalAmbient.thermalCollectorStator.port_a[3].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor2.aimc.rs.resistor[3].LossPower", 1, 5, 2395, 132)
DeclareAlias2("threePhaseMotor2.aimc.thermalAmbient.thermalCollectorStator.port_b.T",\
 "Port temperature [K|degC]", "threePhaseMotor2.aimc.thermalAmbient.constTs.k", 1,\
 5, 2505, 4)
DeclareAlias2("threePhaseMotor2.aimc.thermalAmbient.thermalCollectorStator.port_b.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor2.aimc.thermalAmbient.Q_flowStatorWinding", -1, 5, 2479, 132)
DeclareVariable("threePhaseMotor2.aimc.thermalAmbient.Tr", "Temperature of rotor (squirrel cage) [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("threePhaseMotor2.aimc.thermalAmbient.Q_flowRotorWinding", \
"Heat flow rate of rotor (squirrel cage) [W]", "threePhaseMotor2.aimc.powerBalance.lossPowerRotorWinding", 1,\
 5, 2337, 0)
DeclareVariable("threePhaseMotor2.aimc.thermalAmbient.Q_flowTotal", "[W]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor2.aimc.thermalAmbient.temperatureRotorWinding.port.T",\
 "Port temperature [K|degC]", "threePhaseMotor2.aimc.thermalAmbient.constTr.k", 1,\
 5, 2509, 4)
DeclareAlias2("threePhaseMotor2.aimc.thermalAmbient.temperatureRotorWinding.port.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor2.aimc.powerBalance.lossPowerRotorWinding", 1, 5, 2337, 132)
DeclareAlias2("threePhaseMotor2.aimc.thermalAmbient.temperatureRotorWinding.T", \
"[K]", "threePhaseMotor2.aimc.thermalAmbient.constTr.k", 1, 5, 2509, 0)
DeclareVariable("threePhaseMotor2.aimc.thermalAmbient.constTr.k", \
"Constant output value [K]", 1, 0.0,1E+100,300.0,0,513)
DeclareAlias2("threePhaseMotor2.aimc.thermalAmbient.constTr.y", "Connector of Real output signal [K]",\
 "threePhaseMotor2.aimc.thermalAmbient.constTr.k", 1, 5, 2509, 0)
DeclareVariable("threePhaseMotor2.aimc.pi", "", 3.141592653589793, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor2.aimc.internalThermalPort.m", "Number of stator phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,2573)
DeclareAlias2("threePhaseMotor2.aimc.internalThermalPort.heatPortStatorWinding[1].T",\
 "Port temperature [K|degC]", "threePhaseMotor2.aimc.thermalAmbient.constTs.k", 1,\
 5, 2505, 1028)
DeclareVariable("threePhaseMotor2.aimc.internalThermalPort.heatPortStatorWinding[1].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareAlias2("threePhaseMotor2.aimc.internalThermalPort.heatPortStatorWinding[2].T",\
 "Port temperature [K|degC]", "threePhaseMotor2.aimc.thermalAmbient.constTs.k", 1,\
 5, 2505, 1028)
DeclareVariable("threePhaseMotor2.aimc.internalThermalPort.heatPortStatorWinding[2].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareAlias2("threePhaseMotor2.aimc.internalThermalPort.heatPortStatorWinding[3].T",\
 "Port temperature [K|degC]", "threePhaseMotor2.aimc.thermalAmbient.constTs.k", 1,\
 5, 2505, 1028)
DeclareVariable("threePhaseMotor2.aimc.internalThermalPort.heatPortStatorWinding[3].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareVariable("threePhaseMotor2.aimc.internalThermalPort.heatPortStatorCore.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,2569)
DeclareVariable("threePhaseMotor2.aimc.internalThermalPort.heatPortStatorCore.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareVariable("threePhaseMotor2.aimc.internalThermalPort.heatPortRotorCore.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,2569)
DeclareVariable("threePhaseMotor2.aimc.internalThermalPort.heatPortRotorCore.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareVariable("threePhaseMotor2.aimc.internalThermalPort.heatPortStrayLoad.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,2569)
DeclareVariable("threePhaseMotor2.aimc.internalThermalPort.heatPortStrayLoad.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareVariable("threePhaseMotor2.aimc.internalThermalPort.heatPortFriction.T", \
"Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,2569)
DeclareVariable("threePhaseMotor2.aimc.internalThermalPort.heatPortFriction.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareAlias2("threePhaseMotor2.aimc.internalThermalPort.heatPortRotorWinding.T",\
 "Port temperature [K|degC]", "threePhaseMotor2.aimc.thermalAmbient.constTr.k", 1,\
 5, 2509, 1028)
DeclareVariable("threePhaseMotor2.aimc.internalThermalPort.heatPortRotorWinding.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareAlias2("threePhaseMotor2.aimc.ir[1]", "Rotor cage currents [A]", \
"threePhaseMotor2.aimc.idq_rr[1]", 1, 1, 19, 0)
DeclareAlias2("threePhaseMotor2.aimc.ir[2]", "Rotor cage currents [A]", \
"threePhaseMotor2.aimc.idq_rr[2]", 1, 1, 20, 0)
DeclareVariable("threePhaseMotor2.aimc.airGapS.Lm", "Main field inductance [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.airGapS.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("threePhaseMotor2.aimc.airGapS.p", "Number of pole pairs [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareAlias2("threePhaseMotor2.aimc.airGapS.tauElectrical", "[N.m]", \
"threePhaseMotor2.aimc.tauElectrical", 1, 5, 2288, 0)
DeclareVariable("threePhaseMotor2.aimc.airGapS.gamma", "Rotor displacement angle [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.airGapS.der(gamma)", "der(Rotor displacement angle) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor2.aimc.airGapS.i_ss[1]", "Stator current space phasor with respect to the stator fixed frame [A]",\
 "threePhaseMotor2.aimc.lssigma.i_[1]", 1, 5, 2401, 0)
DeclareAlias2("threePhaseMotor2.aimc.airGapS.i_ss[2]", "Stator current space phasor with respect to the stator fixed frame [A]",\
 "threePhaseMotor2.aimc.lssigma.i_[2]", 1, 5, 2402, 0)
DeclareAlias2("threePhaseMotor2.aimc.airGapS.i_sr[1]", "Stator current space phasor with respect to the rotor fixed frame [A]",\
 "threePhaseMotor2.aimc.idq_sr[1]", 1, 1, 17, 0)
DeclareAlias2("threePhaseMotor2.aimc.airGapS.i_sr[2]", "Stator current space phasor with respect to the rotor fixed frame [A]",\
 "threePhaseMotor2.aimc.idq_sr[2]", 1, 1, 18, 0)
DeclareAlias2("threePhaseMotor2.aimc.airGapS.i_rs[1]", "Rotor current space phasor with respect to the stator fixed frame [A]",\
 "threePhaseMotor2.aimc.idq_rs[1]", 1, 5, 2343, 0)
DeclareAlias2("threePhaseMotor2.aimc.airGapS.i_rs[2]", "Rotor current space phasor with respect to the stator fixed frame [A]",\
 "threePhaseMotor2.aimc.idq_rs[2]", 1, 5, 2344, 0)
DeclareAlias2("threePhaseMotor2.aimc.airGapS.i_rr[1]", "Rotor current space phasor with respect to the rotor fixed frame [A]",\
 "threePhaseMotor2.aimc.idq_rr[1]", 1, 1, 19, 0)
DeclareAlias2("threePhaseMotor2.aimc.airGapS.i_rr[2]", "Rotor current space phasor with respect to the rotor fixed frame [A]",\
 "threePhaseMotor2.aimc.idq_rr[2]", 1, 1, 20, 0)
DeclareVariable("threePhaseMotor2.aimc.airGapS.psi_ms[1]", "Magnetizing flux phasor with respect to the stator fixed frame [Wb]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.airGapS.psi_ms[2]", "Magnetizing flux phasor with respect to the stator fixed frame [Wb]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.airGapS.der(psi_ms[1])", "der(Magnetizing flux phasor with respect to the stator fixed frame) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.airGapS.der(psi_ms[2])", "der(Magnetizing flux phasor with respect to the stator fixed frame) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.airGapS.psi_mr[1]", "Magnetizing flux phasor with respect to the rotor fixed frame [Wb]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.airGapS.psi_mr[2]", "Magnetizing flux phasor with respect to the rotor fixed frame [Wb]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.airGapS.der(psi_mr[1])", "der(Magnetizing flux phasor with respect to the rotor fixed frame) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.airGapS.der(psi_mr[2])", "der(Magnetizing flux phasor with respect to the rotor fixed frame) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.airGapS.RotationMatrix[1, 1]", \
"Matrix of rotation from rotor to stator [1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.airGapS.RotationMatrix[1, 2]", \
"Matrix of rotation from rotor to stator [1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.airGapS.RotationMatrix[2, 1]", \
"Matrix of rotation from rotor to stator [1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.airGapS.RotationMatrix[2, 2]", \
"Matrix of rotation from rotor to stator [1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.airGapS.der(RotationMatrix[1, 1])", \
"der(Matrix of rotation from rotor to stator) [s-1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.airGapS.der(RotationMatrix[1, 2])", \
"der(Matrix of rotation from rotor to stator) [s-1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.airGapS.der(RotationMatrix[2, 1])", \
"der(Matrix of rotation from rotor to stator) [s-1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.airGapS.der(RotationMatrix[2, 2])", \
"der(Matrix of rotation from rotor to stator) [s-1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("threePhaseMotor2.aimc.airGapS.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "variableSpeedDrive_ThreePhase2.speedSensor.flange.phi", 1, 1, 21, 4)
DeclareAlias2("threePhaseMotor2.aimc.airGapS.flange.tau", "Cut torque in the flange [N.m]",\
 "threePhaseMotor2.aimc.tauElectrical", -1, 5, 2288, 132)
DeclareAlias2("threePhaseMotor2.aimc.airGapS.support.phi", "Absolute rotation angle of flange [rad|deg]",\
 "threePhaseMotor2.aimc.fixed.phi0", 1, 7, 317, 4)
DeclareAlias2("threePhaseMotor2.aimc.airGapS.support.tau", "Cut torque in the flange [N.m]",\
 "threePhaseMotor2.aimc.tauElectrical", 1, 5, 2288, 132)
DeclareAlias2("threePhaseMotor2.aimc.airGapS.spacePhasor_s.v_[1]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor2.aimc.airGapS.der(psi_ms[1])", 1,\
 5, 2531, 4)
DeclareAlias2("threePhaseMotor2.aimc.airGapS.spacePhasor_s.v_[2]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor2.aimc.airGapS.der(psi_ms[2])", 1,\
 5, 2532, 4)
DeclareAlias2("threePhaseMotor2.aimc.airGapS.spacePhasor_s.i_[1]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor2.aimc.lssigma.i_[1]", 1, 5, 2401,\
 132)
DeclareAlias2("threePhaseMotor2.aimc.airGapS.spacePhasor_s.i_[2]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor2.aimc.lssigma.i_[2]", 1, 5, 2402,\
 132)
DeclareAlias2("threePhaseMotor2.aimc.airGapS.spacePhasor_r.v_[1]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor2.aimc.airGapS.der(psi_mr[1])", 1,\
 5, 2535, 4)
DeclareAlias2("threePhaseMotor2.aimc.airGapS.spacePhasor_r.v_[2]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor2.aimc.airGapS.der(psi_mr[2])", 1,\
 5, 2536, 4)
DeclareAlias2("threePhaseMotor2.aimc.airGapS.spacePhasor_r.i_[1]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor2.aimc.idq_rr[1]", 1, 1, 19, 132)
DeclareAlias2("threePhaseMotor2.aimc.airGapS.spacePhasor_r.i_[2]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor2.aimc.idq_rr[2]", 1, 1, 20, 132)
DeclareVariable("threePhaseMotor2.aimc.airGapS.i_ms[1]", "Magnetizing current space phasor with respect to the stator fixed frame [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.airGapS.i_ms[2]", "Magnetizing current space phasor with respect to the stator fixed frame [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.airGapS.der(i_ms[1])", "der(Magnetizing current space phasor with respect to the stator fixed frame) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.airGapS.der(i_ms[2])", "der(Magnetizing current space phasor with respect to the stator fixed frame) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("threePhaseMotor2.aimc.airGapS.L[1, 1]", "Inductance matrix [H]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor2.aimc.airGapS.L[1, 2]", "Inductance matrix [H]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor2.aimc.airGapS.L[2, 1]", "Inductance matrix [H]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor2.aimc.airGapS.L[2, 2]", "Inductance matrix [H]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("threePhaseMotor2.aimc.Lm", "Stator main field inductance per phase [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.Lrsigma", "Rotor stray inductance per phase (equivalent three phase winding) [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.Rr", "Rotor resistance per phase (equivalent three phase winding) at TRef [Ohm]",\
 0.04, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.TrRef", "Reference temperature of rotor resistance [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.alpha20r", "Temperature coefficient of rotor resistance at 20 degC [1/K]",\
 0, 0.0,0.0,0.0,0,513)
DeclareParameter("threePhaseMotor2.aimc.TrOperational", "Operational temperature of rotor resistance [K|degC]",\
 318, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("threePhaseMotor2.aimc.squirrelCageR.Lrsigma", "Rotor stray inductance per phase translated to stator [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.squirrelCageR.Rr", "Rotor resistance per phase translated to stator at T_ref [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.squirrelCageR.T_ref", "Reference temperature [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.squirrelCageR.alpha", "Temperature coefficient of resistance at T_ref [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimc.squirrelCageR.useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("threePhaseMotor2.aimc.squirrelCageR.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("threePhaseMotor2.aimc.squirrelCageR.heatPort.T", "Port temperature [K|degC]",\
 "threePhaseMotor2.aimc.thermalAmbient.constTr.k", 1, 5, 2509, 4)
DeclareAlias2("threePhaseMotor2.aimc.squirrelCageR.heatPort.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"threePhaseMotor2.aimc.powerBalance.lossPowerRotorWinding", -1, 5, 2337, 132)
DeclareAlias2("threePhaseMotor2.aimc.squirrelCageR.LossPower", "Loss power leaving component via heatPort [W]",\
 "threePhaseMotor2.aimc.powerBalance.lossPowerRotorWinding", 1, 5, 2337, 0)
DeclareAlias2("threePhaseMotor2.aimc.squirrelCageR.T_heatPort", "Temperature of heatPort [K|degC]",\
 "threePhaseMotor2.aimc.thermalAmbient.constTr.k", 1, 5, 2509, 0)
DeclareVariable("threePhaseMotor2.aimc.squirrelCageR.Rr_actual", \
"Actual resistance = Rr*(1 + alpha*(T_heatPort - T_ref)) [Ohm]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareAlias2("threePhaseMotor2.aimc.squirrelCageR.spacePhasor_r.v_[1]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor2.aimc.airGapS.der(psi_mr[1])", 1,\
 5, 2535, 4)
DeclareAlias2("threePhaseMotor2.aimc.squirrelCageR.spacePhasor_r.v_[2]", \
"1=real, 2=imaginary part [V]", "threePhaseMotor2.aimc.airGapS.der(psi_mr[2])", 1,\
 5, 2536, 4)
DeclareAlias2("threePhaseMotor2.aimc.squirrelCageR.spacePhasor_r.i_[1]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor2.aimc.idq_rr[1]", -1, 1, 19, 132)
DeclareAlias2("threePhaseMotor2.aimc.squirrelCageR.spacePhasor_r.i_[2]", \
"1=real, 2=imaginary part [A]", "threePhaseMotor2.aimc.idq_rr[2]", -1, 1, 20, 132)
DeclareAlias2("threePhaseMotor2.aimc.squirrelCageR.spacePhasor_r.der(i_[1])", \
"der(1=real, 2=imaginary part) [A/s]", "threePhaseMotor2.aimc.der(idq_rr[1])", -1,\
 6, 19, 4)
DeclareAlias2("threePhaseMotor2.aimc.squirrelCageR.spacePhasor_r.der(i_[2])", \
"der(1=real, 2=imaginary part) [A/s]", "threePhaseMotor2.aimc.der(idq_rr[2])", -1,\
 6, 20, 4)
DeclareAlias2("threePhaseMotor2.aimc.squirrelCageR.i[1]", "Currents out from squirrel cage [A]",\
 "threePhaseMotor2.aimc.idq_rr[1]", 1, 1, 19, 0)
DeclareAlias2("threePhaseMotor2.aimc.squirrelCageR.i[2]", "Currents out from squirrel cage [A]",\
 "threePhaseMotor2.aimc.idq_rr[2]", 1, 1, 20, 0)
DeclareVariable("threePhaseMotor2.terminalBox.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("threePhaseMotor2.terminalBox.plug_sp.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("threePhaseMotor2.terminalBox.plug_sp.pin[1].v", "Potential at the pin [V]",\
 "inverter3.ac.pin[1].v", 1, 5, 1966, 4)
DeclareAlias2("threePhaseMotor2.terminalBox.plug_sp.pin[1].i", "Current flowing into the pin [A]",\
 "inverter3.ac.pin[1].i", 1, 5, 1967, 132)
DeclareAlias2("threePhaseMotor2.terminalBox.plug_sp.pin[2].v", "Potential at the pin [V]",\
 "inverter3.ac.pin[2].v", 1, 5, 1968, 4)
DeclareAlias2("threePhaseMotor2.terminalBox.plug_sp.pin[2].i", "Current flowing into the pin [A]",\
 "inverter3.ac.pin[2].i", 1, 5, 1969, 132)
DeclareAlias2("threePhaseMotor2.terminalBox.plug_sp.pin[3].v", "Potential at the pin [V]",\
 "inverter3.ac.pin[3].v", 1, 5, 1970, 4)
DeclareAlias2("threePhaseMotor2.terminalBox.plug_sp.pin[3].i", "Current flowing into the pin [A]",\
 "inverter3.ac.pin[3].i", 1, 5, 1971, 132)
DeclareVariable("threePhaseMotor2.terminalBox.plug_sn.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("threePhaseMotor2.terminalBox.plug_sn.pin[1].v", "Potential at the pin [V]",\
 "threePhaseMotor2.aimc.plug_sn.pin[1].v", 1, 5, 2349, 4)
DeclareAlias2("threePhaseMotor2.terminalBox.plug_sn.pin[1].i", "Current flowing into the pin [A]",\
 "inverter3.ac.pin[1].i", -1, 5, 1967, 132)
DeclareAlias2("threePhaseMotor2.terminalBox.plug_sn.pin[2].v", "Potential at the pin [V]",\
 "threePhaseMotor2.aimc.plug_sn.pin[1].v", 1, 5, 2349, 4)
DeclareAlias2("threePhaseMotor2.terminalBox.plug_sn.pin[2].i", "Current flowing into the pin [A]",\
 "inverter3.ac.pin[2].i", -1, 5, 1969, 132)
DeclareAlias2("threePhaseMotor2.terminalBox.plug_sn.pin[3].v", "Potential at the pin [V]",\
 "threePhaseMotor2.aimc.plug_sn.pin[1].v", 1, 5, 2349, 4)
DeclareAlias2("threePhaseMotor2.terminalBox.plug_sn.pin[3].i", "Current flowing into the pin [A]",\
 "inverter3.ac.pin[3].i", -1, 5, 1971, 132)
DeclareVariable("threePhaseMotor2.terminalBox.star.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("threePhaseMotor2.terminalBox.star.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("threePhaseMotor2.terminalBox.star.plug_p.pin[1].v", \
"Potential at the pin [V]", "threePhaseMotor2.aimc.plug_sn.pin[1].v", 1, 5, 2349,\
 4)
DeclareAlias2("threePhaseMotor2.terminalBox.star.plug_p.pin[1].i", \
"Current flowing into the pin [A]", "inverter3.ac.pin[1].i", -1, 5, 1967, 132)
DeclareAlias2("threePhaseMotor2.terminalBox.star.plug_p.pin[2].v", \
"Potential at the pin [V]", "threePhaseMotor2.aimc.plug_sn.pin[1].v", 1, 5, 2349,\
 4)
DeclareAlias2("threePhaseMotor2.terminalBox.star.plug_p.pin[2].i", \
"Current flowing into the pin [A]", "inverter3.ac.pin[2].i", -1, 5, 1969, 132)
DeclareAlias2("threePhaseMotor2.terminalBox.star.plug_p.pin[3].v", \
"Potential at the pin [V]", "threePhaseMotor2.aimc.plug_sn.pin[1].v", 1, 5, 2349,\
 4)
DeclareAlias2("threePhaseMotor2.terminalBox.star.plug_p.pin[3].i", \
"Current flowing into the pin [A]", "inverter3.ac.pin[3].i", -1, 5, 1971, 132)
DeclareAlias2("threePhaseMotor2.terminalBox.star.pin_n.v", "Potential at the pin [V]",\
 "threePhaseMotor2.aimc.plug_sn.pin[1].v", 1, 5, 2349, 4)
DeclareVariable("threePhaseMotor2.terminalBox.star.pin_n.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("threePhaseMotor2.terminalBox.plugSupply.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("threePhaseMotor2.terminalBox.plugSupply.pin[1].v", \
"Potential at the pin [V]", "inverter3.ac.pin[1].v", 1, 5, 1966, 4)
DeclareAlias2("threePhaseMotor2.terminalBox.plugSupply.pin[1].i", \
"Current flowing into the pin [A]", "inverter3.ac.pin[1].i", -1, 5, 1967, 132)
DeclareAlias2("threePhaseMotor2.terminalBox.plugSupply.pin[2].v", \
"Potential at the pin [V]", "inverter3.ac.pin[2].v", 1, 5, 1968, 4)
DeclareAlias2("threePhaseMotor2.terminalBox.plugSupply.pin[2].i", \
"Current flowing into the pin [A]", "inverter3.ac.pin[2].i", -1, 5, 1969, 132)
DeclareAlias2("threePhaseMotor2.terminalBox.plugSupply.pin[3].v", \
"Potential at the pin [V]", "inverter3.ac.pin[3].v", 1, 5, 1970, 4)
DeclareAlias2("threePhaseMotor2.terminalBox.plugSupply.pin[3].i", \
"Current flowing into the pin [A]", "inverter3.ac.pin[3].i", -1, 5, 1971, 132)
DeclareAlias2("threePhaseMotor2.terminalBox.starpoint.v", "Potential at the pin [V]",\
 "threePhaseMotor2.aimc.plug_sn.pin[1].v", 1, 5, 2349, 4)
DeclareVariable("threePhaseMotor2.terminalBox.starpoint.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("threePhaseMotor2.flange1.phi", "Absolute rotation angle of flange [rad|deg]",\
 "variableSpeedDrive_ThreePhase2.speedSensor.flange.phi", 1, 1, 21, 4)
DeclareVariable("threePhaseMotor2.flange1.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("threePhaseMotor2.aimcData.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareParameter("threePhaseMotor2.aimcData.Jr", "Rotor's moment of inertia [kg.m2]",\
 319, 0.29, 0.0,0.0,0.0,0,560)
DeclareVariable("threePhaseMotor2.aimcData.Js", "Stator's moment of inertia [kg.m2]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("threePhaseMotor2.aimcData.p", "Number of pole pairs (Integer) [:#(type=Integer)]",\
 320, 2, 1.0,1E+100,0.0,0,564)
DeclareParameter("threePhaseMotor2.aimcData.fsNominal", "Nominal frequency [Hz]",\
 321, 50, 0.0,0.0,0.0,0,560)
DeclareParameter("threePhaseMotor2.aimcData.Rs", "Stator resistance per phase at TRef [Ohm]",\
 322, 0.03, 0.0,0.0,0.0,0,560)
DeclareParameter("threePhaseMotor2.aimcData.TsRef", "Reference temperature of stator resistance [K|degC]",\
 323, 293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("threePhaseMotor2.aimcData.alpha20s", "Temperature coefficient of stator resistance at 20 degC [1/K]",\
 324, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("threePhaseMotor2.aimcData.effectiveStatorTurns", \
"Effective number of stator turns", 325, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("threePhaseMotor2.aimcData.Lszero", "Stator zero sequence inductance [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimcData.Lssigma", "Stator stray inductance per phase [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimcData.frictionParameters.PRef", \
"Reference friction losses at wRef [W]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimcData.frictionParameters.wRef", \
"Reference angular velocity that the PRef refer to [rad/s|rev/min]", 1E-60, \
1E-60,1E+100,0.0,0,513)
DeclareParameter("threePhaseMotor2.aimcData.frictionParameters.power_w", \
"Exponent of friction torque w.r.t. angular velocity", 326, 2, 1E-60,1E+100,0.0,\
0,560)
DeclareVariable("threePhaseMotor2.aimcData.frictionParameters.tauRef", \
"Reference friction torque at reference angular velocity [N.m]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("threePhaseMotor2.aimcData.frictionParameters.linear", \
"Linear angular velocity range with respect to reference angular velocity [1]", \
0.001, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimcData.frictionParameters.wLinear", \
"Linear angular velocity range [rad/s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimcData.frictionParameters.tauLinear", \
"Torque corresponding with linear angular velocity range [N.m]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("threePhaseMotor2.aimcData.statorCoreParameters.m", \
"Number of phases (1 for DC, 3 for induction machines) [:#(type=Integer)]", 3, \
0.0,0.0,0.0,0,517)
DeclareVariable("threePhaseMotor2.aimcData.statorCoreParameters.PRef", \
"Reference core losses at reference inner voltage VRef [W]", 0, 0.0,1E+100,0.0,0,513)
DeclareParameter("threePhaseMotor2.aimcData.statorCoreParameters.VRef", \
"Reference inner RMS voltage that reference core losses PRef refer to [V]", 327,\
 100, 1E-60,1E+100,0.0,0,560)
DeclareVariable("threePhaseMotor2.aimcData.statorCoreParameters.wRef", \
"Reference angular velocity that reference core losses PRef refer to [rad/s]", \
1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimcData.statorCoreParameters.ratioHysteresis",\
 "Ratio of hysteresis losses with respect to the total core losses at VRef and fRef",\
 0, 0.0,1.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimcData.statorCoreParameters.GcRef", \
"Reference conductance at reference frequency and voltage [S]", 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("threePhaseMotor2.aimcData.statorCoreParameters.wMin", "[rad/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimcData.strayLoadParameters.PRef", \
"Reference stray load losses at IRef and wRef [W]", 0, 0.0,1E+100,0.0,0,513)
DeclareParameter("threePhaseMotor2.aimcData.strayLoadParameters.IRef", \
"Reference RMS current that PRef refers to [A]", 328, 100, 1E-60,1E+100,0.0,0,560)
DeclareVariable("threePhaseMotor2.aimcData.strayLoadParameters.wRef", \
"Reference angular velocity that PRef refers to [rad/s|rev/min]", 1E-60, 1E-60,\
1E+100,0.0,0,513)
DeclareParameter("threePhaseMotor2.aimcData.strayLoadParameters.power_w", \
"Exponent of stray load loss torque w.r.t. angular velocity", 329, 1, 1E-60,\
1E+100,0.0,0,560)
DeclareVariable("threePhaseMotor2.aimcData.strayLoadParameters.tauRef", \
"Reference stray load torque at reference angular velocity and reference current [N.m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimcData.Lm", "Stator main field inductance per phase [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("threePhaseMotor2.aimcData.Lrsigma", "Rotor stray inductance per phase (equivalent three phase winding) [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("threePhaseMotor2.aimcData.Rr", "Rotor resistance per phase (equivalent three phase winding) at TRef [Ohm]",\
 330, 0.04, 0.0,0.0,0.0,0,560)
DeclareParameter("threePhaseMotor2.aimcData.TrRef", "Reference temperature of rotor resistance [K|degC]",\
 331, 293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("threePhaseMotor2.aimcData.alpha20r", "Temperature coefficient of rotor resistance at 20 degC [1/K]",\
 332, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("threePhaseMotor2.plug_p1.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("threePhaseMotor2.plug_p1.pin[1].v", "Potential at the pin [V]", \
"inverter3.ac.pin[1].v", 1, 5, 1966, 4)
DeclareAlias2("threePhaseMotor2.plug_p1.pin[1].i", "Current flowing into the pin [A]",\
 "inverter3.ac.pin[1].i", -1, 5, 1967, 132)
DeclareAlias2("threePhaseMotor2.plug_p1.pin[2].v", "Potential at the pin [V]", \
"inverter3.ac.pin[2].v", 1, 5, 1968, 4)
DeclareAlias2("threePhaseMotor2.plug_p1.pin[2].i", "Current flowing into the pin [A]",\
 "inverter3.ac.pin[2].i", -1, 5, 1969, 132)
DeclareAlias2("threePhaseMotor2.plug_p1.pin[3].v", "Potential at the pin [V]", \
"inverter3.ac.pin[3].v", 1, 5, 1970, 4)
DeclareAlias2("threePhaseMotor2.plug_p1.pin[3].i", "Current flowing into the pin [A]",\
 "inverter3.ac.pin[3].i", -1, 5, 1971, 132)
DeclareVariable("threePhaseMotor2.rpm", "Reference speed of the generator [rad/s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("signalPWM5[1].useConstantDutyCycle", "Enables constant duty cycle [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("signalPWM5[1].constantDutyCycle", "Constant duty cycle", 333, 0,\
 0.0,0.0,0.0,0,560)
DeclareParameter("signalPWM5[1].f", "Switching frequency [Hz|kHz]", 334, 100000,\
 0.0,0.0,0.0,0,560)
DeclareParameter("signalPWM5[1].startTime", "Start time [s]", 335, 0, 0.0,0.0,\
0.0,0,560)
DeclareAlias2("signalPWM5[1].dutyCycle", "Duty cycle [rad/s]", "variableSpeedDrive_ThreePhase2.y1[1]", 1,\
 5, 2660, 0)
DeclareAlias2("signalPWM5[1].fire", "Firing PWM signal [:#(type=Boolean)]", \
"inverter3.fire_n[1]", 1, 5, 1956, 65)
DeclareAlias2("signalPWM5[1].notFire", "Firing PWM signal [:#(type=Boolean)]", \
"inverter3.fire_p[1]", 1, 5, 1948, 65)
DeclareParameter("signalPWM5[1].limiter.uMax", "Upper limits of input signals [rad/s]",\
 336, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("signalPWM5[1].limiter.uMin", "Lower limits of input signals [rad/s]",\
 337, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("signalPWM5[1].limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("signalPWM5[1].limiter.homotopyType", "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("signalPWM5[1].limiter.limitsAtInit", "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("signalPWM5[1].limiter.u", "Connector of Real input signal [rad/s]",\
 "variableSpeedDrive_ThreePhase2.y1[1]", 1, 5, 2660, 0)
DeclareVariable("signalPWM5[1].limiter.y", "Connector of Real output signal [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("signalPWM5[1].limiter.simplifiedExpr", "Simplified expression for homotopy-based initialization [rad/s]",\
 "variableSpeedDrive_ThreePhase2.y1[1]", 1, 5, 2660, 1024)
DeclareVariable("signalPWM5[1].greaterEqual.u1", "Connector of first Real input signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("signalPWM5[1].greaterEqual.u2", "Connector of second Real input signal [rad/s]",\
 0.0, 0.0,0.0,0.0,0,640)
DeclareAlias2("signalPWM5[1].greaterEqual.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter3.fire_n[1]", 1, 5, 1956, 65)
DeclareVariable("signalPWM5[1].zeroOrderHold.samplePeriod", "Sample period of component [s]",\
 0.1, 1E-13,1E+100,0.0,0,513)
DeclareVariable("signalPWM5[1].zeroOrderHold.startTime", "First sample time instant [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM5[1].zeroOrderHold.sampleTrigger", "True, if sample time instant [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2690)
DeclareVariable("signalPWM5[1].zeroOrderHold.firstTrigger", "Rising edge signals first sample instant [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2706)
DeclareAlias2("signalPWM5[1].zeroOrderHold.u", "Connector of Real input signal [rad/s]",\
 "signalPWM5[1].limiter.y", 1, 5, 2601, 0)
DeclareAlias2("signalPWM5[1].zeroOrderHold.y", "Connector of Real output signal [rad/s]",\
 "signalPWM5[1].greaterEqual.u2", 1, 5, 2603, 0)
DeclareVariable("signalPWM5[1].zeroOrderHold.ySample", "[rad/s]", 0, 0.0,0.0,0.0,\
0,656)
DeclareVariable("signalPWM5[1].sawtooth.amplitude", "Amplitude of saw tooth", 1,\
 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM5[1].sawtooth.period", "Time for one period [s]", 1, \
1E-60,1E+100,0.0,0,513)
DeclareVariable("signalPWM5[1].sawtooth.nperiod", "Number of periods (< 0 means infinite number of periods) [:#(type=Integer)]",\
 -1, 0.0,0.0,0.0,0,517)
DeclareAlias2("signalPWM5[1].sawtooth.y", "Connector of Real output signal", \
"signalPWM5[1].greaterEqual.u1", 1, 5, 2602, 0)
DeclareVariable("signalPWM5[1].sawtooth.offset", "Offset of output signal y", 0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM5[1].sawtooth.startTime", "Output y = offset for time < startTime [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM5[1].sawtooth.T_start", "Start time of current period [s]",\
 0.0, 0.0,0.0,0.0,0,2688)
DeclareVariable("signalPWM5[1].sawtooth.count", "Period count [:#(type=Integer)]",\
 0, 0.0,0.0,0.0,0,2692)
DeclareAlias2("signalPWM5[1].inverse.u", "Connector of Boolean input signal [:#(type=Boolean)]",\
 "inverter3.fire_n[1]", 1, 5, 1956, 65)
DeclareAlias2("signalPWM5[1].inverse.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter3.fire_p[1]", 1, 5, 1948, 65)
DeclareVariable("signalPWM5[2].useConstantDutyCycle", "Enables constant duty cycle [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("signalPWM5[2].constantDutyCycle", "Constant duty cycle", 338, 0,\
 0.0,0.0,0.0,0,560)
DeclareParameter("signalPWM5[2].f", "Switching frequency [Hz|kHz]", 339, 100000,\
 0.0,0.0,0.0,0,560)
DeclareParameter("signalPWM5[2].startTime", "Start time [s]", 340, 0, 0.0,0.0,\
0.0,0,560)
DeclareAlias2("signalPWM5[2].dutyCycle", "Duty cycle [rad/s]", "variableSpeedDrive_ThreePhase2.y1[1]", 1,\
 5, 2660, 0)
DeclareAlias2("signalPWM5[2].fire", "Firing PWM signal [:#(type=Boolean)]", \
"inverter3.fire_n[2]", 1, 5, 1957, 65)
DeclareAlias2("signalPWM5[2].notFire", "Firing PWM signal [:#(type=Boolean)]", \
"inverter3.fire_p[2]", 1, 5, 1949, 65)
DeclareParameter("signalPWM5[2].limiter.uMax", "Upper limits of input signals [rad/s]",\
 341, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("signalPWM5[2].limiter.uMin", "Lower limits of input signals [rad/s]",\
 342, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("signalPWM5[2].limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("signalPWM5[2].limiter.homotopyType", "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("signalPWM5[2].limiter.limitsAtInit", "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("signalPWM5[2].limiter.u", "Connector of Real input signal [rad/s]",\
 "variableSpeedDrive_ThreePhase2.y1[1]", 1, 5, 2660, 0)
DeclareVariable("signalPWM5[2].limiter.y", "Connector of Real output signal [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("signalPWM5[2].limiter.simplifiedExpr", "Simplified expression for homotopy-based initialization [rad/s]",\
 "variableSpeedDrive_ThreePhase2.y1[1]", 1, 5, 2660, 1024)
DeclareVariable("signalPWM5[2].greaterEqual.u1", "Connector of first Real input signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("signalPWM5[2].greaterEqual.u2", "Connector of second Real input signal [rad/s]",\
 0.0, 0.0,0.0,0.0,0,640)
DeclareAlias2("signalPWM5[2].greaterEqual.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter3.fire_n[2]", 1, 5, 1957, 65)
DeclareVariable("signalPWM5[2].zeroOrderHold.samplePeriod", "Sample period of component [s]",\
 0.1, 1E-13,1E+100,0.0,0,513)
DeclareVariable("signalPWM5[2].zeroOrderHold.startTime", "First sample time instant [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM5[2].zeroOrderHold.sampleTrigger", "True, if sample time instant [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2690)
DeclareVariable("signalPWM5[2].zeroOrderHold.firstTrigger", "Rising edge signals first sample instant [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2706)
DeclareAlias2("signalPWM5[2].zeroOrderHold.u", "Connector of Real input signal [rad/s]",\
 "signalPWM5[2].limiter.y", 1, 5, 2620, 0)
DeclareAlias2("signalPWM5[2].zeroOrderHold.y", "Connector of Real output signal [rad/s]",\
 "signalPWM5[2].greaterEqual.u2", 1, 5, 2622, 0)
DeclareVariable("signalPWM5[2].zeroOrderHold.ySample", "[rad/s]", 0, 0.0,0.0,0.0,\
0,656)
DeclareVariable("signalPWM5[2].sawtooth.amplitude", "Amplitude of saw tooth", 1,\
 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM5[2].sawtooth.period", "Time for one period [s]", 1, \
1E-60,1E+100,0.0,0,513)
DeclareVariable("signalPWM5[2].sawtooth.nperiod", "Number of periods (< 0 means infinite number of periods) [:#(type=Integer)]",\
 -1, 0.0,0.0,0.0,0,517)
DeclareAlias2("signalPWM5[2].sawtooth.y", "Connector of Real output signal", \
"signalPWM5[2].greaterEqual.u1", 1, 5, 2621, 0)
DeclareVariable("signalPWM5[2].sawtooth.offset", "Offset of output signal y", 0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM5[2].sawtooth.startTime", "Output y = offset for time < startTime [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM5[2].sawtooth.T_start", "Start time of current period [s]",\
 0.0, 0.0,0.0,0.0,0,2688)
DeclareVariable("signalPWM5[2].sawtooth.count", "Period count [:#(type=Integer)]",\
 0, 0.0,0.0,0.0,0,2692)
DeclareAlias2("signalPWM5[2].inverse.u", "Connector of Boolean input signal [:#(type=Boolean)]",\
 "inverter3.fire_n[2]", 1, 5, 1957, 65)
DeclareAlias2("signalPWM5[2].inverse.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter3.fire_p[2]", 1, 5, 1949, 65)
DeclareVariable("signalPWM5[3].useConstantDutyCycle", "Enables constant duty cycle [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("signalPWM5[3].constantDutyCycle", "Constant duty cycle", 343, 0,\
 0.0,0.0,0.0,0,560)
DeclareParameter("signalPWM5[3].f", "Switching frequency [Hz|kHz]", 344, 100000,\
 0.0,0.0,0.0,0,560)
DeclareParameter("signalPWM5[3].startTime", "Start time [s]", 345, 0, 0.0,0.0,\
0.0,0,560)
DeclareAlias2("signalPWM5[3].dutyCycle", "Duty cycle [rad/s]", "variableSpeedDrive_ThreePhase2.y1[1]", 1,\
 5, 2660, 0)
DeclareAlias2("signalPWM5[3].fire", "Firing PWM signal [:#(type=Boolean)]", \
"inverter3.fire_n[3]", 1, 5, 1958, 65)
DeclareAlias2("signalPWM5[3].notFire", "Firing PWM signal [:#(type=Boolean)]", \
"inverter3.fire_p[3]", 1, 5, 1950, 65)
DeclareParameter("signalPWM5[3].limiter.uMax", "Upper limits of input signals [rad/s]",\
 346, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("signalPWM5[3].limiter.uMin", "Lower limits of input signals [rad/s]",\
 347, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("signalPWM5[3].limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("signalPWM5[3].limiter.homotopyType", "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("signalPWM5[3].limiter.limitsAtInit", "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("signalPWM5[3].limiter.u", "Connector of Real input signal [rad/s]",\
 "variableSpeedDrive_ThreePhase2.y1[1]", 1, 5, 2660, 0)
DeclareVariable("signalPWM5[3].limiter.y", "Connector of Real output signal [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("signalPWM5[3].limiter.simplifiedExpr", "Simplified expression for homotopy-based initialization [rad/s]",\
 "variableSpeedDrive_ThreePhase2.y1[1]", 1, 5, 2660, 1024)
DeclareVariable("signalPWM5[3].greaterEqual.u1", "Connector of first Real input signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("signalPWM5[3].greaterEqual.u2", "Connector of second Real input signal [rad/s]",\
 0.0, 0.0,0.0,0.0,0,640)
DeclareAlias2("signalPWM5[3].greaterEqual.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter3.fire_n[3]", 1, 5, 1958, 65)
DeclareVariable("signalPWM5[3].zeroOrderHold.samplePeriod", "Sample period of component [s]",\
 0.1, 1E-13,1E+100,0.0,0,513)
DeclareVariable("signalPWM5[3].zeroOrderHold.startTime", "First sample time instant [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM5[3].zeroOrderHold.sampleTrigger", "True, if sample time instant [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2690)
DeclareVariable("signalPWM5[3].zeroOrderHold.firstTrigger", "Rising edge signals first sample instant [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2706)
DeclareAlias2("signalPWM5[3].zeroOrderHold.u", "Connector of Real input signal [rad/s]",\
 "signalPWM5[3].limiter.y", 1, 5, 2639, 0)
DeclareAlias2("signalPWM5[3].zeroOrderHold.y", "Connector of Real output signal [rad/s]",\
 "signalPWM5[3].greaterEqual.u2", 1, 5, 2641, 0)
DeclareVariable("signalPWM5[3].zeroOrderHold.ySample", "[rad/s]", 0, 0.0,0.0,0.0,\
0,656)
DeclareVariable("signalPWM5[3].sawtooth.amplitude", "Amplitude of saw tooth", 1,\
 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM5[3].sawtooth.period", "Time for one period [s]", 1, \
1E-60,1E+100,0.0,0,513)
DeclareVariable("signalPWM5[3].sawtooth.nperiod", "Number of periods (< 0 means infinite number of periods) [:#(type=Integer)]",\
 -1, 0.0,0.0,0.0,0,517)
DeclareAlias2("signalPWM5[3].sawtooth.y", "Connector of Real output signal", \
"signalPWM5[3].greaterEqual.u1", 1, 5, 2640, 0)
DeclareVariable("signalPWM5[3].sawtooth.offset", "Offset of output signal y", 0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM5[3].sawtooth.startTime", "Output y = offset for time < startTime [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("signalPWM5[3].sawtooth.T_start", "Start time of current period [s]",\
 0.0, 0.0,0.0,0.0,0,2688)
DeclareVariable("signalPWM5[3].sawtooth.count", "Period count [:#(type=Integer)]",\
 0, 0.0,0.0,0.0,0,2692)
DeclareAlias2("signalPWM5[3].inverse.u", "Connector of Boolean input signal [:#(type=Boolean)]",\
 "inverter3.fire_n[3]", 1, 5, 1958, 65)
DeclareAlias2("signalPWM5[3].inverse.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "inverter3.fire_p[3]", 1, 5, 1950, 65)
DeclareState("variableSpeedDrive_ThreePhase2.speedSensor.flange.phi", \
"Absolute rotation angle of flange [rad|deg]", 21, 0.0, 0.0,0.0,0.0,0,568)
DeclareDerivative("variableSpeedDrive_ThreePhase2.speedSensor.flange.der(phi)", \
"der(Absolute rotation angle of flange) [rad/s]", 0.0, 0.0,0.0,0.0,0,520)
DeclareVariable("variableSpeedDrive_ThreePhase2.speedSensor.flange.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("variableSpeedDrive_ThreePhase2.speedSensor.w", "Absolute angular velocity of flange as output signal [rad/s]",\
 "variableSpeedDrive_ThreePhase2.speedSensor.flange.der(phi)", 1, 6, 21, 0)
DeclareVariable("variableSpeedDrive_ThreePhase2.currentController.k", "Gain [1]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("variableSpeedDrive_ThreePhase2.currentController.T", \
"Time Constant (T>0 required) [s]", 1, 1E-60,1E+100,0.0,0,513)
DeclareVariable("variableSpeedDrive_ThreePhase2.currentController.initType", \
"Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareParameter("variableSpeedDrive_ThreePhase2.currentController.x_start", \
"Initial or guess value of state [rad/s]", 348, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("variableSpeedDrive_ThreePhase2.currentController.y_start", \
"Initial value of output [rad/s]", 349, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("variableSpeedDrive_ThreePhase2.currentController.u", \
"Connector of Real input signal [rad/s]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("variableSpeedDrive_ThreePhase2.currentController.y", \
"Connector of Real output signal [rad/s]", "variableSpeedDrive_ThreePhase2.y1[1]", 1,\
 5, 2660, 0)
DeclareState("variableSpeedDrive_ThreePhase2.currentController.x", \
"State of block [rad/s]", 22, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("variableSpeedDrive_ThreePhase2.currentController.der(x)", \
"der(State of block) [rad/s2]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("variableSpeedDrive_ThreePhase2.flange1.phi", "Absolute rotation angle of flange [rad|deg]",\
 "variableSpeedDrive_ThreePhase2.speedSensor.flange.phi", 1, 1, 21, 4)
DeclareVariable("variableSpeedDrive_ThreePhase2.flange1.tau", "Cut torque in the flange [N.m]",\
 0, 0.0,0.0,0.0,0,777)
DeclareVariable("variableSpeedDrive_ThreePhase2.y1[1]", "Connector of Real output signal [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("variableSpeedDrive_ThreePhase2.y1[2]", "Connector of Real output signal [rad/s]",\
 "variableSpeedDrive_ThreePhase2.y1[1]", 1, 5, 2660, 0)
DeclareAlias2("variableSpeedDrive_ThreePhase2.y1[3]", "Connector of Real output signal [rad/s]",\
 "variableSpeedDrive_ThreePhase2.y1[1]", 1, 5, 2660, 0)
DeclareVariable("variableSpeedDrive_ThreePhase2.const.k", "Constant output value [rad/s]",\
 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("variableSpeedDrive_ThreePhase2.const.y", "Connector of Real output signal [rad/s]",\
 "variableSpeedDrive_ThreePhase2.const.k", 1, 5, 2661, 0)
DeclareParameter("variableSpeedDrive_ThreePhase2.wref", "Constant output value [rad/s]",\
 350, 41000, 0.0,0.0,0.0,0,560)
DeclareAlias2("variableSpeedDrive_ThreePhase2.feedback.u1", "[rad/s]", \
"variableSpeedDrive_ThreePhase2.speedSensor.flange.der(phi)", 1, 6, 21, 0)
DeclareAlias2("variableSpeedDrive_ThreePhase2.feedback.u2", "[rad/s]", \
"variableSpeedDrive_ThreePhase2.const.k", 1, 5, 2661, 0)
DeclareAlias2("variableSpeedDrive_ThreePhase2.feedback.y", "[rad/s]", \
"variableSpeedDrive_ThreePhase2.currentController.u", 1, 5, 2658, 0)
DeclareParameter("variableSpeedDrive_ThreePhase2.T", "Time Constant (T>0 required) [s]",\
 351, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("variableSpeedDrive_ThreePhase2.k", "Gain [1]", 352, 1, \
0.0,0.0,0.0,0,560)
DeclareAlias2("variableSpeedDrive_ThreePhase2.realExtend.u", "[rad/s]", \
"variableSpeedDrive_ThreePhase2.y1[1]", 1, 5, 2660, 0)
DeclareAlias2("variableSpeedDrive_ThreePhase2.realExtend.y[1]", "[rad/s]", \
"variableSpeedDrive_ThreePhase2.y1[1]", 1, 5, 2660, 0)
DeclareAlias2("variableSpeedDrive_ThreePhase2.realExtend.y[2]", "[rad/s]", \
"variableSpeedDrive_ThreePhase2.y1[1]", 1, 5, 2660, 0)
DeclareAlias2("variableSpeedDrive_ThreePhase2.realExtend.y[3]", "[rad/s]", \
"variableSpeedDrive_ThreePhase2.y1[1]", 1, 5, 2660, 0)
DeclareAlias2("fan2.inertia.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "variableSpeedDrive_ThreePhase2.speedSensor.flange.phi", 1, 1, 21, 4)
DeclareAlias2("fan2.inertia.flange_a.tau", "Cut torque in the flange [N.m]", \
"threePhaseMotor2.flange1.tau", -1, 5, 2573, 132)
DeclareAlias2("fan2.inertia.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "variableSpeedDrive_ThreePhase2.speedSensor.flange.phi", 1, 1, 21, 4)
DeclareVariable("fan2.inertia.flange_b.tau", "Cut torque in the flange [N.m]", \
0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("fan2.inertia.J", "Moment of inertia [kg.m2]", 1, 0.0,1E+100,0.0,\
0,513)
DeclareVariable("fan2.inertia.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 3, 1.0,5.0,0.0,0,1541)
DeclareAlias2("fan2.inertia.phi", "Absolute rotation angle of component [rad|deg]",\
 "variableSpeedDrive_ThreePhase2.speedSensor.flange.phi", 1, 1, 21, 0)
DeclareAlias2("fan2.inertia.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 "fan2.inertia.w", 1, 1, 23, 0)
DeclareState("fan2.inertia.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 23, 0, 0.0,0.0,0.0,0,544)
DeclareDerivative("fan2.inertia.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("fan2.inertia.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "fan2.inertia.der(w)", 1, 6, 23, 0)
DeclareAlias2("fan2.flange_a1.phi", "Absolute rotation angle of flange [rad|deg]",\
 "variableSpeedDrive_ThreePhase2.speedSensor.flange.phi", 1, 1, 21, 4)
DeclareAlias2("fan2.flange_a1.tau", "Cut torque in the flange [N.m]", \
"threePhaseMotor2.flange1.tau", -1, 5, 2573, 132)
DeclareParameter("fan2.J", "Moment of inertia of the fan blades [kg.m2]", 353, 1,\
 0.0,0.0,0.0,0,560)
DeclareParameter("fan2.deltaPhi", "Fixed rotation of left flange with respect to right flange [rad|deg]",\
 354, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("resistor.R", "Resistance at temperature T_ref [Ohm]", 355, 10,\
 0.0,0.0,0.0,0,560)
DeclareParameter("resistor.T_ref", "Reference temperature [K|degC]", 356, 300.15,\
 0.0,1E+100,300.0,0,560)
DeclareParameter("resistor.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 357, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("resistor.v", "Voltage drop of the two pins (= p.v - n.v) [V]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("resistor.i", "Current flowing from pin p to pin n [A]", \
"inverter2.dc_p.i", 1, 5, 37, 0)
DeclareAlias2("resistor.p.v", "Potential at the pin [V]", "dcdc.dc_p2.v", 1, 5, 287,\
 4)
DeclareAlias2("resistor.p.i", "Current flowing into the pin [A]", \
"inverter2.dc_p.i", 1, 5, 37, 132)
DeclareAlias2("resistor.n.v", "Potential at the pin [V]", "inverter2.dc_p.v", 1,\
 5, 36, 4)
DeclareAlias2("resistor.n.i", "Current flowing into the pin [A]", \
"inverter2.dc_p.i", -1, 5, 37, 132)
DeclareVariable("resistor.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("resistor.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("resistor.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("resistor.T_heatPort", "Temperature of heatPort [K|degC]", \
"resistor.T", 1, 5, 2667, 0)
DeclareVariable("resistor.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("resistor1.R", "Resistance at temperature T_ref [Ohm]", 358, 10,\
 0.0,0.0,0.0,0,560)
DeclareParameter("resistor1.T_ref", "Reference temperature [K|degC]", 359, \
300.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("resistor1.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 360, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("resistor1.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("resistor1.i", "Current flowing from pin p to pin n [A]", \
"inverter2.dc_n.i", 1, 5, 39, 0)
DeclareAlias2("resistor1.p.v", "Potential at the pin [V]", "simplifiedFuelCell.pin_p1.v", 1,\
 5, 21, 4)
DeclareAlias2("resistor1.p.i", "Current flowing into the pin [A]", \
"inverter2.dc_n.i", 1, 5, 39, 132)
DeclareAlias2("resistor1.n.v", "Potential at the pin [V]", "inverter2.dc_n.v", 1,\
 5, 38, 4)
DeclareAlias2("resistor1.n.i", "Current flowing into the pin [A]", \
"inverter2.dc_n.i", -1, 5, 39, 132)
DeclareVariable("resistor1.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("resistor1.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("resistor1.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("resistor1.T_heatPort", "Temperature of heatPort [K|degC]", \
"resistor1.T", 1, 5, 2672, 0)
DeclareVariable("resistor1.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("hTS_exploss.temperature", "", 361, 100, 0.0,0.0,0.0,0,560)
DeclareParameter("hTS_exploss.l", "Length of wire [m]", 362, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("hTS_exploss.E_0", "Reference electric field [V/m]", 363, \
0.0001, 0.0,0.0,0.0,0,560)
DeclareParameter("hTS_exploss.n", "Intrinstic value of the superconductor", 364,\
 1, 0.0,0.0,0.0,0,560)
DeclareParameter("hTS_exploss.I_c", "corner current [A]", 365, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("hTS_exploss.E", "Electric field [V/m]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("hTS_exploss.pin_p.v", "Potential at the pin [V]", "dcdc2.dc_p2.v", 1,\
 5, 2210, 4)
DeclareAlias2("hTS_exploss.pin_p.i", "Current flowing into the pin [A]", \
"inverter3.dc_p.i", -1, 5, 1960, 132)
DeclareAlias2("hTS_exploss.pin_n.v", "Potential at the pin [V]", \
"inverter3.dc_p.v", 1, 5, 1959, 4)
DeclareAlias2("hTS_exploss.pin_n.i", "Current flowing into the pin [A]", \
"inverter3.dc_p.i", -1, 5, 1960, 132)
DeclareParameter("hTS_exploss.R", "Resistance at temperature T_ref [Ohm]", 366, 100,\
 0.0,0.0,0.0,0,560)
DeclareParameter("hTS_exploss1.temperature", "", 367, 100, 0.0,0.0,0.0,0,560)
DeclareParameter("hTS_exploss1.l", "Length of wire [m]", 368, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("hTS_exploss1.E_0", "Reference electric field [V/m]", 369, \
0.0001, 0.0,0.0,0.0,0,560)
DeclareParameter("hTS_exploss1.n", "Intrinstic value of the superconductor", 370,\
 1, 0.0,0.0,0.0,0,560)
DeclareParameter("hTS_exploss1.I_c", "corner current [A]", 371, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("hTS_exploss1.E", "Electric field [V/m]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("hTS_exploss1.pin_p.v", "Potential at the pin [V]", \
"simplifiedFuelCell1.pin_p1.v", 1, 5, 1944, 4)
DeclareAlias2("hTS_exploss1.pin_p.i", "Current flowing into the pin [A]", \
"inverter3.dc_n.i", -1, 5, 1962, 132)
DeclareAlias2("hTS_exploss1.pin_n.v", "Potential at the pin [V]", \
"inverter3.dc_n.v", 1, 5, 1961, 4)
DeclareAlias2("hTS_exploss1.pin_n.i", "Current flowing into the pin [A]", \
"inverter3.dc_n.i", -1, 5, 1962, 132)
DeclareParameter("hTS_exploss1.R", "Resistance at temperature T_ref [Ohm]", 372,\
 100, 0.0,0.0,0.0,0,560)
DeclareAlias2("batteryPack.core.impedance.cellState.R_max_ch", "Value of Real output [Ohm]",\
 "batteryPack.summary.core_R_max_dch[1, 1]", 1, 5, 1510, 4)
DeclareAlias2("batteryPack.core.impedance.cellState.R_max_dch", "Value of Real output [Ohm]",\
 "batteryPack.summary.core_R_max_dch[1, 1]", 1, 5, 1510, 4)
DeclareAlias2("batteryPack.core.sensors.signals.v_sns", "Value of Real output [V]",\
 "batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 4)
DeclareAlias2("batteryPack.core.sensors.signals.ocv_sns", "Value of Real output [V]",\
 "batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 4)
DeclareVariable("batteryPack.core.sensors.signals.i_sns", "Value of Real output [A]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("batteryPack.core.sensors.signals.R_max_dch_sns", "Value of Real output [Ohm]",\
 "batteryPack.summary.core_R_max_dch[1, 1]", 1, 5, 1510, 4)
DeclareAlias2("batteryPack.core.sensors.signals.cell_v_sns", "Value of Real output [V]",\
 "batteryPack.core.sensors.cell_v_sns", 1, 5, 1718, 4)
DeclareAlias2("batteryPack.core.sensors.signals.cell_ocv_sns", "Value of Real output [V]",\
 "batteryPack.core.sensors.cell_ocv_sns", 1, 5, 1719, 4)
DeclareVariable("batteryPack.core.sensors.signals.cell_i_sns", "Value of Real output [A]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("batteryPack.core.sensors.signals.cell_R_max_dch_sns", \
"Value of Real output [Ohm]", "batteryPack.core.sensors.cell_R_max_dch_sns", 1, 5,\
 1721, 4)
DeclareAlias2("batteryPack.core.sensors.signals.SoC_sns", "Value of Real output [1]",\
 "batteryPack.core.capacity.limitSoC.x", 1, 5, 1597, 4)
DeclareAlias2("batteryPack.core.sensors.signals.T_sns", "Value of Real output [K]",\
 "batteryPack.thermal.internalMass.T", 1, 1, 15, 4)
DeclareAlias2("batteryPack.electrical.sensors.signals.core_v_sns", \
"Value of Real output [V]", "batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622,\
 4)
DeclareVariable("batteryPack.electrical.sensors.signals.core_i_sns", \
"Value of Real output [A]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("batteryPack.electrical.sensors.signals.core_p_sns", \
"Connector of Real output signal [W]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("batteryPack.electrical.sensors.signals.link_v_sns", \
"Value of Real output [V]", "batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622,\
 4)
DeclareVariable("batteryPack.electrical.sensors.signals.link_i_sns", \
"Value of Real output [A]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("batteryPack.electrical.sensors.signals.link_p_sns", \
"Connector of Real output signal [W]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("batteryPack.thermal.adaptAmbient.battery.ambient.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareAlias2("batteryPack.thermal.adaptAmbient.battery.ambient.T", \
"Port temperature [K|degC]", "batteryPack.thermal.adaptAmbient.heat.T", 1, 5, 1802,\
 4)
DeclareVariable("batteryPack.thermal.adaptCellsLumped.battery.cellsLumped.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareAlias2("batteryPack.thermal.adaptCellsLumped.battery.cellsLumped.T", \
"Port temperature [K|degC]", "batteryPack.thermal.internalMass.T", 1, 1, 15, 4)
DeclareAlias2("batteryPack.thermal.sensors.signals.T_sns", "Value of Real output [K]",\
 "batteryPack.thermal.internalMass.T", 1, 1, 15, 4)
DeclareVariable("batteryPack.thermal.sensors.signals.T_core_sns[1, 1]", \
"Value of Real output", 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("batteryPack.controller.core[1, 1].R_max_dch_sns", \
"Value of Real output [Ohm]", "batteryPack.summary.core_R_max_dch[1, 1]", 1, 5, 1510,\
 4)
DeclareAlias2("batteryPack.controller.core[1, 1].SoC_sns", "Value of Real output [1]",\
 "batteryPack.core.capacity.limitSoC.x", 1, 5, 1597, 4)
DeclareAlias2("batteryPack.controller.core[1, 1].T_sns", "Value of Real output [K]",\
 "batteryPack.thermal.internalMass.T", 1, 1, 15, 4)
DeclareAlias2("batteryPack.controller.core[1, 1].cell_R_max_dch_sns", \
"Value of Real output [Ohm]", "batteryPack.core.sensors.cell_R_max_dch_sns", 1, 5,\
 1721, 4)
DeclareVariable("batteryPack.controller.core[1, 1].cell_i_sns", "Value of Real output [A]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("batteryPack.controller.core[1, 1].cell_ocv_sns", "Value of Real output [V]",\
 "batteryPack.core.sensors.cell_ocv_sns", 1, 5, 1719, 4)
DeclareAlias2("batteryPack.controller.core[1, 1].cell_v_sns", "Value of Real output [V]",\
 "batteryPack.core.sensors.cell_v_sns", 1, 5, 1718, 4)
DeclareVariable("batteryPack.controller.core[1, 1].i_sns", "Value of Real output [A]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("batteryPack.controller.core[1, 1].ocv_sns", "Value of Real output [V]",\
 "batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 4)
DeclareAlias2("batteryPack.controller.core[1, 1].v_sns", "Value of Real output [V]",\
 "batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 4)
DeclareAlias2("batteryPack.core.signals.R_max_dch_sns", "Value of Real output [Ohm]",\
 "batteryPack.summary.core_R_max_dch[1, 1]", 1, 5, 1510, 4)
DeclareAlias2("batteryPack.core.signals.SoC_sns", "Value of Real output [1]", \
"batteryPack.core.capacity.limitSoC.x", 1, 5, 1597, 4)
DeclareAlias2("batteryPack.core.signals.T_sns", "Value of Real output [K]", \
"batteryPack.thermal.internalMass.T", 1, 1, 15, 4)
DeclareAlias2("batteryPack.core.signals.cell_R_max_dch_sns", "Value of Real output [Ohm]",\
 "batteryPack.core.sensors.cell_R_max_dch_sns", 1, 5, 1721, 4)
DeclareVariable("batteryPack.core.signals.cell_i_sns", "Value of Real output [A]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("batteryPack.core.signals.cell_ocv_sns", "Value of Real output [V]",\
 "batteryPack.core.sensors.cell_ocv_sns", 1, 5, 1719, 4)
DeclareAlias2("batteryPack.core.signals.cell_v_sns", "Value of Real output [V]",\
 "batteryPack.core.sensors.cell_v_sns", 1, 5, 1718, 4)
DeclareVariable("batteryPack.core.signals.i_sns", "Value of Real output [A]", \
0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("batteryPack.core.signals.ocv_sns", "Value of Real output [V]", \
"batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 4)
DeclareAlias2("batteryPack.core.signals.v_sns", "Value of Real output [V]", \
"batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 4)
DeclareVariable("batteryPack.controller.electrical.core_i_sns", "Value of Real output [A]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("batteryPack.controller.electrical.core_p_sns", "Connector of Real output signal [W]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("batteryPack.controller.electrical.core_v_sns", "Value of Real output [V]",\
 "batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 4)
DeclareVariable("batteryPack.controller.electrical.link_i_sns", "Value of Real output [A]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("batteryPack.controller.electrical.link_p_sns", "Connector of Real output signal [W]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("batteryPack.controller.electrical.link_v_sns", "Value of Real output [V]",\
 "batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 4)
DeclareVariable("batteryPack.electrical.signals.core_i_sns", "Value of Real output [A]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("batteryPack.electrical.signals.core_p_sns", "Connector of Real output signal [W]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("batteryPack.electrical.signals.core_v_sns", "Value of Real output [V]",\
 "batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 4)
DeclareVariable("batteryPack.electrical.signals.link_i_sns", "Value of Real output [A]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("batteryPack.electrical.signals.link_p_sns", "Connector of Real output signal [W]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("batteryPack.electrical.signals.link_v_sns", "Value of Real output [V]",\
 "batteryPack.core.voltage.limitCellOCV.x", 1, 5, 1622, 4)
DeclareVariable("batteryPack.controller.thermal.T_core_sns[1, 1]", \
"Value of Real output", 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("batteryPack.controller.thermal.T_sns", "Value of Real output [K]",\
 "batteryPack.thermal.internalMass.T", 1, 1, 15, 4)
DeclareVariable("batteryPack.thermal.signals.T_core_sns[1, 1]", "Value of Real output",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("batteryPack.thermal.signals.T_sns", "Value of Real output [K]", \
"batteryPack.thermal.internalMass.T", 1, 1, 15, 4)
DeclareAlias2("batteryPack.core.aging.cellState.R_max_ch", "Value of Real output [Ohm]",\
 "batteryPack.summary.core_R_max_dch[1, 1]", 1, 5, 1510, 4)
DeclareAlias2("batteryPack.core.aging.cellState.R_max_dch", "Value of Real output [Ohm]",\
 "batteryPack.summary.core_R_max_dch[1, 1]", 1, 5, 1510, 4)
DeclareAlias2("batteryPack.core.capacity.cellState.R_max_ch", "Value of Real output [Ohm]",\
 "batteryPack.summary.core_R_max_dch[1, 1]", 1, 5, 1510, 4)
DeclareAlias2("batteryPack.core.capacity.cellState.R_max_dch", "Value of Real output [Ohm]",\
 "batteryPack.summary.core_R_max_dch[1, 1]", 1, 5, 1510, 4)
DeclareAlias2("batteryPack.core.selfDischarge.cellState.R_max_ch", \
"Value of Real output [Ohm]", "batteryPack.summary.core_R_max_dch[1, 1]", 1, 5, 1510,\
 4)
DeclareAlias2("batteryPack.core.selfDischarge.cellState.R_max_dch", \
"Value of Real output [Ohm]", "batteryPack.summary.core_R_max_dch[1, 1]", 1, 5, 1510,\
 4)
DeclareAlias2("batteryPack.core.sensors.cellState.R_max_ch", "Value of Real output [Ohm]",\
 "batteryPack.summary.core_R_max_dch[1, 1]", 1, 5, 1510, 4)
DeclareAlias2("batteryPack.core.sensors.cellState.R_max_dch", "Value of Real output [Ohm]",\
 "batteryPack.summary.core_R_max_dch[1, 1]", 1, 5, 1510, 4)
DeclareAlias2("batteryPack.core.voltage.cellState.R_max_ch", "Value of Real output [Ohm]",\
 "batteryPack.summary.core_R_max_dch[1, 1]", 1, 5, 1510, 4)
DeclareAlias2("batteryPack.core.voltage.cellState.R_max_dch", "Value of Real output [Ohm]",\
 "batteryPack.summary.core_R_max_dch[1, 1]", 1, 5, 1510, 4)
EndNonAlias(2)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
}
StartDataBlock
StartPreBlock
pre(DYNX(W_,1603),"batteryPack.core.capacity.limitSoC.lower_limit_active", false,
   49);
pre(DYNX(W_,1602),"batteryPack.core.capacity.limitSoC.upper_limit_active", false,
   48);
pre(DYNX(W_,1732),"batteryPack.core.limitCurrent.lower_limit_active", false, 55);
pre(DYNX(W_,1731),"batteryPack.core.limitCurrent.upper_limit_active", false, 54);
pre(DYNX(W_,1741),"batteryPack.core.limitPower.lower_limit_active", false, 57);
pre(DYNX(W_,1740),"batteryPack.core.limitPower.upper_limit_active", false, 56);
pre(DYNX(W_,1706),"batteryPack.core.limitVoltage.lower_limit_active", false, 53);
pre(DYNX(W_,1705),"batteryPack.core.limitVoltage.upper_limit_active", false, 52);
pre(DYNX(W_,1629),"batteryPack.core.voltage.limitCellOCV.lower_limit_active", 
  false, 51);
pre(DYNX(W_,1628),"batteryPack.core.voltage.limitCellOCV.upper_limit_active", 
  false, 50);
pre(DYNX(W_,1850),"batteryPack.limitDischarge.lower_limit_active", false, 59);
pre(DYNX(W_,1849),"batteryPack.limitDischarge.upper_limit_active", false, 58);
preWD(DYNX(W_,1880),"circuitBreaker4.switch.off", false, 0);
preWD(DYNX(W_,1891),"circuitBreaker5.switch.off", false, 1);
preWD(DYNX(W_,1907),"circuitBreaker6.switch.off", false, 2);
preWD(DYNX(W_,1918),"circuitBreaker7.switch.off", false, 3);
preWD(DYNX(W_,301),"dcdc.andCondition_p.y", false, 4);
preWD(DYNX(W_,1022),"dcdc1.andCondition_p.y", false, 5);
preWD(DYNX(W_,1040),"dcdc1.diode.off", true, 6);
preWD(DYNX(W_,1030),"dcdc1.transistor.off", true, 7);
preWD(DYNX(W_,911),"inverter1.transistor_n.fire[1]", false, 8);
preWD(DYNX(W_,912),"inverter1.transistor_n.fire[2]", false, 9);
preWD(DYNX(W_,913),"inverter1.transistor_n.fire[3]", false, 10);
preWD(DYNX(W_,797),"inverter1.transistor_p.fire[1]", false, 11);
preWD(DYNX(W_,798),"inverter1.transistor_p.fire[2]", false, 12);
preWD(DYNX(W_,799),"inverter1.transistor_p.fire[3]", false, 13);
preWD(DYNX(W_,194),"inverter2.transistor_n.fire[1]", false, 14);
preWD(DYNX(W_,195),"inverter2.transistor_n.fire[2]", false, 15);
preWD(DYNX(W_,196),"inverter2.transistor_n.fire[3]", false, 16);
preWD(DYNX(W_,80),"inverter2.transistor_p.fire[1]", false, 17);
preWD(DYNX(W_,81),"inverter2.transistor_p.fire[2]", false, 18);
preWD(DYNX(W_,82),"inverter2.transistor_p.fire[3]", false, 19);
preWD(DYNX(W_,2117),"inverter3.transistor_n.fire[1]", false, 20);
preWD(DYNX(W_,2118),"inverter3.transistor_n.fire[2]", false, 21);
preWD(DYNX(W_,2119),"inverter3.transistor_n.fire[3]", false, 22);
preWD(DYNX(W_,2003),"inverter3.transistor_p.fire[1]", false, 23);
preWD(DYNX(W_,2004),"inverter3.transistor_p.fire[2]", false, 24);
preWD(DYNX(W_,2005),"inverter3.transistor_p.fire[3]", false, 25);
pre(DYNX(W_,1064),"signalPWM1.sawtooth.count", 0, 34);
pre(DYNX(W_,1057),"signalPWM1.zeroOrderHold.ySample", 0, 35);
pre(DYNX(W_,344),"signalPWM2.sawtooth.count", 0, 26);
pre(DYNX(W_,337),"signalPWM2.zeroOrderHold.ySample", 0, 27);
pre(DYNX(W_,1412),"signalPWM3[1].sawtooth.count", 0, 40);
pre(DYNX(W_,1405),"signalPWM3[1].zeroOrderHold.ySample", 0, 41);
pre(DYNX(W_,1431),"signalPWM3[2].sawtooth.count", 0, 36);
pre(DYNX(W_,1424),"signalPWM3[2].zeroOrderHold.ySample", 0, 37);
pre(DYNX(W_,1450),"signalPWM3[3].sawtooth.count", 0, 38);
pre(DYNX(W_,1443),"signalPWM3[3].zeroOrderHold.ySample", 0, 39);
pre(DYNX(W_,2267),"signalPWM4.sawtooth.count", 0, 60);
pre(DYNX(W_,2260),"signalPWM4.zeroOrderHold.ySample", 0, 61);
pre(DYNX(W_,2615),"signalPWM5[1].sawtooth.count", 0, 42);
pre(DYNX(W_,2608),"signalPWM5[1].zeroOrderHold.ySample", 0, 43);
pre(DYNX(W_,2634),"signalPWM5[2].sawtooth.count", 0, 46);
pre(DYNX(W_,2627),"signalPWM5[2].zeroOrderHold.ySample", 0, 47);
pre(DYNX(W_,2653),"signalPWM5[3].sawtooth.count", 0, 44);
pre(DYNX(W_,2646),"signalPWM5[3].zeroOrderHold.ySample", 0, 45);
pre(DYNX(W_,692),"signalPWM[1].sawtooth.count", 0, 32);
pre(DYNX(W_,685),"signalPWM[1].zeroOrderHold.ySample", 0, 33);
pre(DYNX(W_,711),"signalPWM[2].sawtooth.count", 0, 28);
pre(DYNX(W_,704),"signalPWM[2].zeroOrderHold.ySample", 0, 29);
pre(DYNX(W_,730),"signalPWM[3].sawtooth.count", 0, 30);
pre(DYNX(W_,723),"signalPWM[3].zeroOrderHold.ySample", 0, 31);
EndPreBlock
StartEqBlock
DoRemember_(DYNX(W_,1881), 0.0, 28);
DoRemember_(DYNX(W_,1892), 0.0, 23);
DoRemember_(DYNX(W_,1908), 0.0, 27);
DoRemember_(DYNX(W_,1919), 0.0, 24);
DoRemember_(DYNX(W_,321), 0, 9);
DoRemember_(DYNX(W_,311), 0, 8);
DoRemember_(DYNX(W_,1041), 0, 29);
DoRemember_(DYNX(W_,1031), 0, 30);
DoRememAcc_(DYNX(W_,2244), 0, 74);
DoRememAcc_(DYNX(W_,2234), 0, 73);
DoRemember_(DYNX(F_,15), 0.0, 51);
DoRemember_(DYNX(F_,6), 0.0, 20);
DoRemember_(DYNX(F_,13), 0.0, 48);
DoRemember_(DYNX(F_,23), 0.0, 70);
DoRemember_(DYNX(F_,16), 0.0, 39);
DoRemember_(DYNX(F_,2), 0.0, 17);
DoRemember_(DYNX(F_,3), 0.0, 19);
DoRemember_(DYNX(F_,0), 0.0, 22);
DoRemember_(DYNX(F_,1), 0.0, 21);
DoRemember_(DYNX(W_,480), 0.0, 18);
DoRemember_(DYNX(W_,481), 0.0, 16);
DoRemember_(DYNX(F_,9), 0.0, 45);
DoRemember_(DYNX(F_,10), 0.0, 47);
DoRemember_(DYNX(F_,7), 0.0, 50);
DoRemember_(DYNX(F_,8), 0.0, 49);
DoRemember_(DYNX(W_,1200), 0.0, 46);
DoRemember_(DYNX(W_,1201), 0.0, 44);
DoRemember_(DYNX(F_,19), 0.0, 67);
DoRemember_(DYNX(F_,20), 0.0, 69);
DoRemember_(DYNX(F_,17), 0.0, 72);
DoRemember_(DYNX(F_,18), 0.0, 71);
DoRemember_(DYNX(W_,2403), 0.0, 68);
DoRemember_(DYNX(W_,2404), 0.0, 66);
DoRemember_(DYNX(W_,761), 0.0, 26);
DoRemember_(DYNX(W_,765), 0.0, 25);
DoRemember_(DYNX(W_,974), 0, 38);
DoRemember_(DYNX(W_,984), 0, 43);
DoRemember_(DYNX(W_,994), 0, 34);
DoRemember_(DYNX(W_,860), 0, 41);
DoRemember_(DYNX(W_,870), 0, 42);
DoRemember_(DYNX(W_,880), 0, 35);
DoRemember_(DYNX(W_,921), 0, 37);
DoRemember_(DYNX(W_,931), 0, 31);
DoRemember_(DYNX(W_,941), 0, 33);
DoRemember_(DYNX(W_,807), 0, 40);
DoRemember_(DYNX(W_,817), 0, 36);
DoRemember_(DYNX(W_,827), 0, 32);
DoRemember_(DYNX(W_,44), 0.0, 1);
DoRemember_(DYNX(W_,48), 0.0, 0);
DoRemember_(DYNX(W_,257), 0, 11);
DoRemember_(DYNX(W_,267), 0, 14);
DoRemember_(DYNX(W_,277), 0, 7);
DoRemember_(DYNX(W_,143), 0, 10);
DoRemember_(DYNX(W_,153), 0, 13);
DoRemember_(DYNX(W_,163), 0, 6);
DoRemember_(DYNX(W_,204), 0, 2);
DoRemember_(DYNX(W_,214), 0, 15);
DoRemember_(DYNX(W_,224), 0, 5);
DoRemember_(DYNX(W_,90), 0, 3);
DoRemember_(DYNX(W_,100), 0, 12);
DoRemember_(DYNX(W_,110), 0, 4);
DoRemember_(DYNX(W_,1967), 0.0, 53);
DoRemember_(DYNX(W_,1971), 0.0, 52);
DoRemember_(DYNX(W_,2180), 0, 59);
DoRemember_(DYNX(W_,2190), 0, 62);
DoRemember_(DYNX(W_,2200), 0, 58);
DoRemember_(DYNX(W_,2066), 0, 65);
DoRemember_(DYNX(W_,2076), 0, 63);
DoRemember_(DYNX(W_,2086), 0, 57);
DoRemember_(DYNX(W_,2127), 0, 54);
DoRemember_(DYNX(W_,2137), 0, 61);
DoRemember_(DYNX(W_,2147), 0, 56);
DoRemember_(DYNX(W_,2013), 0, 64);
DoRemember_(DYNX(W_,2023), 0, 60);
DoRemember_(DYNX(W_,2033), 0, 55);
EndEqBlock
UpdateQEvaluate(47)
UpdateSampleCounters(12)
EndDataBlock

BreakSectionFunctionStart(0);
BreakSectionFunctionCallNew(1);
BreakSectionFunctionCallNew(2);
BreakSectionFunctionCallNew(3);
BreakSectionFunctionCallNew(4);
BreakSectionFunctionCallNew(5);
BreakSectionFunctionCallNew(6);
BreakSectionFunctionCallNew(7);
BreakSectionFunctionCallNew(8);
BreakSectionFunctionCallNew(9);
BreakSectionFunctionCallNew(10);
BreakSectionFunctionCallNew(11);
BreakSectionFunctionCallNew(12);
BreakSectionFunctionCallNew(13);
BreakSectionFunctionCallNew(14);
BreakSectionFunctionCallNew(15);
BreakSectionFunctionEnd()
